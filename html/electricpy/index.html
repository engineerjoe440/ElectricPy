<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>electricpy API documentation</title>
<meta name="description" content="`electricpy.py`
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>electricpy</code></h1>
</header>
<section id="section-intro">
<hr>
<h2 id="electricpypy"><code>electricpy.py</code></h2>
<p><code>A library of functions, constants and more
that are related to Power in Electrical Engineering.</code></p>
<p>Written by Joe Stanley</p>
<h2 id="included-constants">Included Constants</h2>
<ul>
<li>Pico Multiple:
p</li>
<li>Nano Multiple:
n</li>
<li>Micro (mu) Multiple:
u</li>
<li>Mili Multiple:
m</li>
<li>Kilo Multiple:
k</li>
<li>Mega Multiple:
M</li>
<li>'A' Operator for Symmetrical Components:
a</li>
<li>Not a Number value (NaN):
NAN</li>
</ul>
<p>Additional constants may not be listed. For a complete list,
visit constants page.</p>
<h2 id="symmetrical-components-matricies">Symmetrical Components Matricies</h2>
<ul>
<li>ABC to 012 Conversion:
Aabc</li>
<li>012 to ABC Conversion:
A012</li>
</ul>
<h2 id="included-functions">Included Functions</h2>
<ul>
<li>Phasor V/I Generator:
phasor</li>
<li>Phasor Array V/I Generator:
phasorlist</li>
<li>Phasor Data Genorator:
phasordata</li>
<li>Phase Angle Generator:
phs</li>
<li>Time of Number of Cycles:
tcycle
</li>
<li>Phasor Impedance Generator:
phasorz</li>
<li>Complex Display Function:
cprint</li>
<li>Complex LaTeX Display Function:
clatex</li>
<li>Transfer Function LaTeX Generator:
tflatex</li>
<li>Parallel Impedance Adder:
parallelz</li>
<li>V/I Line/Phase Converter:
phaseline</li>
<li>Power Set Values:
powerset</li>
<li>Power Triangle Function:
powertriangle</li>
<li>Transformer SC OC Tests:
transformertest</li>
<li>Phasor Plot Generator:
phasorplot</li>
<li>Total Harmonic Distortion:
thd</li>
<li>Total Demand Distortion:
tdd</li>
<li>Reactance Calculator:
reactance</li>
<li>Non-Linear PF Calc:
nlinpf</li>
<li>Harmonic Limit Calculator:
harmoniclimit</li>
<li>Power Factor Distiortion:
pfdist</li>
<li>Short-Circuit RL Current:
iscrl</li>
<li>Voltage Divider:
voltdiv</li>
<li>Current Divider:
curdiv</li>
<li>Instantaneous Power Calc.:
instpower</li>
<li>Delta-Wye Network Converter:
dynetz</li>
<li>Single Line Power Flow:
powerflow</li>
<li>Thermocouple Temperature:
thermocouple</li>
<li>Cold Junction Voltage:
coldjunction</li>
<li>RTD Temperature Calculator:
rtdtemp</li>
<li>Horsepower to Watts:
hp_to_watts</li>
<li>Watts to Horsepower:
watts_to_hp</li>
<li>Inductor Charge:
inductorcharge</li>
<li>Inductor Discharge:
inductordischarge</li>
<li>Inductor Stored Energy:
inductorenergy
</li>
<li>Back-to-Back Cap. Surge:
capbacktoback
</li>
<li>Capacitor Stored Energy:
energy</li>
<li>Cap. Voltage after Time:
VafterT</li>
<li>Cap. Voltage Discharge:
vcapdischarge</li>
<li>Cap. Voltage Charge:
vcapcharge</li>
<li>Rectifier Cap. Calculation:
rectifiercap</li>
<li>Cap. VAR to FARAD Conversion:
farads</li>
<li>VSC DC Bus Voltage Calculator:
vscdcbus</li>
<li>PLL-VSC Gains Calculator:
vscgains</li>
<li>Sinusoid Peak-to-RMS Converter:
rms</li>
<li>Sinusoid RMS-to-Peak Converter:
peak</li>
<li>Arbitrary Waveform RMS Calculator:
funcrms</li>
<li>Step Function:
step</li>
<li>Multi-Argument Convolution:
convolve</li>
<li>Convolution Bar Graph Visualizer:
convbar</li>
<li>Gaussian Function:
gaussian</li>
<li>Gaussian Distribution Calculator:
gausdist</li>
<li>Probability Density Calculator:
probdensity</li>
<li>Real FFT Evaluator:
rfft</li>
<li>Normalized Power Spectrum:
wrms</li>
<li>Hartley's Data Capacity Equation:
hartleydata</li>
<li>Shannon's Data Capacity Equation:
shannondata</li>
<li>String to Bit-String Converter:
string_to_bits</li>
<li>CRC Message Generator:
crcsender</li>
<li>CRC Remainder Calculator:
crcremainder</li>
<li>kWh to BTU:
kwh_to_btu</li>
<li>BTU to kWh:
btu_to_kwh</li>
<li>Per-Unit Impedance Calculator:
zpu</li>
<li>Per-Unit Current Calculator:
ipu</li>
<li>Per-Unit Change of Base Formula:
puchgbase</li>
<li>Per-Unit to Ohmic Impedance:
zrecompose</li>
<li>X over R to Ohmic Impedance:
rxrecompose</li>
<li>Generator Internal Voltage Calc:
geninternalv</li>
<li>Phase to Sequence Conversion:
abc_to_seq</li>
<li>Sequence to Phase Conversion:
seq_to_abc</li>
<li>Sequence Impedance Calculator:
sequencez</li>
<li>Function Harmonic (FFT) Evaluation:
funcfft</li>
<li>Dataset Harmonic (FFT) Evaluation:
sampfft</li>
<li>Harmonic (FFT) Component Plotter:
fftplot</li>
<li>Harmonic (FFT) Summation Plotter:
fftsumplot </li>
<li>Harmonic System Generator:
harmonics
</li>
<li>Motor Startup Capacitor Formula:
motorstartcap</li>
<li>Power Factor Correction Formula:
pfcorrection</li>
<li>AC Power/Voltage/Current Relation:
acpiv</li>
<li>Transformer Primary Conversion:
primary</li>
<li>Transformer Secondary Conversion:
secondary</li>
<li>Natural Frequency Calculator
natfreq</li>
<li>3-Phase Voltage/Current Unbalance:
unbalance</li>
<li>Characteristic Impedance Calculator:
characterz</li>
<li>Transformer Phase Shift Calculator:
xfmphs</li>
<li>Hertz to Radians Converter:
hz_to_rad</li>
<li>Radians to Hertz Converter:
rad_to_hz</li>
<li>Induction Machine Vth Calculator:
indmachvth</li>
<li>Induction Machine Zth Calculator:
indmachzth</li>
<li>Induction Machine Pem Calculator:
indmachpem</li>
<li>Induction Machine Tem Calculator:
indmachtem</li>
<li>Induction Machine Peak Slip Calculator:
indmachpkslip</li>
<li>Induction Machine Peak Torque Calc.:
indmachpktorq</li>
<li>Induction Machine Rotor Current:
indmachiar</li>
<li>Induction Machine Starting Torque:
indmachstarttorq</li>
<li>Stator Power for Induction Machine:
pstator</li>
<li>Rotor Power for Induction Machine:
protor</li>
<li>De Calculator:
de_calc</li>
<li>Z Per Length Calculator:
zperlength</li>
<li>Induction Machine FOC Rating Calculator: indmachfocratings</li>
<li>Induction Machine FOC Control Calc.:
imfoc_control</li>
<li>Synchronous Machine Internal Voltage:
synmach_Eq</li>
<li>Voltage / Current / PF Relation:
vipf</li>
<li>Radians/Second to RPM Converter:
rad_to_rpm</li>
<li>RPM to Radians/Second Converter:
rpm_to_rad</li>
<li>Hertz to RPM Converter:
hz_to_rpm</li>
<li>RPM to Hertz Converter:
rpm_to_hz</li>
<li>Synchronous Speed Calculator:
syncspeed</li>
<li>Machine Slip Calculator:
machslip</li>
</ul>
<h2 id="additional-available-sub-modules">Additional Available Sub-Modules</h2>
<ul>
<li>fault.py</li>
<li>bode.py</li>
<li>sim.py</li>
</ul>
<h2 id="functions-available-in-electricpyfaultpy">Functions Available in <code>electricpy.fault.py</code></h2>
<ul>
<li>Single Line to Ground
phs1g</li>
<li>Double Line to Ground
phs2g</li>
<li>Line to Line
phs2</li>
<li>Three-Phase Fault
phs3</li>
<li>Single Pole Open:
poleopen1</li>
<li>Double Pole Open:
poleopen2</li>
<li>Simple MVA Calculator:
scMVA</li>
<li>Three-Phase MVA Calculator:
phs3mvasc</li>
<li>Single-Phase MVA Calculator:
phs1mvasc</li>
<li>Faulted Bus Voltage
busvolt</li>
<li>CT Saturation Function
ct_saturation</li>
<li>CT C-Class Calculator
ct_cclass</li>
<li>CT Sat. V at rated Burden
ct_satratburden</li>
<li>CT Voltage Peak Formula
ct_vpeak</li>
<li>CT Time to Saturation
ct_timetosat</li>
<li>Transient Recovery Voltage Calc.
pktransrecvolt</li>
<li>TRV Reduction Resistor
trvresistor</li>
<li>TOC Trip Time
toctriptime</li>
<li>TOC Reset Time
tocreset</li>
<li>Pickup Setting Assistant
pickup</li>
<li>Radial TOC Coordination Tool
tdradial</li>
<li>TAP Setting Calculator
protectiontap</li>
<li>Transformer Current Correction
correctedcurrents</li>
<li>Operate/Restraint Current Calc.
iopirt</li>
<li>Symmetrical/RMS Fault Current Calc:
symrmsfaultcur</li>
<li>TOC Fault Current Ratio:
faultratio</li>
<li>Residual Compensation Factor Calc:
residcomp</li>
<li>Distance Elem. Impedance Calc:
distmeasz</li>
<li>Transformer Mismatch Calculator:
transmismatch</li>
<li>High-Impedance Voltage Pickup:
highzvpickup</li>
<li>High-Impedance Minimum Current PU:
highzmini</li>
<li>Instantaneous Overcurrent PU:
instoc</li>
<li>Generator Loss of Field Settings:
genlossfield</li>
<li>Thermal Time Limit Calculator:
thermaltime</li>
<li>Synchronous Machine Symm. Current:
synmach_Isym</li>
<li>Synchronous Machine Asymm. Current:
synmach_Iasym</li>
<li>Induction Machine Eigenvalue Calc.:
indmacheigenvalues</li>
<li>Induction Machine 3-Phase-SC Calc.:
indmachphs3sc</li>
<li>Induction Machine 3-Phs-Torq. Calc.:
indmachphs3torq</li>
</ul>
<h2 id="functions-available-in-electricpybodepy">Functions Available in <code>electricpy.bode.py</code></h2>
<ul>
<li>Transfer Function Bode Plotter:
bode</li>
<li>S-Domain Bode Plotter:
sbode</li>
<li>Z-Domain Bode Plotter:
zbode</li>
</ul>
<h2 id="functions-available-in-electricpysimpy">Functions Available in <code>electricpy.sim.py</code></h2>
<ul>
<li>Digital Filter Simulator:
digifiltersim</li>
<li>Step Response Filter Simulator:
step_response</li>
<li>Ramp Response Filter Simulator:
ramp_response</li>
<li>Parabolic Response Filter Simulator:
parabolic_response</li>
<li>State-Space System Simulator:
statespace</li>
<li>Newton Raphson Calculator:
NewtonRaphson</li>
<li>Power Flow System Generator:
nr_pq</li>
<li>Multi-Bus Power Flow Calculator:
mbuspowerflow</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">###################################################################
&#34;&#34;&#34;
---------------
`electricpy.py`
---------------

 `A library of functions, constants and more
 that are related to Power in Electrical Engineering.`

 Written by Joe Stanley


Included Constants
------------------
 - Pico Multiple:                            p
 - Nano Multiple:                            n
 - Micro (mu) Multiple:                      u
 - Mili Multiple:                            m
 - Kilo Multiple:                            k
 - Mega Multiple:                            M
 - &#39;A&#39; Operator for Symmetrical Components:  a
 - Not a Number value (NaN):                 NAN
 
Additional constants may not be listed. For a complete list,
visit constants page.

Symmetrical Components Matricies
--------------------------------
 - ABC to 012 Conversion:        Aabc
 - 012 to ABC Conversion:        A012

Included Functions
------------------
 - Phasor V/I Generator:                    phasor
 - Phasor Array V/I Generator:              phasorlist
 - Phasor Data Genorator:                   phasordata
 - Phase Angle Generator:                   phs
 - Time of Number of Cycles:                tcycle        
 - Phasor Impedance Generator:              phasorz
 - Complex Display Function:                cprint
 - Complex LaTeX Display Function:          clatex
 - Transfer Function LaTeX Generator:       tflatex
 - Parallel Impedance Adder:                parallelz
 - V/I Line/Phase Converter:                phaseline
 - Power Set Values:                        powerset
 - Power Triangle Function:                 powertriangle
 - Transformer SC OC Tests:                 transformertest
 - Phasor Plot Generator:                   phasorplot
 - Total Harmonic Distortion:               thd
 - Total Demand Distortion:                 tdd
 - Reactance Calculator:                    reactance
 - Non-Linear PF Calc:                      nlinpf
 - Harmonic Limit Calculator:               harmoniclimit
 - Power Factor Distiortion:                pfdist
 - Short-Circuit RL Current:                iscrl
 - Voltage Divider:                         voltdiv
 - Current Divider:                         curdiv
 - Instantaneous Power Calc.:               instpower
 - Delta-Wye Network Converter:             dynetz
 - Single Line Power Flow:                  powerflow
 - Thermocouple Temperature:                thermocouple
 - Cold Junction Voltage:                   coldjunction
 - RTD Temperature Calculator:              rtdtemp
 - Horsepower to Watts:                     hp_to_watts
 - Watts to Horsepower:                     watts_to_hp
 - Inductor Charge:                         inductorcharge
 - Inductor Discharge:                      inductordischarge
 - Inductor Stored Energy:                  inductorenergy      
 - Back-to-Back Cap. Surge:                 capbacktoback  
 - Capacitor Stored Energy:                 energy
 - Cap. Voltage after Time:                 VafterT
 - Cap. Voltage Discharge:                  vcapdischarge
 - Cap. Voltage Charge:                     vcapcharge
 - Rectifier Cap. Calculation:              rectifiercap
 - Cap. VAR to FARAD Conversion:            farads
 - VSC DC Bus Voltage Calculator:           vscdcbus
 - PLL-VSC Gains Calculator:                vscgains
 - Sinusoid Peak-to-RMS Converter:          rms
 - Sinusoid RMS-to-Peak Converter:          peak
 - Arbitrary Waveform RMS Calculator:       funcrms
 - Step Function:                           step
 - Multi-Argument Convolution:              convolve
 - Convolution Bar Graph Visualizer:        convbar
 - Gaussian Function:                       gaussian
 - Gaussian Distribution Calculator:        gausdist
 - Probability Density Calculator:          probdensity
 - Real FFT Evaluator:                      rfft
 - Normalized Power Spectrum:               wrms
 - Hartley&#39;s Data Capacity Equation:        hartleydata
 - Shannon&#39;s Data Capacity Equation:        shannondata
 - String to Bit-String Converter:          string_to_bits
 - CRC Message Generator:                   crcsender
 - CRC Remainder Calculator:                crcremainder
 - kWh to BTU:                              kwh_to_btu
 - BTU to kWh:                              btu_to_kwh
 - Per-Unit Impedance Calculator:           zpu
 - Per-Unit Current Calculator:             ipu
 - Per-Unit Change of Base Formula:         puchgbase
 - Per-Unit to Ohmic Impedance:             zrecompose
 - X over R to Ohmic Impedance:             rxrecompose
 - Generator Internal Voltage Calc:         geninternalv
 - Phase to Sequence Conversion:            abc_to_seq
 - Sequence to Phase Conversion:            seq_to_abc
 - Sequence Impedance Calculator:           sequencez
 - Function Harmonic (FFT) Evaluation:      funcfft
 - Dataset Harmonic (FFT) Evaluation:       sampfft
 - Harmonic (FFT) Component Plotter:        fftplot
 - Harmonic (FFT) Summation Plotter:        fftsumplot 
 - Harmonic System Generator:               harmonics   
 - Motor Startup Capacitor Formula:         motorstartcap
 - Power Factor Correction Formula:         pfcorrection
 - AC Power/Voltage/Current Relation:       acpiv
 - Transformer Primary Conversion:          primary
 - Transformer Secondary Conversion:        secondary
 - Natural Frequency Calculator             natfreq
 - 3-Phase Voltage/Current Unbalance:       unbalance
 - Characteristic Impedance Calculator:     characterz
 - Transformer Phase Shift Calculator:      xfmphs
 - Hertz to Radians Converter:              hz_to_rad
 - Radians to Hertz Converter:              rad_to_hz
 - Induction Machine Vth Calculator:        indmachvth
 - Induction Machine Zth Calculator:        indmachzth
 - Induction Machine Pem Calculator:        indmachpem
 - Induction Machine Tem Calculator:        indmachtem
 - Induction Machine Peak Slip Calculator:  indmachpkslip
 - Induction Machine Peak Torque Calc.:     indmachpktorq
 - Induction Machine Rotor Current:         indmachiar
 - Induction Machine Starting Torque:       indmachstarttorq
 - Stator Power for Induction Machine:      pstator
 - Rotor Power for Induction Machine:       protor
 - De Calculator:                           de_calc
 - Z Per Length Calculator:                 zperlength
 - Induction Machine FOC Rating Calculator: indmachfocratings
 - Induction Machine FOC Control Calc.:     imfoc_control
 - Synchronous Machine Internal Voltage:    synmach_Eq
 - Voltage / Current / PF Relation:         vipf
 - Radians/Second to RPM Converter:         rad_to_rpm
 - RPM to Radians/Second Converter:         rpm_to_rad
 - Hertz to RPM Converter:                  hz_to_rpm
 - RPM to Hertz Converter:                  rpm_to_hz
 - Synchronous Speed Calculator:            syncspeed
 - Machine Slip Calculator:                 machslip

Additional Available Sub-Modules
--------------------------------
 - fault.py
 - bode.py
 - sim.py

Functions Available in `electricpy.fault.py`
--------------------------------------------
 - Single Line to Ground                 phs1g
 - Double Line to Ground                 phs2g
 - Line to Line                          phs2
 - Three-Phase Fault                     phs3
 - Single Pole Open:                     poleopen1
 - Double Pole Open:                     poleopen2
 - Simple MVA Calculator:                scMVA
 - Three-Phase MVA Calculator:           phs3mvasc
 - Single-Phase MVA Calculator:          phs1mvasc
 - Faulted Bus Voltage                   busvolt
 - CT Saturation Function                ct_saturation
 - CT C-Class Calculator                 ct_cclass
 - CT Sat. V at rated Burden             ct_satratburden
 - CT Voltage Peak Formula               ct_vpeak
 - CT Time to Saturation                 ct_timetosat
 - Transient Recovery Voltage Calc.      pktransrecvolt
 - TRV Reduction Resistor                trvresistor
 - TOC Trip Time                         toctriptime
 - TOC Reset Time                        tocreset
 - Pickup Setting Assistant              pickup
 - Radial TOC Coordination Tool          tdradial
 - TAP Setting Calculator                protectiontap
 - Transformer Current Correction        correctedcurrents
 - Operate/Restraint Current Calc.       iopirt
 - Symmetrical/RMS Fault Current Calc:   symrmsfaultcur
 - TOC Fault Current Ratio:              faultratio
 - Residual Compensation Factor Calc:    residcomp
 - Distance Elem. Impedance Calc:        distmeasz
 - Transformer Mismatch Calculator:      transmismatch
 - High-Impedance Voltage Pickup:        highzvpickup
 - High-Impedance Minimum Current PU:    highzmini
 - Instantaneous Overcurrent PU:         instoc
 - Generator Loss of Field Settings:     genlossfield
 - Thermal Time Limit Calculator:        thermaltime
 - Synchronous Machine Symm. Current:    synmach_Isym
 - Synchronous Machine Asymm. Current:   synmach_Iasym
 - Induction Machine Eigenvalue Calc.:   indmacheigenvalues
 - Induction Machine 3-Phase-SC Calc.:   indmachphs3sc
 - Induction Machine 3-Phs-Torq. Calc.:  indmachphs3torq

Functions Available in `electricpy.bode.py`
-------------------------------------------
 - Transfer Function Bode Plotter:       bode
 - S-Domain Bode Plotter:                sbode
 - Z-Domain Bode Plotter:                zbode

Functions Available in `electricpy.sim.py`
------------------------------------------
 - Digital Filter Simulator:             digifiltersim
 - Step Response Filter Simulator:       step_response
 - Ramp Response Filter Simulator:       ramp_response
 - Parabolic Response Filter Simulator:  parabolic_response
 - State-Space System Simulator:         statespace
 - Newton Raphson Calculator:            NewtonRaphson
 - Power Flow System Generator:          nr_pq
 - Multi-Bus Power Flow Calculator:      mbuspowerflow
&#34;&#34;&#34;
###################################################################

# Define Module Specific Variables
_name_ = &#34;electricpy&#34;
_version_ = &#34;0.1.7&#34;
# Version Breakdown:
# MAJOR CHANGE . MINOR CHANGE . MICRO CHANGE

# Import Submodules
from .constants import *
from . import fault
from . import bode
from . import sim

# Import Supporting Modules
import numpy as _np
import matplotlib as _matplotlib
import matplotlib.pyplot as _plt
import cmath as _c
from scipy.optimize import fsolve as _fsolve


# Define Phase Angle Generator
def phs( ang ):
    &#34;&#34;&#34;
    Complex Phase Angle Generator
    
    Generate a complex value given the phase angle
    for the complex value.
    
    Same as `phase`.
    
    Parameters
    ----------
    ang:        float
                The angle (in degrees) for which
                the value should be calculated.
    
    See Also
    --------
    phasorlist: Phasor Generator for List or Array
    cprint:     Complex Variable Printing Function
    phasorz:    Impedance Phasor Generator
    phasor:     Phasor Generating Function
    &#34;&#34;&#34;
    # Return the Complex Angle Modulator
    return(_np.exp(1j*_np.radians( ang )))
phase = phs # Create Duplicate Name
    

# Define Phasor Generator
def phasor( mag, ang=0 ):
    &#34;&#34;&#34;
    Complex Phasor Generator
    
    Generates the standard Pythonic complex representation
    of a phasor voltage or current when given the magnitude
    and angle of the specific voltage or current.
    
    Parameters
    ----------
    mag:        float
                The Magnitude of the Voltage/Current
    ang:        float
                The Angle (in degrees) of the Voltage/Current
    
    Returns
    -------
    phasor:     complex
                Standard Pythonic Complex Representation of
                the specified voltage or current.
    
    Examples
    --------
    &gt;&gt;&gt; import electricpy as ep
    &gt;&gt;&gt; ep.phasor(67, 120) # 67 volts at angle 120 degrees
    (-33.499999999999986+58.02370205355739j)
    
    See Also
    --------
    phasorlist: Phasor Generator for List or Array
    cprint:     Complex Variable Printing Function
    phasorz:    Impedance Phasor Generator
    phs:        Complex Phase Angle Generator
    &#34;&#34;&#34;
    # Test for Tuple/List Arg
    if isinstance(mag, (tuple,list,_np.ndarray)):
        ang = mag[1]
        mag = mag[0]
    return( _c.rect( mag, _np.radians( ang ) ) )

# Define Phasor Array Generator
def phasorlist( arr ):
    &#34;&#34;&#34;
    Complex Phasor Generator for 2-D Array or 2-D List
    
    Generates the standard Pythonic complex representation
    of a phasor voltage or current when given the magnitude
    and angle of the specific voltage or current for a list
    or array of values.
    
    Parameters
    ----------
    arr:        numpy.ndarray
                2-D array or list of magnitudes and angles.
                Each item must be set of magnitude and angle
                in form of: [mag, ang].
    
    Returns
    -------
    phasor:     complex
                Standard Pythonic Complex Representation of
                the specified voltage or current.
    
    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; import electricpy as ep
    &gt;&gt;&gt; voltages = _np.array([[67,0],
                             [67,-120],
                             [67,120]])
    &gt;&gt;&gt; Vset = ep.phasorlist( voltages )
    &gt;&gt;&gt; print(Vset)
    
    See Also
    --------
    phasor:     Phasor Generating Function
    cprint:     Complex Variable Printing Function
    phasorz:    Impedance Phasor Generator
    &#34;&#34;&#34;
    # Iteratively Process
    outarr = _np.array([])
    for i in arr:
        outarr = _np.append(outarr, phasor( i ))
    # Return Array
    return(outarr)

# Define Phasor Data Generator
def phasordata(mn,mx=None,npts=1000,mag=1,ang=0,freq=60,
               retstep=False,rettime=False,sine=False):
    &#34;&#34;&#34;
    Complex Phasor Data Generator
    
    Generates a sinusoidal data set with minimum, maximum,
    frequency, magnitude, and phase angle arguments.
    
    Parameters
    ----------
    mn:         float, optional
                Minimum time (in seconds) to generate data for.
                default=0
    mx:         float
                Maximum time (in seconds) to generate data for.
    npts:       float, optional
                Number of data samples. default=1000
    mag:        float, optional
                Sinusoid magnitude, default=1
    ang:        float, optional
                Sinusoid angle in degrees, default=0
    freq:       float, optional
                Sinusoid frequency in Hz
    retstep:    bool, optional
                Control argument to request return of time
                step size (dt) in seconds.
    sine:       bool, optional
                Control argument to require data be generated
                with a sinusoidal function instead of cosine.
                
    Returns
    -------
    data:       numpy.ndarray
                The resultant data array.
    &#34;&#34;&#34;
    # Test Inputs for Min/Max
    if mx == None:
        # No Minimum provided, use Value as Maximum
        mx = mn
        mn = 0
    # Generate Omega
    w = 2*_np.pi*freq
    # Generate Time Array
    t,dt = _np.linspace(mn,mx,npts,retstep=True)
    # Generate Data Array
    if not sine:
        data = mag * _np.cos(w*t + _np.radians(ang))
    else:
        data = mag * _np.sin(w*t + _np.radians(ang))
    # Generate Return Data Set
    dataset = [data]
    if retstep:
        dataset.append(dt)
    if rettime:
        dataset.append(t)
    # Return Dataset
    if len(dataset) == 1:
        return(dataset[0])
    return(dataset)

# Define Complex LaTeX Generator
def clatex(val,round=3,polar=True,predollar=True,postdollar=True,double=False):
    &#34;&#34;&#34;
    Complex Value Latex Generator
    
    Function to generate a LaTeX string of complex value(s)
    in either polar or rectangular form. May generate both dollar
    signs.
    
    Parameters
    ----------
    val:        complex
                The complex value to be printed, if value
                is a list or numpy array, the result will be
                demonstrated as a matrix.
    round:      int, optional
                Control to specify number of decimal places
                that should displayed. default=True
    polar:      bool, optional
                Control argument to force result into polar
                coordinates instead of rectangular. default=True
    predollar:  bool, optional
                Control argument to enable/disable the dollar
                sign before the string. default=True
    postdollar: bool, optional
                Control argument to enable/disable the dollar
                sign after the string. default=True
    double:     bool, optional
                Control argument to specify whether or not
                LaTeX dollar signs should be double or single,
                default=False
    
    Returns
    -------
    latex:      str
                LaTeX string for the complex value.
    &#34;&#34;&#34;
    # Define Interpretation Functions
    def polarstring( val, round ):
        mag, ang_r = _c.polar(val) #Convert to polar form
        ang = _np.degrees(ang_r) #Convert to degrees
        mag = _np.around( mag, round ) #Round
        ang = _np.around( ang, round ) #Round
        latex = str(mag) + &#39;∠&#39; + str(ang) + &#39;°&#39;
        return(latex)
    def rectstring( val, round ):
        real = _np.around( val.real, round ) #Round
        imag = _np.around( val.imag, round ) #Round
        if imag &gt; 0:
            latex = str(real) + &#34;+j&#34; + str(imag)
        else:
            latex = str(real) + &#34;-j&#34; + str(abs(imag))
        return(latex)
    # Interpret as numpy array if simple list
    if isinstance(val, list):
        val = _np.asarray(val) # Ensure that input is array
    # Find length of the input array
    if isinstance(val,_np.ndarray):
        shp = val.shape
        try:
            row, col = shp # Interpret Shape of Object
        except:
            row = shp[0]
            col = 1
        sz = val.size
        # Open Matrix
        latex = r&#39;\begin{bmatrix}&#39;
        # Iteratively Process Each Item in Array
        for ri in range(row):
            if ri != 0: # Insert Row Separator
                latex += r&#39;\\&#39;
            if col &gt; 1:
                for ci in range(col):
                    if ci != 0: # Insert Column Separator
                        latex += r&#39; &amp; &#39;
                    # Add Complex Represetation of Value
                    if polar: latex += polarstring( val[ri][ci], round )
                    else: latex += rectstring( val[ri][ci], round )
            else:
                # Add Complex Represetation of Value
                if polar: latex += polarstring( val[ri], round )
                else: latex += rectstring( val[ri], round )
        # Close Matrix
        latex += r&#39;\end{bmatrix}&#39;
    elif isinstance(val, complex):
        # Treat as Polar When Directed
        if polar:
            latex = polarstring( val, round )
        else:
            latex = rectstring( val, round )
    else:
        raise ValueError(&#34;Invalid Input Type&#34;)
    # Add Dollar Sign pre-post
    if double:
        dollar = r&#39;$$&#39;
    else:
        dollar = r&#39;$&#39;
    if predollar:
        latex = dollar + latex
    if postdollar:
        latex = latex + dollar
    return( latex )

# Define Transfer Function LaTeX Generator
def tflatex(sys,sysp=None,var=&#39;s&#39;,predollar=True,
            postdollar=True,double=False,tolerance=1e-8):
    &#34;&#34;&#34;
    Transfer Function LaTeX String Generator
    
    LaTeX string generating function to create a transfer
    function string in LaTeX. Particularly useful for
    demonstrating systems in Interactive Python Notebooks.
    
    Parameters
    ----------
    sys:        list
                If provided in conjunction with optional
                parameter `sysp`, the parameter `sys` will
                act as the numerator set. Otherwise, can be
                passed as a list containing two sublists,
                the first being the numerator set, and the
                second being the denominator set.
    sysp:       list, optional
                If provided, this input will act as the
                denominator of the transfer function.
    var:        str, optional
                The variable that should be printed for each
                term (i.e. &#39;s&#39; or &#39;j\\omega&#39;). default=&#39;s&#39;
    predollar:  bool, optional
                Control argument to enable/disable the dollar
                sign before the string. default=True
    postdollar: bool, optional
                Control argument to enable/disable the dollar
                sign after the string. default=True
    double:     bool, optional
                Control argument to specify whether or not
                LaTeX dollar signs should be double or single,
                default=False
    tolerance:  float, optional
                The floating point tolerance cutoff to evaluate
                each term against. If the absolute value of the
                particular term is greater than the tolerance,
                the value will be printed, if not, it will not
                be printed. default=1e-8
    
    Returns
    -------
    latex:      str
                LaTeX string for the transfer function.
    &#34;&#34;&#34;
    # Collect Numerator and Denominator Terms
    if isinstance(sysp, (list,tuple,_np.ndarray)):
        num = sys
        den = sysp
    else:
        num, den = sys
    # Generate String Function
    def genstring( val ):
        length = len(val)
        strg = &#39;&#39;
        for i,v in enumerate(val):
            # Add Each Term to String
            if abs(v) &gt; tolerance:
                # Add &#39;+&#39; Symbol After Each Term
                if i != 0:
                    strg += r&#39;+&#39;
                strg += str(v)
                # Determine Exponent
                xpnt = length-i-1
                if xpnt == 1:
                    strg += var
                elif xpnt == 0:
                    pass # Don&#39;t Do Anything
                else:
                    strg += var+r&#39;^{&#39;+str(xpnt)+r&#39;}&#39;
        return( strg )
    # Generate Total TF String
    latex = r&#39;\frac{&#39; + genstring( num ) + r&#39;}{&#39;
    latex += genstring( den ) + r&#39;}&#39;
    # Add Dollar Sign pre-post
    if double:
        dollar = r&#39;$$&#39;
    else:
        dollar = r&#39;$&#39;
    if predollar:
        latex = dollar + latex
    if postdollar:
        latex = latex + dollar
    return( latex )

# Define Complex Composition Function
def compose(*arr):
    &#34;&#34;&#34;
    Complex Composition Function
    
    Accepts a set of real values and generates an array
    of complex values. Input must be array-like, but can
    appear in various forms:
    
    - [ real, imag]
    - [ [ real1, ..., realn ], [ imag1, ..., imagn ] ]
    - [ [ real1, imag1 ], ..., [ realn, imagn ] ]
    
    Will always return values in form:
    
    [ complex1, ... complexn ]
    
    Parameters
    ----------
    arr:        array_like
                The input of real and imaginary term(s)
    &#34;&#34;&#34;
    # Condition Input
    if len(arr) == 1:
        arr = arr[0] # Extract 0-th term
    # Input comes in various forms, we must first detect shape
    arr = _np.asarray( arr ) # Format as Numpy Array
    # Gather Shape to Detect Format
    try:
        row, col = arr.shape
        # Passed Test, Valid Shape
        retarr = _np.array([]) # Empty Return Array
        # Now, Determine whether is type 2 or 3
        if col == 2: # Type 3
            for i in range(row): # Iterate over each row
                item = arr[i][0] + 1j*arr[i][1]
                retarr = _np.append(retarr, item)
        elif row == 2: # Type 2
            for i in range(col): # Iterate over each column
                item = arr[0][i] + 1j*arr[1][i]
                retarr = _np.append(retarr, item)
        else:
            raise ValueError(&#34;Invalid Array Shape, must be 2xN or Nx2.&#34;)
        # Successfully Generated Array, Return
        return( retarr )
    except: # 1-Dimension Array
        length = arr.size
        # Test for invalid Array Size
        if length != 2:
            raise ValueError(&#34;Invalid Array Size, Saw Length of &#34;+str(length))
        # Valid Size, Calculate and Return
        return( arr[0] + 1j*arr[1] )

# Define Cycle Time Function
def tcycle(ncycles=1,freq=60):
    &#34;&#34;&#34;
    Time of Electrical Cycles
    
    Evaluates the time for a number of n
    cycles given the system frequency.
    
    .. math:: t = \\frac{n_{cycles}}{freq}
    
    Parameters
    ----------
    ncycles:    float, optional    
                Number (n) of cycles to evaluate, default=1
    freq:       float, optional
                System frequency in Hz, default=60
    
    Returns
    -------
    t:          float
                Total time for *ncycles*
    &#34;&#34;&#34;
    # Condition Inputs
    ncycles = _np.asarray(ncycles)
    freq = _np.asarray(freq)
    # Evaluate the time for ncycles
    time = ncycles/freq
    # Return
    if len(time) == 1:
        return(time[0])
    else:
        return(time)

# Define Reactance Calculator
def reactance(z,freq=60,sensetivity=1e-12):
    &#34;&#34;&#34;
    Capacitance/Inductance from Impedance
    
    Calculates the Capacitance or Inductance in Farads or Henreys
    (respectively) provided the impedance of an element.
    Will return capacitance (in Farads) if ohmic impedance is
    negative :eq:`cap`, or inductance (in Henrys) if ohmic impedance is
    positive :eq:`ind`. If imaginary: calculate with j factor
    (imaginary number).
    
    .. math:: C = \\frac{1}{\\omega*Z}
       :label: cap
    
    .. math:: L = \\frac{Z}{\\omega}
       :label: ind
    
    This requires that the radian frequency is found as follows:
    
    .. math:: \\omega = 2*\\pi*freq
    
    where `freq` is the frequency in Hertz.
    
    .. note::
       It&#39;s worth noting here, that the resistance will be found by
       extracting the real part of a complex value. That is:
       
       .. math:: R = Real( R + jX )
       
    
    Parameters
    ----------
    z:              complex
                    The Impedance Provided, may be complex (R+jI)
    freq:           float, optional
                    The Frequency Base for Provided Impedance, default=60
    sensetivity:    float, optional
                    The sensetivity used to check if a resistance was
                    provided, default=1e-12
    
    Returns
    -------
    out:            float
                    Capacitance or Inductance of Impedance
    &#34;&#34;&#34;
    # Evaluate Omega
    w = 2*_np.pi*freq
    # Input is Complex
    if isinstance(z, complex):
        # Test for Resistance
        if(abs(z.real) &gt; sensetivity):
            R = z.real
        else:
            R = 0
        if (z.imag &gt; 0):
            out = z/(w*1j)
        else:
            out = 1/(w*1j*z)
        out = abs(out)
        # Combine with resistance if present
        if(R!=0): out = (R, out)
    else:
        if (z &gt; 0):
            out = z/(w)
        else:
            out = 1/(w*z)
        out = abs(out)
    # Return Output
    return(out)

# Define display function
def cprint(val,unit=None,label=None,title=None,
           pretty=True,printval=True,ret=False,round=3):
    &#34;&#34;&#34;
    Phasor (Complex) Printing Function
    
    This function is designed to accept a complex value (val) and print
    the value in the standard electrical engineering notation:
    
    **magnitude ∠ angle °**
    
    This function will print the magnitude in degrees, and can print
    a unit and label in addition to the value itself.
    
    Parameters
    ----------
    val:        complex
                The Complex Value to be Printed, may be singular value,
                tuple of values, or list/array.
    unit:       string, optional
                The string to be printed corresponding to the unit mark.
    label:      str, optional
                The pre-pended string used as a descriptive labeling string.
    title:      str, optional
                The pre-pended string describing a set of complex values.
    pretty:     bool, optional
                Control argument to force printed result to a *pretty*
                format without array braces. default=True
    printval:   bool, optional
                Control argument enabling/disabling printing of the string.
                default=True
    ret:        bool, optional
                Control argument allowing the evaluated value to be returned.
                default=False
    round:      int, optional
                Control argument specifying how many decimals of the complex
                value to be printed. May be negative to round to spaces
                to the left of the decimal place (follows standard round()
                functionality). default=3
    
    Returns
    -------
    numarr:     numpy.ndarray
                The array of values corresponding to the magnitude and angle,
                values are returned in the form: [[ mag, ang ],...,[ mag, ang ]]
                where the angles are evaluated in degrees.
    
    Examples
    --------
    &gt;&gt;&gt; import electricpy as ep
    &gt;&gt;&gt; v = ep.phasor(67, 120)
    &gt;&gt;&gt; ep.cprint(v)
    67.0 ∠ 120.0°
    &gt;&gt;&gt; voltages = _np.array([[67,0],
                             [67,-120],
                             [67,120]])
    &gt;&gt;&gt; Vset = ep.phasorlist( voltages )
    &gt;&gt;&gt; ep.cprint(Vset)
    [[&#39;67.0 ∠ 0.0°&#39;]
    [&#39;67.0 ∠ -120.0°&#39;]
    [&#39;67.0 ∠ 120.0°&#39;]]

    
    See Also
    --------
    phasor:     Phasor Generating Function
    phasorlist: Phasor Generating Function for Lists or Arrays
    phasorz:    Impedance Phasor Generator
    &#34;&#34;&#34;
    # Interpret as numpy array if simple list
    if isinstance(val, list):
        val = _np.asarray(val) # Ensure that input is array
    # Find length of the input array
    if isinstance(val,_np.ndarray):
        shp = val.shape
        try:
            row, col = shp # Interpret Shape of Object
        except:
            row = shp[0]
            col = 1
        sz = val.size
        # Handle Label as a List or Array
        if isinstance(label, (list,_np.ndarray)):
            if len(label)==1:
                tmp = label
                for _ in range(sz):
                    label = _np.append(label,[tmp])
            elif sz != len(label):
                raise ValueError(&#34;Too Few Label Arguments&#34;)
        # Handle Label as String
        elif isinstance(label, str):
            tmp = label
            for _ in range(sz):
                label = _np.append(label,[tmp])
        # Handle Lack of Label
        elif label == None:
            label = _np.array([])
            for _ in range(sz):
                label = _np.append(label,None)
        # Handle all Other Cases
        else:
            raise ValueError(&#34;Invalid Label&#34;)
        # Handle Unit as a List or Array
        if isinstance(unit, (list,_np.ndarray)):
            if len(unit)==1:
                tmp = unit
                for _ in range(sz):
                    unit = _np.append(unit,[tmp])
            elif sz != len(unit):
                raise ValueError(&#34;Too Few Unit Arguments&#34;)
        # Handle Unit as String
        elif isinstance(unit, str):
            tmp = unit
            for _ in range(sz):
                unit = _np.append(unit,[tmp])
        # Handle Lack of Unit
        elif unit == None:
            unit = _np.array([])
            for _ in range(sz):
                unit = _np.append(unit,None)
        # Handle all Other Cases
        else:
            raise ValueError(&#34;Invalid Unit&#34;)
        # Generate Default Arrays
        printarr = _np.array([]) # Empty array
        numarr = _np.array([]) # Empty array
        # Operate on List/Array
        for i in range(row):
            _val = val[i]
            _label = label[i]
            _unit = unit[i]
            mag, ang_r = _c.polar(_val) #Convert to polar form
            ang = _np.degrees(ang_r) #Convert to degrees
            mag = _np.around( mag, round ) #Round
            ang = _np.around( ang, round ) #Round
            strg = &#34;&#34;
            if _label != None:
                strg += _label + &#34; &#34;
            strg += str(mag)+&#34; ∠ &#34;+str(ang)+&#34;°&#34;
            if _unit != None:
                strg += &#34; &#34; + _unit
            printarr = _np.append(printarr, strg)
            numarr = _np.append(numarr, [mag, ang])
        # Reshape Arrays
        printarr = _np.reshape(printarr, (row,col))
        numarr = _np.reshape(numarr, (sz, 2))
        # Print
        if printval and row==1:
            if title != None:
                print(title)
            print(strg)
        elif printval and pretty:
            strg = &#39;&#39;
            start = True
            for i in printarr:
                if not start:
                    strg += &#39;\n&#39;
                strg += str(i[0])
                start = False
            if title != None:
                print(title)
            print(strg)
        elif printval:
            if title != None:
                print(title)
            print(printarr)
        # Return if Necessary
        if ret:
            return(numarr)
    elif isinstance(val, (int,float,complex)):
        # Handle Invalid Unit/Label
        if unit != None and not isinstance(unit, str):
            raise ValueError(&#34;Invalid Unit Type for Value&#34;)
        if label != None and not isinstance(label, str):
            raise ValueError(&#34;Invalid Label Type for Value&#34;)
        mag, ang_r = _c.polar(val) #Convert to polar form
        ang = _np.degrees(ang_r) #Convert to degrees
        mag = _np.around( mag, round ) #Round
        ang = _np.around( ang, round ) #Round
        strg = &#34;&#34;
        if label != None:
            strg += label + &#34; &#34;
        strg += str(mag)+&#34; ∠ &#34;+str(ang)+&#34;°&#34;
        if unit != None:
            strg += &#34; &#34; + unit
        # Print values (by default)
        if printval:
            if title != None:
                print(title)
            print(strg)
        # Return values when requested
        if ret:
            return([mag, ang])
    else:
        raise ValueError(&#34;Invalid Input Type&#34;)

# Define Impedance Conversion function
def phasorz(C=None,L=None,freq=60,complex=True):
    &#34;&#34;&#34;
    Phasor Impedance Generator
    
    This function&#39;s purpose is to generate the phasor-based
    impedance of the specified input given as either the
    capacitance (in Farads) or the inductance (in Henreys).
    The function will return the phasor value (in Ohms).
    
    .. math:: Z = \\frac{-j}{\\omega*C}
    
    .. math:: Z = j*\\omega*L
    
    where:
    
    .. math:: \\omega = 2*\\pi*freq
    
    Parameters
    ----------
    C:          float, optional
                The capacitance value (specified in Farads),
                default=None
    L:          float, optional
                The inductance value (specified in Henreys),
                default=None
    freq:       float, optional
                The system frequency to be calculated upon, default=60
    complex:    bool, optional
                Control argument to specify whether the returned
                value should be returned as a complex value.
                default=True
    
    Returns
    -------
    Z:      complex
            The ohmic impedance of either C or L (respectively).
    &#34;&#34;&#34;
    w = 2*_np.pi*freq
    #C Given in ohms, return as Z
    if (C!=None):
        Z = -1/(w*C)
    #L Given in ohms, return as Z
    if (L!=None):
        Z = w*L
    #If asked for imaginary number
    if (complex):
        Z *= 1j
    return(Z)

# Define Parallel Impedance Adder
def parallelz(*args):
    &#34;&#34;&#34;
    Parallel Impedance Calculator
    
    This function is designed to generate the total parallel
    impedance of a set (tuple) of impedances specified as real
    or complex values.
    
    .. math::
       Z_{eq}=(\\frac{1}{Z_1}+\\frac{1}{Z_2}+\\dots+\\frac{1}{Z_n})^{-1}
    
    Parameters
    ----------
    Z:      tuple of complex
            The tupled input set of impedances, may be a tuple
            of any size greater than 2. May be real, complex, or
            a combination of the two.
    
    Returns
    -------
    Zp:     complex
            The calculated parallel impedance of the input tuple.
    &#34;&#34;&#34;
    # Gather length (number of elements in tuple)
    L = len(args)
    if L==1:
        Z = args[0] # Only One Tuple Provided
        try:
            L = len(Z)
            if(L==1):
                Zp = Z[0] # Only one impedance, burried in tuple
            else:
                # Inversely add the first two elements in tuple
                Zp = (1/Z[0]+1/Z[1])**(-1)
                # If there are more than two elements, add them all inversely
                if(L &gt; 2):
                    for i in range(2,L):
                        Zp = (1/Zp+1/Z[i])**(-1)
        except:
            Zp = Z # Only one impedance
    else:
        Z = args # Set of Args acts as Tuple
        # Inversely add the first two elements in tuple
        Zp = (1/Z[0]+1/Z[1])**(-1)
        # If there are more than two elements, add them all inversely
        if(L &gt; 2):
            for i in range(2,L):
                Zp = (1/Zp+1/Z[i])**(-1)
    return(Zp)

# Define Phase/Line Converter
def phaseline(VLL=None,VLN=None,Iline=None,Iphase=None,complex=False):
    &#34;&#34;&#34;
    Line-Line to Line-Neutral Converter
    
    This function is designed to return the phase- or line-equivalent
    of the voltage/current provided. It is designed to be used when
    converting delta- to wye-connections and vice-versa.
    Given a voltage of one type, this function will return the
    voltage of the opposite type. The same is true for current.
    
    .. math:: V_{LL} = \\sqrt{3}∠30° * V_{LN}
       :label: voltages
    
    Typical American (United States) standard is to note voltages in
    Line-to-Line values (VLL), and often, the Line-to-Neutral voltage
    is of value, this function uses the voltage :eq:`voltages` relation
    to evaluate either voltage given the other.
    
    .. math:: I_{Φ} = \\frac{I_{line}}{\\sqrt{3}∠-30°}
       :label: currents
    
    Often, the phase current in a delta-connected device is of
    particular interest, and the line-current is provided. This
    function uses the current :eq:`currents` formula to evaluate
    phase- and line-current given the opposing term.
    
    Parameters
    ----------
    VLL:        float, optional
                The Line-to-Line Voltage; default=None
    VLN:        float, optional
                The Line-to-Neutral Voltage; default=None
    Iline:      float, optional
                The Line-Current; default=None
    Iphase:     float, optional
                The Phase-Current; default=None
    complex:    bool, optional
                Control to return value in complex form; default=False
    &#34;&#34;&#34;
    output = 0
    #Given VLL, convert to VLN
    if VLL is not None:
        VLN = VLL/(VLLcVLN)
        output = VLN
    #Given VLN, convert to VLL
    elif VLN is not None:
        VLL = VLN*VLLcVLN
        output = VLL
    #Given Iphase, convert to Iline
    elif Iphase is not None:
        Iline = Iphase*ILcIP
        output = Iline
    #Given Iline, convert to Iphase
    elif Iline is not None:
        Iphase = Iline/ILcIP
        output = Iphase
    #None given, error encountered
    else:
        print(&#34;ERROR: No value given&#34;+
                &#34;or innapropriate value&#34;+
                &#34;given.&#34;)
        return(0)
    #Return as complex only when requested
    if complex:
        return( output )
    return(abs( output ))

# Define Power Set Function
def powerset(P=None,Q=None,S=None,PF=None,find=&#39;&#39;):
    &#34;&#34;&#34;
    Power Triangle Conversion Function
    
    This function is designed to calculate all values
    in the set { P, Q, S, PF } when two (2) of the
    values are provided. The equations in this
    function are prepared for AC values, that is:
    real and reactive power, apparent power, and power
    factor.
    
    Parameters
    ----------
    P:      float, optional
            Real Power, unitless; default=None
    Q:      float, optional
            Reactive Power, unitless; default=None
    S:      float, optional
            Apparent Power, unitless; default=None
    PF:     float, optional
            Power Factor, unitless, provided as a
            decimal value, lagging is positive,
            leading is negative; default=None
    find:   str, optional
            Control argument to specify which value
            should be returned.
    
    Returns
    -------
    P:      float
            Calculated Real Power Magnitude
    Q:      float
            Calculated Reactive Power Magnitude
    S:      float
            Calculated Apparent Power Magnitude
    PF:     float
            Calculated Power Factor
    &#34;&#34;&#34;
    #Given P and Q
    if (P!=None) and (Q!=None):
        S = _np.sqrt(P**2+Q**2)
        PF = P/S
        if Q&lt;0:
            PF=-PF
    #Given S and PF
    elif (S!=None) and (PF!=None):
        P = abs(S*PF)
        Q = _np.sqrt(S**2-P**2)
        if PF&lt;0:
            Q=-Q
    #Given P and PF
    elif (P!=None) and (PF!=None):
        S = P/PF
        Q = _np.sqrt(S**2-P**2)
        if PF&lt;0:
            Q=-Q
    # Given P and S
    elif (P!=None) and (S!=None):
        Q = _np.sqrt(S**2 - P**2)
        PF = P/S
    # Given Q and S
    elif (Q!=None) and (S!=None):
        P = _np.sqrt(S**2 - Q**2)
        PF = P/S
    else:
        raise ValueError(&#34;ERROR: Invalid Parameters or too few&#34;+
                        &#34; parameters given to calculate.&#34;)
    # Return
    find = find.upper()
    if find == &#39;P&#39;:
        return(P)
    elif find == &#39;Q&#39;:
        return(Q)
    elif find == &#39;S&#39;:
        return(S)
    elif find == &#39;PF&#39;:
        return(PF)
    else:
        return(P,Q,S,PF)

# Define Power Triangle Function
def powertriangle(P=None,Q=None,S=None,PF=None,color=&#34;red&#34;,
                  text=&#34;Power Triangle&#34;,printval=False):
    &#34;&#34;&#34;
    Power Triangle Plotting Function
    
    This function is designed to draw a power triangle given
    values for the complex power system.
    
    Parameters
    ----------
    P:          float
                Real Power, unitless; default=None
    Q:          float
                Reactive Power, unitless; default=None
    S:          float
                Apparent Power, unitless; default=None
    PF:         float
                Power Factor, unitless, provided as a
                decimal value, lagging is positive,
                leading is negative; default=None
    color:      string, optional
                The color of the power triangle lines;
                default=&#34;red&#34;
    text:       string, optional
                The title of the power triangle plot,
                default=&#34;Power Triangle&#34;
    printval:   bool, optional
                Control argument to allow the numeric
                values to be printed on the plot,
                default=&#34;False&#34;
    &#34;&#34;&#34;
    # Calculate all values if not all are provided
    if( P==None or Q==None or S==None or PF==None):
        P,Q,S,PF = powerset(P,Q,S,PF)

    #Generate Lines
    Plnx = [0,P]
    Plny = [0,0]
    Qlnx = [P,P]
    Qlny = [0,Q]
    Slnx = [0,P]
    Slny = [0,Q]

    # Plot Power Triangle
    _plt.figure(1)
    _plt.title(text)
    _plt.plot(Plnx,Plny,color=color)
    _plt.plot(Qlnx,Qlny,color=color)
    _plt.plot(Slnx,Slny,color=color)
    _plt.xlabel(&#34;Real Power (W)&#34;)
    _plt.ylabel(&#34;Reactive Power (VAR)&#34;)
    mx = max(abs(P),abs(Q))

    if P&gt;0:
        _plt.xlim(0,mx*1.1)
        x=mx
    else:
        _plt.xlim(-mx*1.1,0)
        x=-mx
    if Q&gt;0:
        _plt.ylim(0,mx*1.1)
        y=mx
    else:
        _plt.ylim(-mx*1.1,0)
        y=-mx
    if PF &gt; 0:
        PFtext = &#34; Lagging&#34;
    else:
        PFtext = &#34; Leading&#34;
    text = &#34;P:   &#34;+str(P)+&#34; W\n&#34;
    text = text+&#34;Q:   &#34;+str(Q)+&#34; VAR\n&#34;
    text = text+&#34;S:   &#34;+str(S)+&#34; VA\n&#34;
    text = text+&#34;PF:  &#34;+str(abs(PF))+PFtext+&#34;\n&#34;
    text = text+&#34;ΘPF: &#34;+str(_np.degrees(_np.arccos(PF)))+&#34;°&#34;+PFtext
    # Print all values if asked to
    if printval:
         _plt.text(x/20,y*4/5,text,color=color)
    _plt.show()

# Define Transformer Short-Circuit/Open-Circuit Function
def transformertest(Poc=False,Voc=False,Ioc=False,Psc=False,Vsc=False,
               Isc=False):
    &#34;&#34;&#34;
    Transformer Rated Test Evaluator
    
    This function will determine the non-ideal circuit components of
    a transformer (Req and Xeq, or Rc and Xm) given the test-case
    parameters for the open-circuit test and/or the closed-circuit
    test. Requires one or both of two sets: { Poc, Voc, Ioc }, or
    { Psc, Vsc, Isc }.
    All values given must be given as absolute value, not complex.
    All values returned are given with respect to primary.
    
    Parameters
    ----------
    Poc:    float, optional
            The open-circuit measured power (real power), default=None
    Voc:    float, optional
            The open-circuit measured voltage (measured on X),
            default=None
    Ioc:    float, optional
            The open-circuit measured current (measured on primary),
            default=None
    Psc:    float, optional
            The short-circuit measured power (real power), default=None
    Vsc:    float, optional
            The short-circuit measured voltage (measured on X),
            default=None
    Isc:    float, optional
            The short-circuit measured current (measured on X),
            default=None
    
    Returns
    -------
    {Req,Xeq,Rc,Xm}:    Given all optional args
    {Rc, Xm}:           Given open-circuit parameters
    {Req, Xeq}:         Given short-circuit parameters
    &#34;&#34;&#34;
    SC = False
    OC = False
    # Given Open-Circuit Values
    if (Poc!=None) and (Voc!=None) and (Ioc!=None):
        PF = Poc/(Voc*Ioc)
        Y = _c.rect(Ioc/Voc,-_np.arccos(PF))
        Rc = 1/Y.real
        Xm = -1/Y.imag
        OC = True
    # Given Short-Circuit Values
    if (Psc!=None) and (Vsc!=None) and (Isc!=None):
        PF = Psc/(Vsc*Isc)
        Zeq = _c.rect(Vsc/Isc,_np.arccos(PF))
        Req = Zeq.real
        Xeq = Zeq.imag
        SC = True
    # Return All if Found
    if OC and SC:
        return(Req,Xeq,Rc,Xm)
    elif OC:
        return(Rc,Xm)
    elif SC:
        return(Req,Xeq)
    else:
        print(&#34;An Error Was Encountered.\n&#34;+
                &#34;Not enough arguments were provided.&#34;)

# Define Phasor Plot Generator
def phasorplot(phasor,title=&#34;Phasor Diagram&#34;,legend=False,bg=None,
               colors=None,radius=None,linewidth=None,size=None,
               filename=None,plot=True,label=False,labels=False,
               tolerance=None):
    &#34;&#34;&#34;
    Phasor Plotting Function
    
    This function is designed to plot a phasor-diagram with angles in degrees
    for up to 12 phasor sets. Phasors must be passed as a complex number set,
    (e.g. [ m+ja, m+ja, m+ja, ... , m+ja ] ).
    
    Parameters
    ----------
    phasor:     list of complex
                The set of phasors to be plotted.
    title:      string, optional
                The Plot Title, default=&#34;Phasor Diagram&#34;
    legend:     bool, optional
                Control argument to enable displaying the legend, must be passed
                as an array or list of strings. `label` and `labels` are mimic-
                arguments and will perform similar operation, default=False
    bg:         string, optional
                Background-Color control, default=&#34;#d5de9c&#34;
    radius:     float, optional
                The diagram radius, unless specified, automatically scales
    colors:     list of str, optional
                List of hexidecimal color strings denoting the line colors to use.
    filename:   string, optional
                String of filename, if set, will force function to save image.
    plot:       bool, optional
                Control argument to disable plotting. default=True
    size:       float, optional
                Control argument for figure size. default=None
    linewidth:  float, optional
                Control argument to declare the line thickness. default=None
    tolerance:  float, optional
                Minimum magnitude to plot, anything less than tolerance will be
                plotted as a single point at the origin, by default, the tolerance
                is scaled to be 1/25-th the maximum radius. To disable the tolerance,
                simply provide either False or -1.
    &#34;&#34;&#34;
    # Load Complex Values if Necessary
    try:
        len(phasor)
    except TypeError:
        phasor = [phasor]
    # Manage Colors
    if colors==None:
        colors = [&#34;#FF0000&#34;,&#34;#800000&#34;,&#34;#FFFF00&#34;,&#34;#808000&#34;,&#34;#00ff00&#34;,&#34;#008000&#34;,
                  &#34;#00ffff&#34;,&#34;#008080&#34;,&#34;#0000ff&#34;,&#34;#000080&#34;,&#34;#ff00ff&#34;,&#34;#800080&#34;]
    # Scale Radius
    if radius==None:
        radius = _np.abs(phasor).max()
    # Set Tolerance
    if tolerance==None:
        tolerance = radius/25
    elif tolerance==False:
        tolerance = -1
    # Set Background Color
    if bg==None:
        bg = &#34;#FFFFFF&#34;
    # Load labels if handled in other argument
    if label!=False:
        legend = label
    if labels!=False:
        legend = labels
    # Check for more phasors than colors
    numphs = len(phasor)
    numclr = len(colors)
    if numphs &gt; numclr:
        raise ValueError(&#34;ERROR: Too many phasors provided. Specify more line colors.&#34;)
    
    if size==None:
        # Force square figure and square axes
        width, height = _matplotlib.rcParams[&#39;figure.figsize&#39;]
        size = min(width, height)
    # Make a square figure
    fig = _plt.figure(figsize=(size, size))
    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True, facecolor=bg)
    _plt.grid(True)
    
    # Plot the diagram
    _plt.title(title+&#34;\n&#34;)
    handles=_np.array([]) # Empty array for plot handles
    for i in range(numphs):
        mag, ang_r = _c.polar(phasor[i])
        # Plot with labels
        if legend!=False:
            if mag &gt; tolerance:
                hand = _plt.arrow(0,0,ang_r,mag,color=colors[i],
                                  label=legend[i],linewidth=linewidth)
            else:
                hand = _plt.plot(0,0,&#39;o&#39;,markersize=linewidth*3,
                                 label=legend[i],color=colors[i])
            handles = _np.append(handles,[hand])
        # Plot without labels
        else: _plt.arrow(0,0,ang_r,mag,color=colors[i],linewidth=linewidth)
    if legend!=False: _plt.legend((handles),legend)
    # Set Minimum and Maximum Radius Terms
    ax.set_rmax(radius)
    ax.set_rmin(0)
    if filename!=None:
        if not any(sub in filename for sub in [&#39;.png&#39;,&#39;.jpg&#39;]):
            filename += &#39;.png&#39; # Add File Extension
        _plt.savefig( filename )
    if plot:
        _plt.show()
    else:
        _plt.close()

# Define Non-Linear Power Factor Calculator
def nlinpf(PFtrue=False,PFdist=False,PFdisp=False):
    &#34;&#34;&#34;
    Non-Linear Power Factor Evaluator
    
    This function is designed to evaluate one of three unknowns
    given the other two. These particular unknowns are the arguments
    and as such, they are described in the representative sections
    below.
    
    Parameters
    ----------
    PFtrue:     float, exclusive
                The &#34;True&#34; power-factor, default=None
    PFdist:     float, exclusive
                The &#34;Distorted&#34; power-factor, default=None
    PFdisp:     float, exclusive
                The &#34;Displacement&#34; power-factor, default=None
    
    Returns
    -------
    {unknown}:  This function will return the unknown variable from
                the previously described set of variables.
    &#34;&#34;&#34;
    if(PFtrue!=None and PFdist!=None and PFdisp!=None):
        raise ValueError(&#34;ERROR: Too many constraints, no solution.&#34;) 
    elif ( PFdist!=None and PFdisp!=None ):
        return( PFdist * PFdisp )
    elif ( PFtrue!=None and PFdisp!=None ):
        return( PFtrue / PFdisp )
    elif ( PFtrue!=None and PFdist!=None ):
        return( PFtrue / PFdist )
    else:
        raise ValueError(&#34;ERROR: Function requires at least two arguments.&#34;)

# Define Short-Circuit RL Current Calculator
def iscrl(V,Z,t=None,f=None,mxcurrent=True,alpha=None):
    &#34;&#34;&#34;
    Short-Circuit-Current (ISC) Calculator
    
    The Isc-RL function (Short Circuit Current for RL Circuit)
    is designed to calculate the short-circuit current for an
    RL circuit.
    
    Parameters
    ----------
    V:          float
                The absolute magnitude of the voltage.
    Z:          float
                The complex value of the impedance. (R + jX)
    t:          float, optional
                The time at which the value should be calculated,
                should be specified in seconds, default=None
    f:          float, optional
                The system frequency, specified in Hz, default=None
    mxcurrent:  bool, optional
                Control variable to enable calculating the value at
                maximum current, default=True
    alpha:      float, optional
                Angle specification, default=None
    
    Returns
    -------
    Opt 1 - (Irms, IAC, K):     The RMS current with maximum DC
                                offset, the AC current magnitude,
                                and the asymmetry factor.
    Opt 2 - (i, iAC, iDC, T):   The Instantaneous current with
                                maximum DC offset, the instantaneous
                                AC current, the instantaneous DC
                                current, and the time-constant T.
    Opt 3 - (Iac):              The RMS current without DC offset.
    &#34;&#34;&#34;
    # Calculate omega, theta, R, and X
    if(f!=None): omega = 2*_np.pi*f
    else: omega = None
    R = abs(Z.real)
    X = abs(Z.imag)
    theta = _np.arctan( X/R )
    
    # If Maximum Current is Desired and No alpha provided
    if(mxcurrent and alpha==None):
        alpha = theta - _np.pi/2
    elif(mxcurrent and alpha!=None):
        raise ValueError(&#34;ERROR: Inappropriate Arguments Provided.\n&#34;+
                         &#34;Not both mxcurrent and alpha can be provided.&#34;)
    
    # Calculate Asymmetrical (total) Current if t != None
    if(t!=None and f!=None):
        # Calculate RMS if none of the angular values are provided
        if(alpha==None and omega==None):
            # Calculate tau
            tau = t/(1/60)
            K = _np.sqrt(1 + 2*_np.exp(-4*_np.pi*tau/(X/R)) )
            IAC = abs(V/Z)
            Irms = K*IAC
            # Return Values
            return(Irms,IAC,K)
        elif(alpha==None or omega==None):
            raise ValueError(&#34;ERROR: Inappropriate Arguments Provided.&#34;)
        # Calculate Instantaneous if all angular values provided
        else:
            # Convert Degrees to Radians
            omega = _np.radians(omega)
            alpha = _np.radians(alpha)
            theta = _np.radians(theta)
            # Calculate T
            T = X/(2*_np.pi*f*R) # seconds
            # Calculate iAC and iDC
            iAC = _np.sqrt(2)*V/Z*_np.sin(omega*t+alpha-theta)
            iDC = -_np.sqrt(2)*V/Z*_np.sin(alpha-theta)*_np.exp(-t/T)
            i = iAC + iDC
            # Return Values
            return(i,iAC,iDC,T)
    elif( (t!=None and f==None) or (t==None and f!=None) ):
        raise ValueError(&#34;ERROR: Inappropriate Arguments Provided.\n&#34;+
                         &#34;Must provide both t and f or neither.&#34;)
    else:
        IAC = abs(V/Z)
        return(Iac)

# Define Voltage Divider Calculator
def voltdiv(Vin,R1,R2,Rload=None):
    &#34;&#34;&#34;
    Voltage Divider Function
    
    This function is designed to calculate the output
    voltage of a voltage divider given the input voltage,
    the resistances (or impedances) and the load resistance
    (or impedance) if present.
    
    .. math:: V_{out} = V_{in} * \\frac{R_2}{R_1+R+2}
    
    .. math:: V_{out}=V_{in}*\\frac{R_2||R_{load}}{R_1+(R_2||R_{load})}
    
    Parameters
    ----------
    Vin:    float
            The Input Voltage, may be real or complex
    R1:     float
            The top resistor of the divider (real or complex)
    R2:     float
            The bottom resistor of the divider, the one which
            the output voltage is measured across, may be
            either real or complex
    Rload:  float, optional
            The Load Resistor (or impedance), default=None
    
    Returns
    -------
    Vout:   float
            The Output voltage as measured across R2 and/or Rload
    &#34;&#34;&#34;
    # Determine whether Rload is given
    if(Rload==None): # No Load Given
        Vout = Vin * R2 / (R1+R2)
    else:   # Load was given
        Rp = parallelz((R2,Rload))
        Vout = Vin * Rp / (R1+Rp)
    return(Vout)

# Define Current Divider Calculator
def curdiv(Ri,Rset,Vin=None,Iin=None,Vout=False,combine=True):
    &#34;&#34;&#34;
    Current Divider Function
    
    This function is disigned to accept the input current, or input
    voltage to a resistor (or impedance) network of parallel resistors
    (impedances) and calculate the current through a particular element.
    
    Parameters
    ----------
    Ri:         float
                The Particular Resistor of Interest, should not be included in
                the tuple passed to Rset.
    Rset:       float
                Tuple of remaining resistances (impedances) in network.
    Vin:        float, optional
                The input voltage for the system, default=None
    Iin:        float, optional
                The input current for the system, default=None
    Vout:       bool, optional
                Control argument to enable return of the voltage across the
                resistor (impedance) of interest (Ri)
    combine:    bool, optional
                Control argument to force resistance combination. default=True
    
    Returns
    -------
    Opt1 - Ii:          The Current through the resistor (impedance) of interest
    Opt2 - (Ii,Vi):     The afore mentioned current, and voltage across the
                        resistor (impedance) of interest
    &#34;&#34;&#34;
    # Validate Tuple
    if not isinstance(Rset,tuple):
        Rset = (Rset,) # Set as Tuple
    # Calculate The total impedance
    if combine:
        Rtot = parallelz( Rset + (Ri,) ) # Combine tuples, then calculate total resistance
    else:
        Rtot = parallelz( Rset )
    # Determine Whether Input was given as Voltage or Current
    if(Vin!=None and Iin==None): # Vin Provided
        Iin = Vin / Rtot # Calculate total current
        Ii = Iin * Rtot/Ri # Calculate the current of interest
    elif(Vin==None and Iin!=None): # Iin provided
        Ii = Iin * Rtot/Ri # Calculate the current of interest
    else:
        raise ValueError(&#34;ERROR: Too many or too few constraints provided.&#34;)
    if(Vout): # Asked for voltage across resistor of interest
        Vi = Ii * Ri
        return(Ii, Vi)
    else:
        return(Ii)

# Define Instantaneous Power Calculator
def instpower(P,Q,t,freq=60):
    &#34;&#34;&#34;
    Instantaneous Power Function
    
    This function is designed to calculate the instantaneous power at a
    specified time t given the magnitudes of P and Q.
    
    .. math:: P_{inst} = P+P*cos(2*\\omega*t)-Q*sin(2*\\omega*t)
    
    Parameters
    ----------
    P:      float
            Magnitude of Real Power
    Q:      float
            Magnitude of Reactive Power
    t:      float
            Time at which to evaluate
    freq:   float, optional
            System frequency (in Hz), default=60
    
    Returns
    -------
    Pinst:  float
            Instantaneous Power at time t
    &#34;&#34;&#34;
    # Evaluate omega
    w = 2*_np.pi*freq
    # Calculate
    Pinst = P + P*_np.cos(2*w*t) - Q*_np.sin(2*w*t)
    return(Pinst)

# Define Delta-Wye Impedance Network Calculator
def dynetz(delta=None,wye=None,round=None):
    &#34;&#34;&#34;
    Delta-Wye Impedance Converter
    
    This function is designed to act as the conversion utility
    to transform delta-connected impedance values to wye-
    connected and vice-versa.
    
    .. math:: 
       Z_{sum} = Z_{1/2} + Z_{2/3} + Z_{3/1}//
       Z_1 = \\frac{Z_{1/2}*Z_{3/1}}{Z_{sum}}//
       Z_2 = \\frac{Z_{1/2}*Z_{2/3}}{Z_{sum}}//
       Z_3 = \\frac{Z_{2/3}*Z_{3/1}}{Z_{sum}}
    
    .. math::
       Z_{ms} = Z_1*Z_2 + Z_2*Z_3 + Z_3*Z_1//
       Z_{2/3} = \\frac{Z_{ms}}{Z_1}//
       Z_{3/1} = \\frac{Z_{ms}}{Z_2}//
       Z_{1/2} = \\frac{Z_{ms}}{Z_3}
    
    Parameters
    ----------
    delta:  tuple of float, exclusive
            Tuple of the delta-connected impedance values as:
            { Z12, Z23, Z31 }, default=None
    wye:    tuple of float, exclusive
            Tuple of the wye-connected impedance valuse as:
            { Z1, Z2, Z3 }, default=None
    
    Returns
    -------
    delta-set:  tuple of float
                Delta-Connected impedance values { Z12, Z23, Z31 }
    wye-set:    tuple of float
                Wye-Connected impedance values { Z1, Z2, Z3 }
    &#34;&#34;&#34;
    # Determine which set of impedances was provided
    if(delta!=None and wye==None):
        Z12, Z23, Z31 = delta # Gather particular impedances
        Zsum = Z12 + Z23 + Z31 # Find Sum
        # Calculate Wye Impedances
        Z1 = Z12*Z31 / Zsum
        Z2 = Z12*Z23 / Zsum
        Z3 = Z23*Z31 / Zsum
        Zset = ( Z1, Z2, Z3 )
        if round!=None: Zset = _np.around(Zset,round)
        return(Zset) # Return Wye Impedances
    elif(delta==None and wye!=None):
        Z1, Z2, Z3 = wye # Gather particular impedances
        Zmultsum = Z1*Z2 + Z2*Z3 + Z3*Z1
        Z23 = Zmultsum / Z1
        Z31 = Zmultsum / Z2
        Z12 = Zmultsum / Z3
        Zset = ( Z12, Z23, Z31 )
        if round!=None: Zset = _np.around(Zset,round)
        return(Zset) # Return Delta Impedances
    else:
        raise ValueError(&#34;ERROR: Either delta or wye impedances must be specified.&#34;)

# Define Single Line Power Flow Calculator
def powerflow( Vsend, Vrec, Zline ):
    &#34;&#34;&#34;
    Simple Power-Flow Calculator
    
    This function is designed to calculate the ammount of real
    power transferred from the sending end to the recieving end
    of an electrical line given the sending voltage (complex),
    the receiving voltage (complex) and the line impedance.
    
    .. math::
       P_{flow}=\\frac{|V_{send}|*|V_{rec}|}{Z_{line}}*sin(\\theta_{send}
       -\\theta_{rec})
    
    Parameters
    ----------
    Vsend:      complex
                The sending-end voltage, should be complex
    Vrec:       complex
                The receiving-end voltage, should be complex
    Zline:      complex
                The line impedance, should be complex
    
    Returns
    -------
    pflow:      complex
                The power transferred from sending-end to
                receiving-end, positive values denote power
                flow from send to receive, negative values
                denote vice-versa.
    &#34;&#34;&#34;
    # Evaluate the Input Terms
    Vs = abs( Vsend )
    ds = _c.phase( Vsend )
    Vr = abs( Vrec )
    dr = _c.phase( Vrec )
    # Calculate Power Flow
    pflow = (Vs * Vr)/(Zline) * _np.sin( ds-dr )
    return( pflow )

# Define Impedance From Power and X/R
def zsource(S,V,XoR,Sbase=None,Vbase=None,perunit=True):
    &#34;&#34;&#34;
    Source Impedance Calculator
    
    Used to calculate the source impedance given the apparent power
    magnitude and the X/R ratio.
    
    Parameters
    ----------
    S:          float
                The (rated) apparent power magnitude of the source.
                This may also be refferred to as the &#34;Short-Circuit MVA&#34;
    V:          float
                The (rated) voltage of the source terminals, not
                specifically identified as either Line-to-Line or Line-to-
                Neutral.
    XoR:        float
                The X/R ratio rated for the source, may optionally be a list
                of floats to accomidate sequence impedances or otherwise.
    Sbase:      float, optional
                The per-unit base for the apparent power. If set to
                None, will automatically force Sbase to equal S.
                If set to True will treat S as the per-unit value.
    Vbase:      float, optional
                The per-unit base for the terminal voltage. If set to
                None, will automaticlaly force Vbase to equal V. If
                set to True, will treat V as the per-unit value.
    perunit:    boolean, optional
                Control value to enable the return of output in per-
                unit base. default=True
    
    Returns
    -------
    Zsource_pu: complex
                The per-unit evaluation of the source impedance.
                Will be returned in ohmic (not per-unit) value if
                *perunit* argument is specified as False.
    &#34;&#34;&#34;
    # Force Sbase and Vbase if needed
    if Vbase == None:
        Vbase = V
    if Sbase == None:
        Sbase = S
    # Prevent scaling if per-unit already applied
    if Vbase == True:
        Vbase = 1
    if Sbase == True:
        Sbase = 1
    # Set to per-unit
    Spu = S/Sbase
    Vpu = V/Vbase
    # Evaluate Zsource Magnitude
    Zsource_pu = Vpu**2/Spu
    # Evaluate the angle
    nu = _np.degrees(_np.arctan(XoR))
    # Conditionally Evaluate Phasor Impedance
    if isinstance(nu, (list,_np.ndarray)):
        Zsource_pu = []
        for angle in nu:
            Zsource_pu.append(phasor(Zsource_pu, angle))
    else:
        Zsource_pu = phasor(Zsource_pu, nu)
    if not perunit:
        Zsource = Zsource_pu * Vbase**2/Sbase
        return(Zsource)
    return(Zsource_pu)

# Define Impedance Decomposer
def zdecompose(Zmag,XoR):
    &#34;&#34;&#34;
    Impedance Decomposition Function
    
    A function to decompose the impedance magnitude into its
    corresponding resistance and reactance using the X/R ratio.
    
    It is possible to &#34;neglect&#34; R, or make it a very small number;
    this is done by setting the X/R ratio to a very large number
    (X being much larger than R).
    
    Parameters
    ----------
    Zmag:       float
                The magnitude of the impedance.
    XoR:        float
                The X/R ratio (reactance over impedance).
    
    Returns
    -------
    R:          float
                The resistance (in ohms)
    X:          float
                The reactance (in ohms)
    &#34;&#34;&#34;
    # Evaluate Resistance
    R = Zmag/_np.sqrt(XoR**2+1)
    # Evaluate Reactance
    X = R * XoR
    # Return
    return(R,X)

# Define HP to Watts Calculation
def hp_to_watts(hp):
    &#34;&#34;&#34;
    Horsepower to Watts Formula
    
    Calculates the power (in watts) given the
    horsepower.
    
    .. math:: P_{\\text{watts}}=P_{\\text{horsepower}}\\cdot745.699872
    
    Same as `watts`.
    
    Parameters
    ----------
    hp:         float
                The horspower to compute.
    
    Returns
    -------
    watts:      float
                The power in watts.
    &#34;&#34;&#34;
    return(hp * 745.699872)
watts = hp_to_watts # Make Duplicate Name
# Define Watts to HP Calculation
def watts_to_hp(watts):
    &#34;&#34;&#34;
    Watts to Horsepower Function
    
    Calculates the power (in horsepower) given
    the power in watts.
    
    .. math:: P_{\\text{horsepower}}=\\frac{P_{\\text{watts}}}{745.699872}
    
    Same as `horsepower`.
    
    Parameters
    ----------
    watts:      float
                The wattage to compute.
    
    Returns
    -------
    hp:         float
                The power in horsepower.
    &#34;&#34;&#34;
    return(watts / 745.699872)
horsepower = watts_to_hp # Make Duplicate Name
    
# Define Power Reactance Calculator
def powerimpedance(S,V,PF=None,parallel=False,terms=False):
    &#34;&#34;&#34;
    Impedance from Apparent Power Formula
    
    Function to determine the ohmic resistance/reactance
    (impedance) represented by the apparent power (S).
    
    .. math:: Z = \\frac{V^2}{S}
       :label: series
    
    .. math:: Z = \\frac{V^2}{(3*S)}
       :label: parallel
    
    This function can evaluate the component values for
    both series :eq:`series` and parallel :eq:`parallel`
    connected circuits.
    
    Parameters
    ----------
    S:          complex, float
                The apparent power of the passive element,
                may be purely resistive or purely reactive.
    V:          float
                The operating voltage of the passive element.
                Note that this is specifically not Line-Line or
                Line-Neutral voltage, rather the voltage of the
                element.
    PF:         float, optional
                The operating Power-Factor, should be specified
                if S is given as a float (not complex). Positive
                PF correlates to lagging, negative to leading.
                default=None
    parallel:   bool, optional
                Control point to specify whether the ohmic
                impedance should be returned as series components
                (False opt.) or parallel components (True opt.).
    terms:      bool, optional
                Control point to specify whether return should
                be made as resistance and reactance, or simply
                the complex impedance. Setting of False will
                return complex impedance, setting of True will
                return individual components (R, X).
    
    Returns
    -------
    R:          float
                The ohmic resistance required to consume the
                specified apparent power (S) at the rated
                voltage (V).
    X:          float
                The ohmic reactance required to consume the
                specified apparent power (S) at the rated
                voltage (V).
    &#34;&#34;&#34;
    # Condition Inputs
    V = abs(V)
    # Test for Parallel Component Option and Evaluate
    if isinstance(S,complex) or PF != None:
        if PF != None:
            # Evaluate Elements
            P,Q,S,PF = powerset(S=S,PF=PF)
        else:
            P = S.real
            Q = S.imag
        # Compute Elements
        if parallel:
            R = V**2 / (3*P)
            X = V**2 / (3*Q)
        else:
            R = V**2 / (P)
            X = V**2 / (Q)
        # Conditionally Return as Impedance
        if terms:
            return( R, X )
        return( R + 1j*X )
    # Not Complex (just R)
    R = V**2 / S
    return( R )

# Define Cold-Junction-Voltage Calculator
def coldjunction(Tcj,coupletype=&#34;K&#34;,To=None,Vo=None,P1=None,P2=None,
                 P3=None,P4=None,Q1=None,Q2=None,round=None):
    &#34;&#34;&#34;
    Thermocouple Cold-Junction Formula
    
    Function to calculate the expected cold-junction-voltage given
    the temperature at the cold-junction.
    
    Parameters
    ----------
    Tcj:        float
                The temperature (in degrees C) that the junction is
                currently subjected to.
    coupletype: string, optional
                Thermocouple Type, may be one of (B,E,J,K,N,R,S,T), default=&#34;K&#34;
    To:         float, optional
                Temperature Constant used in Polynomial.
    Vo:         float, optional
                Voltage Constant used in Polynomial.
    P1:         float, optional
                Polynomial constant.
    P2:         float, optional
                Polynomial constant.
    P3:         float, optional
                Polynomial constant.
    P4:         float, optional
                Polynomial constant.
    Q1:         float, optional
                Polynomial constant.
    Q2:         float, optional
                Polynomial constant.
    Q3:         float, optional
                Polynomial constant.
    round:      int, optional
                Control input to specify how many decimal places the result
                should be rounded to, default=1.
    
    Returns
    -------
    Vcj:        float
                The calculated cold-junction-voltage in volts.
    &#34;&#34;&#34;
    # Condition Inputs
    coupletype = coupletype.upper()
    # Validate Temperature Range
    if coupletype == &#34;B&#34;:
        if not (0 &lt; Tcj and Tcj &lt; 70):
            raise ValueError(&#34;Temperature out of range.&#34;)
    else:
        if not (-20 &lt; Tcj and Tcj &lt; 70):
            raise ValueError(&#34;Temperature out of range.&#34;)
    # Define Constant Lookup System
    lookup = [&#34;B&#34;,&#34;E&#34;,&#34;J&#34;,&#34;K&#34;,&#34;N&#34;,&#34;R&#34;,&#34;S&#34;,&#34;T&#34;]
    if not (coupletype in lookup):
        raise ValueError(&#34;Invalid Thermocouple Type&#34;)
    index = lookup.index(coupletype)
    # Define Constant Dictionary
    constants = {   &#34;To&#34; : [4.2000000E+01,2.5000000E+01,2.5000000E+01,2.5000000E+01,7.0000000E+00,2.5000000E+01,2.5000000E+01,2.5000000E+01],
                    &#34;Vo&#34; : [3.3933898E-04,1.4950582E+00,1.2773432E+00,1.0003453E+00,1.8210024E-01,1.4067016E-01,1.4269163E-01,9.9198279E-01],
                    &#34;P1&#34; : [2.1196684E-04,6.0958443E-02,5.1744084E-02,4.0514854E-02,2.6228256E-02,5.9330356E-03,5.9829057E-03,4.0716564E-02],
                    &#34;P2&#34; : [3.3801250E-06,-2.7351789E-04,-5.4138663E-05,-3.8789638E-05,-1.5485539E-04,2.7736904E-05,4.5292259E-06,7.1170297E-04],
                    &#34;P3&#34; : [-1.4793289E-07,-1.9130146E-05,-2.2895769E-06,-2.8608478E-06,2.1366031E-06,-1.0819644E-06,-1.3380281E-06,6.8782631E-07],
                    &#34;P4&#34; : [-3.3571424E-09,-1.3948840E-08,-7.7947143E-10,-9.5367041E-10,9.2047105E-10,-2.3098349E-09,-2.3742577E-09,4.3295061E-11],
                    &#34;Q1&#34; : [-1.0920410E-02,-5.2382378E-03,-1.5173342E-03,-1.3948675E-03,-6.4070932E-03,2.6146871E-03,-1.0650446E-03,1.6458102E-02],
                    &#34;Q2&#34; : [-4.9782932E-04,-3.0970168E-04,-4.2314514E-05,-6.7976627E-05,8.2161781E-05,-1.8621487E-04,-2.2042420E-04,0.0000000E+00]
                }
    # Load Data Into Terms
    if To == None:
        To = constants[&#34;To&#34;][index]
    if Vo == None:
        Vo = constants[&#34;Vo&#34;][index]
    if P1 == None:
        P1 = constants[&#34;P1&#34;][index]
    if P2 == None:
        P2 = constants[&#34;P2&#34;][index]
    if P3 == None:
        P3 = constants[&#34;P3&#34;][index]
    if P4 == None:
        P4 = constants[&#34;P4&#34;][index]
    if Q1 == None:
        Q1 = constants[&#34;Q1&#34;][index]
    if Q2 == None:
        Q2 = constants[&#34;Q2&#34;][index]
    # Define Formula Terms
    tx = (Tcj-To)
    num = tx*(P1+tx*(P2+tx*(P3+P4*tx)))
    den = 1+tx*(Q1+Q2*tx)
    Vcj = Vo + num/den
    # Round Value if Allowed
    if round != None:
        Vcj = _np.around(Vcj, round)
    # Return in milivolts
    return(Vcj*m)
    
# Define Thermocouple Temperature Calculation
def thermocouple(V,coupletype=&#34;K&#34;,fahrenheit=False,cjt=None,To=None,Vo=None,P1=None,
                 P2=None,P3=None,P4=None,Q1=None,Q2=None,Q3=None,round=1):
    &#34;&#34;&#34;
    Thermocouple Temperature Calculator
    
    Utilizes polynomial formula to calculate the temperature being monitored
    by a thermocouple. Allows for various thermocouple types (B,E,J,K,N,R,S,T)
    and various cold-junction-temperatures.
    
    Parameters
    ----------
    V:          float
                Measured voltage (in Volts)
    coupletype: string, optional
                Thermocouple Type, may be one of (B,E,J,K,N,R,S,T), default=&#34;K&#34;
    fahrenheit: bool, optional
                Control to enable return value as Fahrenheit instead of Celsius,
                default=False
    cjt:        float, optional
                Cold-Junction-Temperature
    To:         float, optional
                Temperature Constant used in Polynomial.
    Vo:         float, optional
                Voltage Constant used in Polynomial.
    P1:         float, optional
                Polynomial constant.
    P2:         float, optional
                Polynomial constant.
    P3:         float, optional
                Polynomial constant.
    P4:         float, optional
                Polynomial constant.
    Q1:         float, optional
                Polynomial constant.
    Q2:         float, optional
                Polynomial constant.
    Q3:         float, optional
                Polynomial constant.
    round:      int, optional
                Control input to specify how many decimal places the result
                should be rounded to, default=1.
    
    Returns
    -------
    T:          float
                The temperature (by default in degrees C, but optionally in
                degrees F) as computed by the function.
    &#34;&#34;&#34;
    # Condition Inputs
    coupletype = coupletype.upper()
    V = V/m # Scale volts to milivolts
    # Determine Cold-Junction-Voltage
    if cjt != None:
        Vcj = coldjunction(cjt,coupletype,To,Vo,P1,P2,P3,P4,Q1,Q2,round)
        V += Vcj/m
    # Define Constant Lookup System
    lookup = [&#34;B&#34;,&#34;E&#34;,&#34;J&#34;,&#34;K&#34;,&#34;N&#34;,&#34;R&#34;,&#34;S&#34;,&#34;T&#34;]
    if not (coupletype in lookup):
        raise ValueError(&#34;Invalid Thermocouple Type&#34;)
    # Define Voltage Ranges
    voltages = {&#34;J&#34; : [-8.095, 0,      21.840, 45.494, 57.953, 69.553],
                &#34;K&#34; : [-6.404, -3.554, 4.096,  16.397, 33.275, 69.553],
                &#34;B&#34; : [0.291,  2.431,  13.820, None,   None,   None],
                &#34;E&#34; : [-9.835, -5.237, 0.591,  24.964, 53.112, 76.373],
                &#34;N&#34; : [-4.313, 0,      20.613, 47.513, None,   None],
                &#34;R&#34; : [-0.226, 1.469,  7.461,  14.277, 21.101, None],
                &#34;S&#34; : [-0.236, 1.441,  6.913,  12.856, 18.693, None],
                &#34;T&#34; : [-6.18,  -4.648, 0,      9.288,  20.872, None]}
    # Determine Array Selection
    vset = voltages[coupletype]
    if V &lt; vset[0]*m:
        raise ValueError(&#34;Voltage Below Lower Bound&#34;)
    elif vset[0] &lt;= V &lt; vset[1]:
        select = 0
    elif vset[1] &lt;= V &lt; vset[2]:
        select = 1
    elif vset[2] &lt;= V &lt; vset[3]:
        select = 2
    elif vset[3] &lt;= V &lt; vset[4]:
        select = 3
    elif vset[4] &lt;= V &lt;= vset[5]:
        select = 4
    elif vset[5] &lt; V:
        raise ValueError(&#34;Voltage Above Upper Bound&#34;)
    else:
        raise ValueError(&#34;Internal Error!&#34;)
    # Define Dictionary of Arrays
    data = {&#34;J&#34; : [[-6.4936529E+01,2.5066947E+02,6.4950262E+02,9.2510550E+02,1.0511294E+03],
                   [-3.1169773E+00,1.3592329E+01,3.6040848E+01,5.3433832E+01,6.0956091E+01],
                   [2.2133797E+01,1.8014787E+01,1.6593395E+01,1.6243326E+01,1.7156001E+01],
                   [2.0476437E+00,-6.5218881E-02,7.3009590E-01,9.2793267E-01,-2.5931041E+00],
                   [-4.6867532E-01,-1.2179108E-02,2.4157343E-02,6.4644193E-03,-5.8339803E-02],
                   [-3.6673992E-02,2.0061707E-04,1.2787077E-03,2.0464414E-03,1.9954137E-02],
                   [1.1746348E-01,-3.9494552E-03,4.9172861E-02,5.2541788E-02,-1.5305581E-01],
                   [-2.0903413E-02,-7.3728206E-04,1.6813810E-03,1.3682959E-04,-2.9523967E-03],
                   [-2.1823704E-03,1.6679731E-05,7.6067922E-05,1.3454746E-04,1.1340164E-03]],
            &#34;K&#34; : [[-1.2147164E+02,-8.7935962E+00,3.1018976E+02,6.0572562E+02,1.0184705E+03],
                   [-4.1790858E+00,-3.4489914E-01,1.2631386E+01,2.5148718E+01,4.1993851E+01],
                   [3.6069513E+01,2.5678719E+01,2.4061949E+01,2.3539401E+01,2.5783239E+01],
                   [3.0722076E+01,-4.9887904E-01,4.0158622E+00,4.6547228E-02,-1.8363403E+00],
                   [7.7913860E+00,-4.4705222E-01,2.6853917E-01,1.3444400E-02,5.6176662E-02],
                   [5.2593991E-01,-4.4869203E-02,-9.7188544E-03,5.9236853E-04,1.8532400E-04],
                   [9.3939547E-01,2.3893439E-04,1.6995872E-01,8.3445513E-04,-7.4803355E-02],
                   [2.7791285E-01,-2.0397750E-02,1.1413069E-02,4.6121445E-04,2.3841860E-03],
                   [2.5163349E-02,-1.8424107E-03,-3.9275155E-04,2.5488122E-05,0.0]],
            &#34;B&#34; : [[5.0000000E+02,1.2461474E+03],
                   [1.2417900E+00,7.2701221E+00],
                   [1.9858097E+02,9.4321033E+01],
                   [2.4284248E+01,7.3899296E+00],
                   [-9.7271640E+01,-1.5880987E-01],
                   [-1.5701178E+01,1.2681877E-02],
                   [3.1009445E-01,1.0113834E-01],
                   [-5.0880251E-01,-1.6145962E-03],
                   [-1.6163342E-01,-4.1086314E-06]],
            &#34;E&#34; : [[-1.1721668E+02,-5.0000000E+01,2.5014600E+02,6.0139890E+02,8.0435911E+02],
                   [-5.9901698E+00,-2.7871777E+00,1.7191713E+01,4.5206167E+01,6.1359178E+01],
                   [2.3647275E+01,1.9022736E+01,1.3115522E+01,1.2399357E+01,1.2759508E+01],
                   [1.2807377E+01,-1.7042725E+00,1.1780364E+00,4.3399963E-01,-1.1116072E+00],
                   [2.0665069E+00,-3.5195189E-01,3.6422433E-02,9.1967085E-03,3.5332536E-02],
                   [8.6513472E-02,4.7766102E-03,3.9584261E-04,1.6901585E-04,3.3080380E-05],
                   [5.8995860E-01,-6.5379760E-02,9.3112756E-02,3.4424680E-02,-8.8196889E-02],
                   [1.0960713E-01,-2.1732833E-02,2.9804232E-03,6.9741215E-04,2.8497415E-03],
                   [6.1769588E-03,0.0,3.3263032E-05,1.2946992E-05,0.0]],
            &#34;N&#34; : [[-5.9610511E+01,3.1534505E+02,1.0340172E+03],
                   [-1.5000000E+00,9.8870997E+00,3.7565475E+01],
                   [4.2021322E+01,2.7988676E+01,2.6029492E+01],
                   [4.7244037E+00,1.5417343E+00,-6.0783095E-01],
                   [-6.1153213E+00,-1.4689457E-01,-9.7742562E-03],
                   [-9.9980337E-01,-6.8322712E-03,-3.3148813E-06],
                   [1.6385664E-01,6.2600036E-02,-2.5351881E-02],
                   [-1.4994026E-01,-5.1489572E-03,-3.8746827E-04],
                   [-3.0810372E-02,-2.8835863E-04,1.7088177E-06]],
            &#34;R&#34; : [[1.3054315E+02,5.4188181E+02,1.0382132E+03,1.5676133E+03],
                   [8.8333090E-01,4.9312886E+00,1.1014763E+01,1.8397910E+01],
                   [1.2557377E+02,9.0208190E+01,7.4669343E+01,7.1646299E+01],
                   [1.3900275E+02,6.1762254E+00,3.4090711E+00,-1.0866763E+00],
                   [3.3035469E+01,-1.2279323E+00,-1.4511205E-01,-2.0968371E+00],
                   [-8.5195924E-01,1.4873153E-02,6.3077387E-03,-7.6741168E-01],
                   [1.2232896E+00,8.7670455E-02,5.6880253E-02,-1.9712341E-02],
                   [3.5603023E-01,-1.2906694E-02,-2.0512736E-03,-2.9903595E-02],
                   [0.0,0.0,0.0,-1.0766878E-02]],
            &#34;S&#34; : [[1.3792630E+02,4.7673468E+02,9.7946589E+02,1.6010461E+03],
                   [9.3395024E-01,4.0037367E+00,9.3508283E+00,1.6789315E+01],
                   [1.2761836E+02,1.0174512E+02,8.7126730E+01,8.4315871E+01],
                   [1.1089050E+02,-8.9306371E+00,-2.3139202E+00,-1.0185043E+01],
                   [1.9898457E+01,-4.2942435E+00,-3.2682118E-02,-4.6283954E+00],
                   [9.6152996E-02,2.0453847E-01,4.6090022E-03,-1.0158749E+00],
                   [9.6545918E-01,-7.1227776E-02,-1.4299790E-02,-1.2877783E-01],
                   [2.0813850E-01,-4.4618306E-02,-1.2289882E-03,-5.5802216E-02],
                   [0.0,1.6822887E-03,0.0,-1.2146518E-02]],
            &#34;T&#34; : [[-1.9243000E+02,-6.0000000E+01,1.3500000E+02,3.0000000E+02],
                   [-5.4798963E+00,-2.1528350E+00,5.9588600E+00,1.4861780E+01],
                   [5.9572141E+01,3.0449332E+01,2.0325591E+01,1.7214707E+01],
                   [1.9675733E+00,-1.2946560E+00,3.3013079E+00,-9.3862713E-01],
                   [-7.8176011E+01,-3.0500735E+00,1.2638462E-01,-7.3509066E-02],
                   [-1.0963280E+01,-1.9226856E-01,-8.2883695E-04,2.9576140E-04],
                   [2.7498092E-01,6.9877863E-03,1.7595577E-01,-4.8095795E-02],
                   [-1.3768944E+00,-1.0596207E-01,7.9740521E-03,-4.7352054E-03],
                   [-4.5209805E-01,-1.0774995E-02,0.0,0.0]]}
    # Load Data Into Terms
    if To == None:
        To = data[coupletype][0][select]
    if Vo == None:
        Vo = data[coupletype][1][select]
    if P1 == None:
        P1 = data[coupletype][2][select]
    if P2 == None:
        P2 = data[coupletype][3][select]
    if P3 == None:
        P3 = data[coupletype][4][select]
    if P4 == None:
        P4 = data[coupletype][5][select]
    if Q1 == None:
        Q1 = data[coupletype][6][select]
    if Q2 == None:
        Q2 = data[coupletype][7][select]
    if Q3 == None:
        Q3 = data[coupletype][8][select]
    # Calculate Temperature in Degrees C
    num = (V-Vo)*(P1+(V-Vo)*(P2+(V-Vo)*(P3+P4*(V-Vo))))
    den = 1 + (V-Vo)*(Q1+(V-Vo)*(Q2+Q3*(V-Vo)))
    temp = To + num/den
    # Return Temperature
    if fahrenheit:
        temp = (temp*9/5)+32
    temp = _np.around(temp,round)
    return(temp)

# Define RTD Calculator
def rtdtemp(RT,rtdtype=&#34;PT100&#34;,fahrenheit=False,Rref=None,Tref=None,
            a=None,round=1):
    &#34;&#34;&#34;
    RTD Temperature Calculator
    
    Evaluates the measured temperature based on the measured resistance
    and the RTD type.
    
    Parameters
    ----------
    RT:         float
                The measured resistance (in ohms).
    rtdtype:    string
                RTD Type string, may be one of: (PT100, PT1000,
                CU100, NI100, NI120, NIFE), default=PT100
    fahrenheit: bool, optional
                Control parameter to force return into degrees
                fahrenheit, default=False
    Rref:       float, optional
                Resistance reference, commonly used if non-standard
                RTD type being used. Specified in ohms.
    Tref:       float, optional
                Temperature reference, commonly used if non-standard
                RTD type being used. Specified in degrees Celsius.
    a:          float, optional
                Scaling value, commonly used if non-standard
                RTD type being used.
    round:      int, optional
                Control argument to specify number of decimal points
                in returned value.
    
    Returns
    -------
    temp:       float
                Calculated temperature, defaults to degrees Celsius.
    &#34;&#34;&#34;
    # Define list of available builtin RTD Types
    types = {   &#34;PT100&#34; : [100,0.00385],
                &#34;PT1000&#34;: [1000,0.00385],
                &#34;CU100&#34; : [100,0.00427],
                &#34;NI100&#34; : [100,0.00618],
                &#34;NI120&#34; : [120,0.00672],
                &#34;NIFE&#34;  : [604,0.00518]
            }
    # Load Variables
    if Rref==None:
        Rref = types[rtdtype][0]
    if Tref==None:
        Tref = 0
    if a==None:
        a = types[rtdtype][1]
    # Define Terms
    num = RT - Rref + Rref*a*Tref
    den = Rref*a
    temp = num/den
    # Return Temperature
    if fahrenheit:
        temp = (temp*9/5)+32
    temp = _np.around(temp,round)
    return(temp)
    
# Define Capacitor Voltage Discharge Function
def vcapdischarge(t,Vs,R,C):
    &#34;&#34;&#34;
    Discharging Capacitor Function
    
    Function to calculate the voltage of a
    capacitor that is discharging given the time.
    
    .. math:: V_c=V_s*e^{\\frac{-t}{R*C}}
    
    Parameters
    ----------
    t:          float
                The time at which to calculate the voltage.
    Vs:         float
                The starting voltage for the capacitor.
    R:          float
                The ohmic value of the resistor being used
                to discharge.
    C:          float
                Capacitive value (in Farads).
    
    Returns
    -------
    Vc:         float
                The calculated voltage of the capacitor.
    &#34;&#34;&#34;
    Vc = Vs*(_np.exp(-t/(R*C)))
    return(Vc)

# Define Capacitor Voltage Charge Function
def vcapcharge(t,Vs,R,C):
    &#34;&#34;&#34;
    Charging Capacitor Voltage
    
    Function to calculate the voltage of a
    capacitor that is charging given the time.
    
    .. math:: V_c=V_s*(1-e^{\\frac{-t}{R*C}})
    
    Parameters
    ----------
    t:          float
                The time at which to calculate the voltage.
    Vs:         float
                The charging voltage for the capacitor.
    R:          float
                The ohmic value of the resistor being used
                to discharge.
    C:          float
                Capacitive value (in Farads).
    
    Returns
    -------
    Vc:         float
                The calculated voltage of the capacitor.
    &#34;&#34;&#34;
    Vc = Vs*(1-_np.exp(-t/(R*C)))
    return(Vc)
    
# Define Capacitive Energy Transfer Function
def captransfer(t,Vs,R,Cs,Cd):
    &#34;&#34;&#34;
    Capacitor Energy Transfer Function
    
    Calculate the voltage across a joining
    resistor (R) that connects Cs and Cd, the
    energy-source and -destination capacitors,
    respectively. Calculate the final voltage
    across both capacitors.
    
    Parameters
    ----------
    t:          float
                Time at which to calculate resistor voltage.
    Vs:         float
                Initial voltage across source-capacitor (Cs).
    R:          float
                Value of resistor that connects capacitors.
    Cs:         float
                Source capacitance value in Farads.
    Cd:         float
                Destination capacitance value in Farads.
    
    Returns
    -------
    rvolt:      float
                Voltage across the resistor at time t.
    vfinal:     float
                Final voltage that both capacitors settle to.
    &#34;&#34;&#34;
    tau = (R*Cs*Cd) / (Cs+Cd)
    rvolt = Vs*_np.exp(-t/tau)
    vfinal = Vs*Cs/(Cs+Cd)
    return(rvolt,vfinal)
    
# Define Inductor Energy Formula
def inductorenergy(L,I):
    &#34;&#34;&#34;
    Energy Stored in Inductor Formula
    
    Function to calculate the energy stored in an inductor
    given the inductance (in Henries) and the current.
    
    .. math:: E=\\frac{1}{2}*L*I^2
    
    Parameters
    ----------
    L:          float
                Inductance Value (in Henries)
    I:          float
                Current traveling through inductor.
    
    Returns
    -------
    E:          float
                The energy stored in the inductor (in Joules).
    &#34;&#34;&#34;
    return(1/2 * L * I**2)

# Define Inductor Charge Function
def inductorcharge(t,Vs,R,L):
    &#34;&#34;&#34;
    Charging Inductor Formula
    
    Calculates the Voltage and Current of an inductor
    that is charging/storing energy.
    
    .. math::
       V_L = V_s*e^{\\frac{-R*t}{L}}//
       I_L = \\frac{V_s}{R}*(1-e^{\\frac{-R*t}{L}})
    
    Parameters
    ----------
    t:          float
                Time at which to calculate voltage and current.
    Vs:         float
                Charging voltage across inductor and resistor.
    R:          float
                Resistance related to inductor.
    L:          float
                Inductance value in Henries.
    
    Returns
    -------
    Vl:         float
                Voltage across inductor at time t.
    Il:         float
                Current through inductor at time t.
    &#34;&#34;&#34;
    Vl = Vs*_np.exp(-R*t/L)
    Il = Vs/R*(1-_np.exp(-R*t/L))
    return(Vl,Il)

# Define Capacitive Back-to-Back Switching Formula
def capbacktoback(C1,C2,Lm,VLN=None,VLL=None):
    &#34;&#34;&#34;
    Back to Back Capacitor Transient Current Calculator
    
    Function to calculate the maximum current and the 
    frequency of the inrush current of two capacitors
    connected in parallel when one (energized) capacitor
    is switched into another (non-engergized) capacitor.
    
    .. note:: This formula is only valid for three-phase systems.
    
    Parameters
    ----------
    C1:         float
                The capacitance of the
    VLN:        float, exclusive
                The line-to-neutral voltage experienced by
                any one of the (three) capacitors in the
                three-phase capacitor bank.
    VLL:        float, exclusive
                The line-to-line voltage experienced by the
                three-phase capacitor bank.
    
    Returns
    -------
    imax:       float
                Maximum Current Magnitude during Transient
    ifreq:      float
                Transient current frequency
    &#34;&#34;&#34;
    # Evaluate Max Current
    imax = _np.sqrt(2/3)*VLL*_np.sqrt((C1*C2)/((C1+C2)*Lm))
    # Evaluate Inrush Current Frequency
    ifreq = 1/(2*_np.pi*_np.sqrt(Lm*(C1*C2)/(C1+C2)))
    return(imax,ifreq)

# Define Inductor Discharge Function
def inductordischarge(t,Io,R,L):
    &#34;&#34;&#34;
    Discharging Inductor Formula
    
    Calculates the Voltage and Current of an inductor
    that is discharging its stored energy.
    
    .. math::
       I_L=I_0*e^{\\frac{-R*t}{L}}//
       V_L=I_0*R*(1-e^{\\frac{-R*t}{L}})
    
    Parameters
    ----------
    t:          float
                Time at which to calculate voltage and current.
    Io:         float
                Initial current traveling through inductor.
    R:          float
                Resistance being discharged to.
    L:          float
                Inductance value in Henries.
    
    Returns
    -------
    Vl:         float
                Voltage across inductor at time t.
    Il:         float
                Current through inductor at time t.
    &#34;&#34;&#34;
    Il = Io*_np.exp(-R*t/L)
    Vl = Io*R*(1-_np.exp(-R*t/L))
    return(Vl,Il)
    
# Define Apparent Power to Farad Conversion
def farads(VAR,V,freq=60):
    &#34;&#34;&#34;
    Capacitance from Apparent Power Formula
    
    Function to calculate the required capacitance
    in Farads to provide the desired power rating
    (VARs).
    
    .. math:: C = \\frac{VAR}{2*\\pi*freq*V^2}
    
    Parameters
    ----------
    VAR:        float
                The rated power to meet.
    V:          float
                The voltage across the capacitor;
                not described as VLL or VLN, merely
                the capacitor voltage.
    freq:       float, optional
                The System frequency
    
    Returns
    -------
    C:          float
                The evaluated capacitance (in Farads).
    &#34;&#34;&#34;
    return(VAR / (2*_np.pi*freq*V**2))

# Define Capacitor Energy Calculation
def capenergy(C,v):
    &#34;&#34;&#34;
    Capacitor Energy Formula
    
    A simple function to calculate the stored voltage (in Joules)
    in a capacitor with a charged voltage.
    
    .. math:: E=\\frac{1}{2}*C*V^2
    
    Parameters
    ----------
    C:          float
                Capacitance in Farads.
    V:          float
                Voltage across capacitor.
    
    Returns
    -------
    energy:     float
                Energy stored in capacitor (Joules).
    &#34;&#34;&#34;
    energy = 1/2 * C * V**2
    return(energy)

# Define Capacitor Voltage Discharge Function
def loadedvcapdischarge(t,vo,C,P):
    &#34;&#34;&#34;
    Loaded Capacitor Discharge Formula
    
    Returns the voltage of a discharging capacitor after time (t - 
    seconds) given initial voltage (vo - volts), capacitor size
    (cap - Farads), and load (P - Watts).
    
    .. math:: V_t=\\sqrt{v_0^2-2*P*\\frac{t}{C}}
    
    Parameters
    ----------
    t:          float
                Time at which to calculate voltage.
    vo:         float
                Initial capacitor voltage.
    C:          float
                Capacitance (in Farads)
    P:          float
                Load power consumption (in Watts).
    
    Returns
    -------
    Vt:         float
                Voltage of capacitor at time t.
    &#34;&#34;&#34;
    Vt = _np.sqrt(vo**2 - 2*P*t/C)
    return(Vt)
    
# Define Capacitor Discharge Function
def timedischarge(Vinit,Vmin,C,P,dt=1e-3,RMS=True,Eremain=False):
    &#34;&#34;&#34;
    Capacitor Discharge Time Formula
    
    Returns the time to discharge a capacitor to a specified
    voltage given set of inputs.
    
    Parameters
    ----------
    Vinit:      float
                Initial Voltage (in volts)
    Vmin:       float
                Final Voltage (the minimum allowable voltage) (in volts)
    C:          float
                Capacitance (in Farads)
    P:          float
                Load Power being consumed (in Watts)
    dt:         float, optional
                Time step-size (in seconds) (defaults to 1e-3 | 1ms)
    RMS:        bool, optional
                if true converts RMS Vin to peak
    Eremain:    bool, optional
                if true: also returns the energy remaining in cap
    
    Returns
    -------
    Returns time to discharge from Vinit to Vmin in seconds.
    May also return remaining energy in capacitor if Eremain=True
    &#34;&#34;&#34;
    t = 0 # start at time t=0
    if RMS:
        vo = Vinit*_np.sqrt(2) # convert RMS to peak
    else:
        vo = Vinit
    vc = loadedvcapdischarge(t,vo,C,P) # set initial cap voltage
    while(vc &gt;= Vmin):
        t = t+dt # increment the time
        vcp = vc # save previous voltage
        vc = loadedvcapdischarge(t,vo,C,P) # calc. new voltage
    if(Eremain):
        E = energy(C,vcp) # calc. energy
        return(t-dt,E)
    else:
        return(t-dt)


# Define Rectifier Capacitor Calculator
def rectifiercap(Iload, fswitch, dVout):
    &#34;&#34;&#34;
    Rectifier Capacitor Formula
    
    Returns the capacitance (in Farads) for a needed capacitor in
    a rectifier configuration given the system frequency (in Hz),
    the load (in amps) and the desired voltage ripple.
    
    .. math:: C=\\frac{I_{load}}{f_{switch}*\\Delta V_{out}}
    
    Parameters
    ----------
    Iload:      float
                The load current that must be met.
    fswitch:    float
                The switching frequency of the system.
    dVout:      float
                Desired delta-V on the output.
    
    Returns
    -------
    C:          float
                Required capacitance (in Farads) to meet arguments.
    &#34;&#34;&#34;
    C = Iload / (fswitch * dVout)
    return(C)

# Define function to find VDC setpoint
def vscdcbus(VLL,Zs,P,Q=0,mmax=0.8,debug=False):
    &#34;&#34;&#34;
    Voltage Sourced Converter DC Bus Voltage Function
    
    The purpose of this function is to calculate the
    required DC-bus voltage for a Voltage-Sourced-
    Converter (VSC) given the desired P/Q parameters
    and the known source impedance (Vs) of the VSC.
    
    Parameters
    ----------
    VLL:    complex
            Line-to-Line voltage on the line-side of
            the source impedance.
    Zs:     complex
            The source impedance of the VSC
    P:      float
            The desired real-power output
    Q:      float, optional
            The desired reactive-power output, default=0
    mmax:   float, optional
            The maximum of the m value for the converter
            default=0.8
    debug:  bool, optional
            Control value to enable printing stages of
            the calculation, default=False
            
    Return
    ------
    VDC:    float
            The DC bus voltage.
    &#34;&#34;&#34;
    # Determine the Load Current
    Iload = _np.conj((P+1j*Q) / (VLL*_np.sqrt(3)))
    # Evaluate the Terminal Voltage
    Vtln = abs(VLL/_np.sqrt(3) + Iload*Zs)
    # Find the Peak Terminal Voltage
    Vtpk = _np.sqrt(2)*Vtln
    # Calculate the VDC value
    VDC = 2*Vtpk / mmax
    if debug:
        print(&#34;Iload&#34;, Iload)
        print(&#34;Vtln&#34;, Vtln)
        print(&#34;Vtpk&#34;, Vtpk)
        print(&#34;VDC&#34;, VDC)
    return(VDC)

# Define kp/ki/w0L calculating function
def vscgains(Rs,Ls,tau=0.005,freq=60):
    &#34;&#34;&#34;
    Voltage Sourced Converter Gains Calculator
    
    This function is designed to calculate the kp, ki,
    and omega-not-L values for a Phase-Lock-Loop based VSC.
    
    Parameters
    ----------
    Rs:     float
            The equiv-resistance (in ohms) of the VSC
    Ls:     float
            The equiv-inductance (in Henrys) of the VSC
    tau:    float, optional
            The desired time-constant, default=0.005
    freq:   float, optional
            The system frequency (in Hz), default=60
    
    Returns
    -------
    kp:     float
            The Kp-Gain Value
    ki:     float
            The Ki-Gain Value
    w0L:    float
            The omega-not-L gain value
    &#34;&#34;&#34;
    # Calculate kp
    kp = Ls / tau
    # Calculate ki
    ki = kp*Rs/Ls
    # Calculate w0L
    w0L = 2*_np.pi*freq*Ls
    return(kp,ki,w0L)

# Define Convolution Bar-Graph Function:
def convbar(h, x, outline=True):
    &#34;&#34;&#34;
    Convolution Bar-Graph Plotter Function
    
    Generates plots of each of two input arrays as bar-graphs, then
    generates a convolved bar-graph of the two inputs to demonstrate
    and illustrate convolution, typically for an educational purpose.
    
    Parameters
    ----------
    h:      numpy.ndarray
            Impulse Response - Given as Array (Prefferably Numpy Array)
    x:      numpy.ndarray
            Input Function - Given as Array (Prefferably Numpy Array)
    &#34;&#34;&#34;
    
    # The impulse response
    M = len(h)
    t = _np.arange(M)
    # Plot
    _plt.subplot(121)
    if(outline): _plt.plot(t,h,color=&#39;red&#39;)
    _plt.bar(t,h,color=&#39;black&#39;)
    _plt.xticks([0,5,9])
    _plt.ylabel(&#39;h&#39;)
    _plt.title(&#39;Impulse Response&#39;)
    _plt.grid()

    # The input function
    N = len(x)
    s = _np.arange(N)
    # Plot
    _plt.subplot(122)
    if(outline): _plt.plot(s,x,color=&#39;red&#39;)
    _plt.bar(s,x,color=&#39;black&#39;)
    _plt.xticks([0,10,19])
    _plt.title(&#39;Input Function&#39;)
    _plt.grid()
    _plt.ylabel(&#39;x&#39;)

    # The output
    L = M+N-1
    w = _np.arange(L)
    _plt.figure(3)
    y = _np.convolve(h,x)
    if(outline): _plt.plot(w,y,color=&#39;red&#39;)
    _plt.bar(w,y,color=&#39;black&#39;)
    _plt.ylabel(&#39;y&#39;)
    _plt.grid()
    _plt.title(&#39;Convolved Output&#39;)
    _plt.show()


# Define convolution function
def convolve(tuple):
    &#34;&#34;&#34;
    Filter Convolution Function
    
    Given a tuple of terms, convolves all terms in tuple to
    return one tuple as a numpy array.
    
    Parameters
    ---------
    tuple:      tuple of numpy.ndarray
                Tuple of terms to be convolved.
    
    Returns
    -------
    c:          The convolved set of the individual terms.
                i.e. numpy.ndarray([ x1, x2, x3, ..., xn ])
    &#34;&#34;&#34;
    c = sig.convolve(tuple[0],tuple[1])
    if (len(tuple) &gt; 2):
        # Iterate starting with second element and continuing
        for i in range(2,len(tuple)):
            c = sig.convolve(c,tuple[i])
    return(c)

# Define Step function
def step(t):
    &#34;&#34;&#34;
    Step Function [ u(t) ]
    
    Simple implimentation of numpy.heaviside function
    to provide standard step-function as specified to
    be zero at x&lt;0, and one at x&gt;=0.
    &#34;&#34;&#34;
    return( _np.heaviside( t, 1) )

# Define Peak Calculator
def peak(val):
    &#34;&#34;&#34;
    Sinusoid RMS to Peak Converter
    
    Provides a readable format to convert an
    RMS (Root-Mean-Square) value to its peak
    representation. Performs a simple multiplication
    with the square-root of two.
    &#34;&#34;&#34;
    return(_np.sqrt(2) * val)
    
# Define RMS Calculator
def rms(val):
    &#34;&#34;&#34;
    Sinusoid Peak to RMS Converter
    
    Provides a readable format to convert a peak
    value to its RMS (Root-Mean-Square) representation.
    Performs a simple division by the square-root of
    two.
    &#34;&#34;&#34;
    return(val * _np.sqrt(0.5))

# Arbitrary Waveform RMS Calculating Function
def funcrms(f, T):
    &#34;&#34;&#34;
    Function Root-Mean-Square (RMS) Evaluator
    
    Integral-based RMS calculator, evaluates the RMS value
    of a repetative signal (f) given the signal&#39;s specific
    period (T)

    Parameters
    ----------
    f:      float
            The periodic function, a callable like f(t)
    T:      float
            The period of the function f, so that f(0)==f(T)

    Returns
    -------
    RMS:    The RMS value of the function (f) over the interval ( 0, T )

    &#34;&#34;&#34;
    fn = lambda x: f(x)**2
    integral = integrate(fn,0,T)
    RMS = _np.sqrt(1/T*integral)
    return(RMS)

# Define Gaussian Function
def gaussian(x,mu=0,sigma=1):
    &#34;&#34;&#34;
    Gaussian Function:
    
    This function is designed to generate the gaussian
    distribution curve with configuration mu and sigma.
    
    Parameters
    ----------
    x:      float
            The input (array) x.
    mu:     float, optional
            Optional control argument, default=0
    sigma:  float, optional
            Optional control argument, default=1
    
    Returns
    -------
    Computed gaussian (numpy.ndarray) of the input x
    &#34;&#34;&#34;
    return( 1/(sigma * _np.sqrt(2 * _np.pi)) *
            _np.exp(-(x - mu)**2 / (2 * sigma**2)) )

# Define Gaussian Distribution Function
def gausdist(x,mu=0,sigma=1):
    &#34;&#34;&#34;
    Gaussian Distribution Function:
    
    This function is designed to calculate the generic
    distribution of a gaussian function with controls
    for mu and sigma.
    
    Parameters
    ----------
    x:      numpy.ndarray
            The input (array) x
    mu:     float, optional
            Optional control argument, default=0
    sigma:  float, optional
            Optional control argument, default=1
    
    Returns
    -------
    F:      numpy.ndarray
            Computed distribution of the gausian function at the
            points specified by (array) x
    &#34;&#34;&#34;
    F = _np.array([])
    try:
        lx = len(x) # Find length of Input
    except:
        lx = 1 # Length 1
        x = [x] # Pack into list
    for i in range(lx):
        x_tmp = x[i]
        # Evaluate X (altered by mu and sigma)
        X = (x_tmp-mu) / sigma
        # Define Integrand
        def integrand(sq):
            return( _np.exp(-sq**2/2) )
        integral = integrate(integrand,_np.NINF,X) # Integrate
        result = 1/_np.sqrt(2*_np.pi) * integral[0] # Evaluate Result
        F = _np.append(F, result) # Append to output list
    # Return only the 0-th value if there&#39;s only 1 value available
    if(len(F)==1):
        F = F[0]
    return(F)

# Define Probability Density Function
def probdensity(func,x,x0=0,scale=True):
    &#34;&#34;&#34;
    Probability Density Function:
    
    This function uses an integral to compute the probability
    density of a given function.
    
    Parameters
    ----------
    func:   function
            The function for which to calculate the PDF
    x:      numpy.ndarray
            The (array of) value(s) at which to calculate
            the PDF
    x0:     float, optional
            The lower-bound of the integral, starting point
            for the PDF to be calculated over, default=0
    scale:  bool, optional
            The scaling to be applied to the output,
            default=True
    
    Returns
    -------
    sumx:   numpy.ndarray
            The (array of) value(s) computed as the PDF at
            point(s) x
    &#34;&#34;&#34;
    sumx = _np.array([])
    try:
        lx = len(x) # Find length of Input
    except:
        lx = 1 # Length 1
        x = [x] # Pack into list
    # Recursively Find Probability Density
    for i in range(lx):
        sumx = _np.append(sumx,integrate(func,x0,x[i])[0])
    # Return only the 0-th value if there&#39;s only 1 value available
    if(len(sumx)==1):
        sumx = sumx[0]
    else:
        if(scale==True):
            mx = sumx.max()
            sumx /= mx
        elif(scale!=False):
            sumx /= scale
    return(sumx)

# Define Real FFT Evaluation Function
def rfft(arr,dt=0.01,absolute=True,resample=True):
    &#34;&#34;&#34;
    RFFT Function
    
    This function is designed to evaluat the real FFT
    of a input signal in the form of an array or list.
    
    Parameters
    ----------
    arr:        numpy.ndarray
                The input array representing the signal
    dt:         float, optional
                The time-step used for the array,
                default=0.01
    absolute:   bool, optional
                Control argument to force absolute
                values, default=True
    resample:   bool, optional
                Control argument specifying whether
                the FFT output should be resampled,
                or if it should have a specific
                resampling rate, default=True
    
    Returns
    -------
    FFT Array
    &#34;&#34;&#34;
    # Calculate with Absolute Values
    if absolute:
        fourier = abs(_np.fft.rfft(arr))
    else:
        foruier = _np.fft.rfft(arr)
    if resample==True:
        # Evaluate the Downsampling Ratio
        dn = int(dt*len(arr))
        # Downsample to remove unnecessary points
        fixedfft = filter.dnsample(fourier,dn)
        return(fixedfft)
    elif resample==False:
        return(fourier)
    else:
        # Condition Resample Value
        resample = int(resample)
        # Downsample to remove unnecessary points
        fixedfft = filter.dnsample(fourier,resample)
        return(fixedfft)

# Define Normalized Power Spectrum Function
def wrms(func,dw=0.1,NN=100,quad=False,plot=True,
         title=&#34;Power Density Spectrum&#34;,round=3):
    &#34;&#34;&#34;
    WRMS Function:
    
    This function is designed to calculate the RMS
    bandwidth (Wrms) using a numerical process.
    
    Parameters
    ----------
    func:       function
                The callable function to use for evaluation
    dw:         float, optional
                The delta-omega to be used, default=0.1
    NN:         int, optional
                The total number of points, default=100
    quad:       bool, optional
                Control value to enable use of integrals
                default=False
    plot:       bool, optional
                Control to enable plotting, default=True
    title:      string, optional
                Title displayed with plot,
                default=&#34;Power Density Spectrum&#34;
    round:      int, optional
                Control to round the Wrms on plot,
                default=3
    
    Returns
    -------
    W:          float
                Calculated RMS Bandwidth (rad/sec)
    &#34;&#34;&#34;
    # Define omega
    omega = _np.linspace(0,(NN-1)*del_w,NN)
    # Initialize Fraction Terms
    Stot = Sw2 = 0
    # Power Density Spectrum
    Sxx = _np.array([])
    for n in range(NN):
        # Calculate Power Density Spectrum
        Sxx = _np.append(Sxx,func(omega[n]))
        Stot = Stot + Sxx[n]
        Sw2 = Sw2 + (omega[n]**2)*Sxx[n]
    if(quad):
        def intf(w):
            return(w**2*func(w))
        num = integrate(intf,0,_np.inf)[0]
        den = integrate(func,0,_np.inf)[0]
        # Calculate W
        W = _np.sqrt(num/den)
    else:
        # Calculate W
        W = _np.sqrt(Sw2/Stot)
    Wr = _np.around(W,round)
    # Plot Upon Request
    if(plot):
        _plt.plot(omega,Sxx)
        _plt.title(title)
        # Evaluate Text Location
        x = 0.65*max(omega)
        y = 0.80*max(Sxx)
        _plt.text(x,y,&#34;Wrms: &#34;+str(Wr))
        _plt.show()
    # Return Calculated RMS Bandwidth
    return(W)
        
# Define Hartley&#39;s Equation for Data Capacity
def hartleydata(BW,M):
    &#34;&#34;&#34;
    Hartley Data Function
    
    Function to calculate Hartley&#39;s Law,
    the maximum data rate achievable for
    a given noiseless channel.
    
    Parameters
    ----------
    BW:         float
                Bandwidth of the data channel.
    M:          float
                Number of signal levels.
    
    Returns:
    --------
    C:          float
                Capacity of channel (in bits per second)
    &#34;&#34;&#34;
    C = 2*BW*_np.log2(M)
    return(C)

# Define Shannon&#39;s Equation For Data Capacity
def shannondata(BW,S,N):
    &#34;&#34;&#34;
    Shannon Data Function
    
    Function to calculate the maximum data
    rate that may be achieved given a data
    channel and signal/noise characteristics
    using Shannon&#39;s equation.
    
    Parameters
    ----------
    BW:         float
                Bandwidth of the data channel.
    S:          float
                Signal strength (in Watts).
    N:          float
                Noise strength (in Watts).
    
    Returns
    -------
    C:          float
                Capacity of channel (in bits per second)
    &#34;&#34;&#34;
    C = BW*_np.log2(1+S/N)
    return(C)

# Define CRC Generator (Sender Side)
def crcsender(data, key):
    &#34;&#34;&#34;
    CRC Sender Function
    
    Function to generate a CRC-embedded
    message ready for transmission.
    
    Contributing Author Credit:
    Shaurya Uppal
    Available from: geeksforgeeks.org
    
    Parameters
    ----------
    data:       string of bits
                The bit-string to be encoded.
    key:        string of bits
                Bit-string representing key.
    
    Returns
    -------
    codeword:   string of bits
                Bit-string representation of
                encoded message.
    &#34;&#34;&#34;
    # Define Sub-Functions
    def xor(a, b): 
        # initialize result 
        result = [] 

        # Traverse all bits, if bits are 
        # same, then XOR is 0, else 1 
        for i in range(1, len(b)): 
            if a[i] == b[i]: 
                result.append(&#39;0&#39;) 
            else: 
                result.append(&#39;1&#39;) 

        return(&#39;&#39;.join(result))

    # Performs Modulo-2 division 
    def mod2div(divident, divisor):
        # Number of bits to be XORed at a time. 
        pick = len(divisor) 

        # Slicing the divident to appropriate 
        # length for particular step 
        tmp = divident[0 : pick] 

        while pick &lt; len(divident): 

            if tmp[0] == &#39;1&#39;: 

                # replace the divident by the result 
                # of XOR and pull 1 bit down 
                tmp = xor(divisor, tmp) + divident[pick] 

            else:   # If leftmost bit is &#39;0&#39; 

                # If the leftmost bit of the dividend (or the 
                # part used in each step) is 0, the step cannot 
                # use the regular divisor; we need to use an 
                # all-0s divisor. 
                tmp = xor(&#39;0&#39;*pick, tmp) + divident[pick] 

            # increment pick to move further 
            pick += 1

        # For the last n bits, we have to carry it out 
        # normally as increased value of pick will cause 
        # Index Out of Bounds. 
        if tmp[0] == &#39;1&#39;: 
            tmp = xor(divisor, tmp) 
        else: 
            tmp = xor(&#39;0&#39;*pick, tmp) 

        checkword = tmp 
        return(checkword)
    
    # Condition data
    data = str(data)
    # Condition Key
    key = str(key)
    l_key = len(key)
   
    # Appends n-1 zeroes at end of data 
    appended_data = data + &#39;0&#39;*(l_key-1) 
    remainder = mod2div(appended_data, key) 
   
    # Append remainder in the original data 
    codeword = data + remainder 
    return(codeword)

# Define CRC Generator (Sender Side)
def crcremainder(data, key):
    &#34;&#34;&#34;
    CRC Remainder Function
    
    Function to calculate the CRC
    remainder of a CRC message.
    
    Contributing Author Credit:
    Shaurya Uppal
    Available from: geeksforgeeks.org
    
    Parameters
    ----------
    data:       string of bits
                The bit-string to be decoded.
    key:        string of bits
                Bit-string representing key.
    
    Returns
    -------
    remainder: string of bits
                Bit-string representation of
                encoded message.
    &#34;&#34;&#34;
    # Define Sub-Functions
    def xor(a, b): 
        # initialize result 
        result = [] 

        # Traverse all bits, if bits are 
        # same, then XOR is 0, else 1 
        for i in range(1, len(b)): 
            if a[i] == b[i]: 
                result.append(&#39;0&#39;) 
            else: 
                result.append(&#39;1&#39;) 

        return(&#39;&#39;.join(result))

    # Performs Modulo-2 division 
    def mod2div(divident, divisor):
        # Number of bits to be XORed at a time. 
        pick = len(divisor) 

        # Slicing the divident to appropriate 
        # length for particular step 
        tmp = divident[0 : pick] 

        while pick &lt; len(divident): 

            if tmp[0] == &#39;1&#39;: 

                # replace the divident by the result 
                # of XOR and pull 1 bit down 
                tmp = xor(divisor, tmp) + divident[pick] 

            else:   # If leftmost bit is &#39;0&#39; 

                # If the leftmost bit of the dividend (or the 
                # part used in each step) is 0, the step cannot 
                # use the regular divisor; we need to use an 
                # all-0s divisor. 
                tmp = xor(&#39;0&#39;*pick, tmp) + divident[pick] 

            # increment pick to move further 
            pick += 1

        # For the last n bits, we have to carry it out 
        # normally as increased value of pick will cause 
        # Index Out of Bounds. 
        if tmp[0] == &#39;1&#39;: 
            tmp = xor(divisor, tmp) 
        else: 
            tmp = xor(&#39;0&#39;*pick, tmp) 

        checkword = tmp 
        return(checkword)
    
    # Condition data
    data = str(data)
    # Condition Key
    key = str(key)
    l_key = len(key)
   
    # Appends n-1 zeroes at end of data 
    appended_data = data + &#39;0&#39;*(l_key-1) 
    remainder = mod2div(appended_data, key) 
   
    return(remainder)

# Define String to Bits Function
def string_to_bits(str):
    &#34;&#34;&#34;
    String to Bits Converter
    
    Converts a Pythonic string to the string&#39;s
    binary representation.
    
    Parameters
    ----------
    str:        string
                The string to be converted.
    
    Returns
    -------
    data:       string
                The binary representation of the
                input string.
    &#34;&#34;&#34;
    data = (&#39;&#39;.join(format(ord(x), &#39;b&#39;) for x in str))
    return(data)
    
# Define kWh to BTU function and vice-versa
def kwh_to_btu(kWh):
    &#34;&#34;&#34;
    Killo-Watt-Hours to BTU Function:
    
    Converts kWh (killo-Watt-hours) to BTU
    (British Thermal Units).
    
    .. math:: \\text{BTU} = \\text{kWh}\\cdot3412.14
    
    Same as `btu`.
    
    Parameters
    ----------
    kWh:        float
                The number of killo-Watt-hours
    
    Returns
    -------
    BTU:        float
                The number of British Thermal Units
    &#34;&#34;&#34;
    return(kWh*3412.14)
btu = kwh_to_btu # Make Duplicate Name
def btu_to_kwh(BTU):
    &#34;&#34;&#34;
    BTU to Killo-Watt-Hours Function:
    
    Converts BTU (British Thermal Units) to
    kWh (killo-Watt-hours).
    
    .. math:: \\text{kWh} = \\frac{\\text{BTU}}{3412.14}
    
    Same as `kwh`.
    
    Parameters
    ----------
    BTU:        float
                The number of British Thermal Units
    
    Returns
    -------
    kWh:        float
                The number of killo-Watt-hours
    &#34;&#34;&#34;
    return(BTU/3412.14)
kwh = btu_to_kwh # Make Duplicate Name

# Define Per-Unit Impedance Formula
def zpu(S,VLL=None,VLN=None):
    &#34;&#34;&#34;
    Per-Unit Impedance Evaluator
    
    Evaluates the per-unit impedance value given the per-unit
    power and voltage bases.
    
    .. math:: Z_{pu}=\\frac{V_{LL}^2}{S}
    
    .. math:: Z_{pu}=\\frac{(\\sqrt{3}*V_{LN})^2}{S}
    
    Parameters
    ----------
    S:          float
                The per-unit power base.
    VLL:        float, optional
                The Line-to-Line Voltage; default=None
    VLN:        float, optional
                The Line-to-Neutral Voltage; default=None
    
    Returns
    -------
    Zbase:      float
                The per-unit impedance base.
    &#34;&#34;&#34;
    if(VLL==None and VLN==None):
        raise ValueError(&#34;ERROR: One voltage must be provided.&#34;)
    if VLL!=None:
        return(VLL**2/S)
    else:
        return((_np.sqrt(3)*VLN)**2/S)

# Define Per-Unit Current Formula
def ipu(S,VLL=None,VLN=None,V1phs=None):
    &#34;&#34;&#34;
    Per-Unit Current Evaluator
    
    Evaluates the per-unit current value given the per-unit
    power and voltage bases.
    
    .. math:: I_{pu}=\\frac{S}{\\sqrt{3}*V_{LL}}
    
    .. math:: I_{pu}=\\frac{S}{3*V_{LN}}
    
    Parameters
    ----------
    S:          float
                The per-unit power base.
    VLL:        float, optional
                The Line-to-Line Voltage; default=None
    VLN:        float, optional
                The Line-to-Neutral Voltage; default=None
    V1phs:      float, optional
                The voltage base of the single phase system.
    
    Returns
    -------
    Ibase:      float
                The per-unit current base.
    &#34;&#34;&#34;
    if(VLL==None and VLN==None):
        raise ValueError(&#34;ERROR: One voltage must be provided.&#34;)
    if VLL!=None:
        return(S/(_np.sqrt(3)*VLL))
    elif VLN != None:
        return(S/(3*VLN))
    else:
        return(S/V1phs)

# Define Per-Unit Change of Base Function
def puchgbase(quantity, puB_old, puB_new):
    &#34;&#34;&#34;
    Per-Unit Change of Base Function
    
    Performs a per-unit change of base operation for the given
    value constrained by the old base and new base.
    
    .. math:: Z_{pu-new}=Z_{pu-old}*\\frac{BASE_{OLD}}{BASE_{NEW}}
    
    Parameters
    ----------
    quantity:   complex
                Current per-unit value in old base.
    puB_old:    float
                Old per-unit base.
    puB_new:    float
                New per-unit base.
    
    Returns
    -------
    pu_new:     complex
                New per-unit value.
    &#34;&#34;&#34;
    pu_new = quantity*puB_old/puB_new
    return(pu_new)

# Define Recomposition Function
def zrecompose(z_pu,S3phs,VLL=None,VLN=None):
    &#34;&#34;&#34;
    Impedance from Per-Unit System Evaluator
    
    Function to reverse per-unit conversion and return the ohmic value
    of an impedance given its per-unit parameters of R and X (as Z).
    
    Parameters
    ----------
    z_pu:       complex
                The per-unit, complex value corresponding to the
                impedance
    S3phs:      float
                The total three-phase power rating of the system.
    VLL:        float, optional
                The Line-to-Line Voltage; default=None
    VLN:        float, optional
                The Line-to-Neutral Voltage; default=None
    
    Returns
    -------
    z:          complex
                The ohmic impedance evaluated from the per-unit base.
    &#34;&#34;&#34;
    # Evaluate the per-unit impedance
    zbase = zpu(S3phs,VLL,VLN)
    # Evaluate the impedance
    z = z_pu * zbase
    return(z)

# Define X/R Recomposition Function
def rxrecompose(x_pu,XoR,S3phs=None,VLL=None,VLN=None):
    &#34;&#34;&#34;
    Resistance/Reactance from Per-Unit System Evaluator
    
    Function to reverse per-unit conversion and return the ohmic value
    of an impedance given its per-unit parameters of X.
    
    Parameters
    ----------
    x_pu:       float
                The per-unit, complex value corresponding to the
                impedance
    XoR:        float
                The X/R ratio (reactance over impedance).
    S3phs:      float, optional
                The total three-phase power rating of the system.
                If left as None, the per-unit values will be set
                to 1, resulting in an unscaled impedance
    VLL:        float, optional
                The Line-to-Line Voltage; default=None
    VLN:        float, optional
                The Line-to-Neutral Voltage; default=None
    
    Returns
    -------
    z:          complex
                The ohmic impedance evaluated from the per-unit base.
    &#34;&#34;&#34;
    # Ensure Absolute Value
    x_pu = abs(x_pu)
    # Find R from X/R
    r_pu = x_pu/XoR
    # Compose into z
    z_pu = r_pu + 1j*x_pu
    # Recompose
    if S3phs == None:
        return(z_pu)
    else:
        z = zrecompose(z_pu,S3phs,VLL,VLN)
        return(z)

# Define Generator Internal Voltage Calculator
def geninternalv(I,Zs,Vt,Vgn=None,Zm=None,Ip=None,Ipp=None):
    &#34;&#34;&#34;
    Generator Internal Voltage Evaluator
    
    Evaluates the internal voltage for a generator given the
    generator&#39;s internal impedance and internal mutual coupling
    impedance values.
    
    Parameters
    ----------
    I:          complex
                The current on the phase of interest.
    Zs:         complex
                The internal impedance of the phase of
                interest in ohms.
    Vt:         complex
                The generator&#39;s terminal voltage.
    Vgn:        complex, optional
                The ground-to-neutral connection voltage.
    Zmp:        complex, optional
                The mutual coupling with the first additional
                phase impedance in ohms.
    Zmpp:       complex, optional
                The mutual coupling with the second additional
                phase impedance in ohms.
    Ip:         complex, optional
                The first mutual phase current in amps.
    Ipp:        complex, optional
                The second mutual phase current in amps.
    
    Returns
    -------
    Ea:         complex
                The internal voltage of the generator.
    &#34;&#34;&#34;
    # All Parameters Provided
    if Zmp == Zmpp == Ip == Ipp != None :
        if Vgn == None:
            Vgn = 0
        Ea = Zs*I + Zmp*Ip + Zmpp*Ipp + Vt + Vgn
    # Select Parameters Provided
    elif Vgn == Zm == Ip == Ipp == None :
        Ea = Zs*I + Vt
    # Invalid Parameter Set
    else:
        raise ValueError(&#34;Invalid Parameter Set&#34;)
    return(Ea)

# Define Sequence Component Conversion Function
def abc_to_seq(Mabc,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Phase-System to Sequence-System Conversion
    
    Converts phase-based values to sequence
    components.
    
    .. math:: M_{\\text{012}}=A_{\\text{012}}\\cdot M_{\\text{ABC}}
    
    Same as phs_to_seq.
    
    Parameters
    ----------
    Mabc:       list of complex
                Phase-based values to be converted.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    
    Returns
    -------
    M012:       numpy.ndarray
                Sequence-based values in order of 0-1-2
    
    See Also
    --------
    seq_to_abc: Sequence to Phase Conversion
    sequencez:  Phase Impedance to Sequence Converter
    &#34;&#34;&#34;
    # Condition Reference:
    reference = reference.upper()
    if reference == &#39;A&#39;:
        M = Aabc
    elif reference == &#39;B&#39;:
        M = _np.roll(Aabc, 1, 0)
    elif reference == &#39;C&#39;:
        M = _np.roll(Aabc, 2, 0)
    else:
        raise ValueError(&#34;Invalid Phase Reference.&#34;)
    return(M.dot(Mabc))
# Define Second Name for abc_to_seq
phs_to_seq = abc_to_seq

# Define Phase Component Conversion Function
def seq_to_abc(M012,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Sequence-System to Phase-System Conversion
    
    Converts sequence-based values to phase
    components.
    
    .. math:: M_{\\text{ABC}}=A_{\\text{012}}^{-1}\\cdot M_{\\text{012}}
    
    Same as seq_to_phs.
    
    Parameters
    ----------
    M012:       list of complex
                Sequence-based values to convert.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    
    Returns
    -------
    Mabc:       numpy.ndarray
                Phase-based values in order of A-B-C
    
    See Also
    --------
    abc_to_seq: Phase to Sequence Conversion
    sequencez:  Phase Impedance to Sequence Converter
    &#34;&#34;&#34;
    # Compute Dot Product
    M = A012.dot(M012)
    # Condition Reference:
    reference = reference.upper()
    if reference == &#39;A&#39;:
        pass
    elif reference == &#39;B&#39;:
        M = _np.roll(M, 1, 0)
    elif reference == &#39;C&#39;:
        M = _np.roll(M, 2, 0)
    else:
        raise ValueError(&#34;Invalid Phase Reference.&#34;)
    return(M)
# Define Second Name for seq_to_abc
seq_to_phs = seq_to_abc

# Define Sequence Impedance Calculator
def sequencez(Zabc,reference=&#39;A&#39;,resolve=False,diag=False,round=3):
    &#34;&#34;&#34;
    Sequence Impedance Calculator
    
    Accepts the phase (ABC-domain) impedances for a
    system and calculates the sequence (012-domain)
    impedances for the same system. If the argument
    `resolve` is set to true, the function will
    combine terms into the set of [Z0, Z1, Z2].
    
    When resolve is False:
    
    .. math:: Z_{\\text{012-M}}=A_{\\text{012}}^{-1}Z_{\\text{ABC}}A_{\\text{012}}
    
    When resolve is True:
    
    .. math:: Z_{\\text{012}}=A_{\\text{012}}Z_{\\text{ABC}}A_{\\text{012}}^{-1}
    
    Parameters
    ----------
    Zabc:       numpy.ndarray of complex
                2-D (3x3) matrix of complex values
                representing the phasor impedances
                in the ABC-domain.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    resolve:    bool, optional
                Control argument to force the function to
                evaluate the individual sequence impedances
                [Z0, Z1, Z2], default=False
    diag:       bool, optional
                Control argument to force the function to
                reduce the matrix to its diagonal terms.
    round:      int, optional
                Integer denoting number of decimal places
                resulting matrix should be rounded to.
                default=3
    
    Returns
    -------
    Z012:       numpy.ndarray of complex
                2-D (3x3) matrix of complex values
                representing the sequence impedances
                in the 012-domain
    
    See Also
    --------
    seq_to_abc: Sequence to Phase Conversion
    abc_to_seq: Phase to Sequence Conversion
    &#34;&#34;&#34;
    # Condition Reference
    reference = reference.upper()
    rollrate = {&#39;A&#39;:0,&#39;B&#39;:1,&#39;C&#39;:2}
    # Test Validity
    if reference not in rollrate:
        raise ValueError(&#34;Invalad Phase Reference&#34;)
    # Determine Roll Factor
    roll = rollrate[ reference ]
    # Evaluate Matricies
    M012 = _np.roll(A012,roll,0)
    Minv = _np.linalg.inv(M012)
    # Compute Sequence Impedances
    if resolve:
        Z012 = M012.dot( Zabc.dot(Minv) )
    else:
        Z012 = Minv.dot( Zabc.dot(M012) )
    # Reduce to Diagonal Terms if Needed
    if diag:
        Z012 = [Z012[0][0],Z012[1][1],Z012[2][2]]
    return(_np.around(Z012,round))

# FFT Coefficient Calculator Function
def funcfft(func, minfreq=60, maxmult=15, complex=False):
    &#34;&#34;&#34;
    Function FFT Evaluator
    
    Given the callable function handle for a periodic function,
    evaluates the harmonic components of the function.
    
    Parameters
    ----------
    func:       function
                Callable function from which to evaluate values.
    minfreq:    float, optional
                Minimum frequency (in Hz) at which to evaluate FFT.
                default=60
    maxmult:    int, optional
                Maximum harmonic (multiple of minfreq) which to
                evaluate. default=15
    complex:    bool, optional
                Control argument to force returned values into
                complex format.
    
    Returns
    -------
    DC:         float
                The DC offset of the FFT result.
    A:          list of float
                The real components from the FFT.
    B:          list of float
                The imaginary components from the FFT.
    &#34;&#34;&#34;
    # Apply Nyquist scaling
    NN = 2 * maxmult + 2
    # Determine Time from Fundamental Frequency
    T = 1/minfreq
    # Generate time range to apply for FFT
    t, dt = _np.linspace(0, T, NN, endpoint=False, retstep=True)
    # Evaluate FFT
    y = _np.fft.rfft(func(t)) / t.size
    # Return Complex Values
    if complex:
       return(y)
    # Split out useful values
    else:
       y *= 2
       return(y[0].real, y[1:-1].real, -y[1:-1].imag)

def sampfft(data,dt,minfreq=60.0,complex=False):
    &#34;&#34;&#34;
    Sampled Dataset FFT Evaluator
    
    Given a data array and the delta-t for the data array, evaluates
    the harmonic composition of the data.
    
    Parameters
    ----------
    data:       numpy.ndarray
                Numpy data array containing 1-D values.
    dt:         float
                Time-difference (delta-t) between data samples.
    minfreq:    float, optional
                Minimum frequency (in Hz) at which to evaluate FFT.
                default=60
    complex:    bool, optional
                Control argument to force returned values into
                complex format.
    
    Returns
    -------
    DC:         float
                The DC offset of the FFT result.
    A:          list of float
                The real components from the FFT.
    B:          list of float
                The imaginary components from the FFT.
    &#34;&#34;&#34;
    # Calculate Terms
    FR = 1/(dt*len(data))
    NN = 1//(dt*minfreq)
    # Test for Invalid System
    if FR &gt; minfreq:
        raise ValueError(&#34;Too few data samples to evaluate FFT at specified minimum frequency.&#34;)
    elif FR == minfreq:
        # Evaluate FFT
        y = _np.fft.rfft(data) / len(data)
    else:
        # Slice data array to appropriate fundamental frequency
        cut_data = data[:int(NN)]
        # Evaluate FFT
        y = _np.fft.rfft(cut_data) / len(cut_data)
    # Return Complex Values
    if complex:
       return(y)
    # Split out useful values
    else:
       y *= 2
       return(y[0].real, y[1:-1].real, -y[1:-1].imag)

# Define FFT Plotting Function
def fftplot(dc, real, imag=None, title=&#34;Fourier Coefficients&#34;):
    &#34;&#34;&#34;
    FFT System Plotter
    
    Plotting function for FFT (harmonic) values,
    plots the DC, Real, and Imaginary components.
    
    Parameters
    ----------
    dc:         float
                The DC offset term
    real:       list of float
                Real terms of FFT (cosine terms)
    imag:       list of float, optional
                Imaginary terms of FFT (sine terms)
    title:      str, optional
                String appended to plot title,
                default=&#34;Fourier Coefficients&#34;
    &#34;&#34;&#34;
    # Define Range values for plots
    rng = range(1,len(real)+1,1)
    xtic = range(0,len(real)+1,1)
    # Set up Arguments
    a0x = [0,0]
    a0y = [0,dc/2]
    # Plot
    _plt.title(title)
    _plt.plot(a0x,a0y,&#39;g&#39;,label=&#34;DC-Term&#34;)
    _plt.stem(rng,real,&#39;r&#39;,&#39;ro&#39;,label=&#34;Real-Terms&#34;,use_line_collection=True)
    try:
        imag != None
    except ValueError:
        _plt.stem(rng,imag,&#39;b&#39;,&#39;bo&#39;,label=&#34;Imaginary-Terms&#34;,use_line_collection=True)
    _plt.xlabel(&#34;Harmonics (Multiple of Fundamental)&#34;)
    _plt.ylabel(&#34;Harmonic Magnitude&#34;)
    _plt.axhline(0.0,color=&#39;k&#39;)
    _plt.legend()
    if(len(xtic) &lt; 50):
        _plt.xticks(xtic)
    _plt.show()

# Define FFT Composition Plotting Function
def fftsumplot(dc,real,imag=None,freq=60,xrange=None,npts=1000,
               plotall=False,title=&#34;Fourier Series Summation&#34;):
    &#34;&#34;&#34;
    FFT Summation Plotter
    
    Function to generate the plot of the sumed FFT results.
    
    Parameters
    ----------
    dc:         float
                The DC offset term
    real:       list of float
                Real terms of FFT (cosine terms)
    imag:       list of float
                Imaginary terms of FFT (sine terms)
    freq:       float, optional
                Fundamental (minimum nonzero) frequency in Hz,
                default=60
    xrange:     list of float, optional
                List of two floats containing the minimum
                time and the maximum time.
    npts:       int, optional
                Number of time step points, default=1000
    title:      str, optional
                String appended to plot title,
                default=&#34;Fourier Series Summation&#34;
    &#34;&#34;&#34;
    # Determine the number (N) of terms
    N = len(real)
    # Determine the system period (T)
    T = 1/freq
    # Generate Domain Array
    if xrange == None:
        x = _np.linspace(0,T,npts)
    else:
        x = _np.linspace(xrange[0],xrange[1],npts)
    # Initialize output with DC term
    yout = _np.ones(len(x))*dc
    # Plot each iteration of the Fourier Series
    for k in range(1,N):
        if plotall:
            _plt.plot(x,yout)
        yout += real[k-1]*_np.cos(k*2*_np.pi*x/T)
        if imag != None:
            yout += imag[k-1]*_np.sin(k*2*_np.pi*x/T)
    _plt.plot(x,yout)
    _plt.title(title)
    _plt.xlabel(&#34;Time (seconds)&#34;)
    _plt.ylabel(&#34;Magnitude&#34;)
    _plt.show()

# Define harmonic system generation function
def harmonics(real,imag=None,dc=0,freq=60,domain=None):
    &#34;&#34;&#34;
    Harmonic Function Generator
    
    Generate a function or dataset for a harmonic system
    given the real (cosine), imaginary (sine), and DC
    components of the system.
    
    Parameters
    ----------
    real:       list of float
                The real (cosine) component coefficients
                for the harmonic system.
    imag:       list of float, optional
                The imaginary (sine) component coefficients
                for the harmonic system.
    dc:         float, optional
                The DC offset for the harmonic system,
                default=0
    freq:       float, optional
                The fundamental frequency of the system in
                Hz, default=60
    domain:     list of float, optional
                Domain of time samples at which to calculate
                the harmonic system, must be array-like, will
                cause function to return numpy array instead
                of function object.
    
    Returns
    -------
    system:     function
                Function object handle which can be used to
                call the function to evaluate the harmonic
                system at specified times.
    &#34;&#34;&#34;
    # Validate Inputs
    if not isinstance(real,(list,_np.ndarray)):
        raise ValueError(&#34;Argument *real* must be array-like.&#34;)
    if imag != None and not isinstance(imag,(list,_np.ndarray)):
        raise ValueError(&#34;Argument *imag* must be array-like.&#34;)
    # Calculate Omega
    w = 2*_np.pi*freq
    def _harmonic_(t):
        out = dc
        for k in range(len(real)):
            # Evaluate Current Coefficient
            A = real[k]
            if imag != None:
                B = imag[k]
            else:
                B = 0
            m = k + 1
            # Calculate Output
            out += A*_np.cos(m*w*t) + B*_np.sin(m*w*t)
        # Return Value
        return(out)
    if domain is None:
        system = _harmonic_
    else:
        system = _harmonic_(domain)
    return(system)

# Define Single Phase Motor Startup Capacitor Formula
def motorstartcap(V,I,freq=60):
    &#34;&#34;&#34;
    Single Phase Motor Starting Capacitor Function
    
    Function to evaluate a reccomended value for the
    startup capacitor associated with a single phase
    motor.
    
    Parameters
    ----------
    V:          float
                Magnitude of motor terminal voltage in volts.
    I:          float
                Magnitude of motor no-load current in amps.
    freq:       float, optional
                Motor/System frequency, default=60.
                
    Returns
    -------
    C:          float
                Suggested capacitance in Farads.
    &#34;&#34;&#34;
    # Condition Inputs
    I = abs(I)
    V = abs(V)
    # Calculate Capacitance
    C = I / (2*_np.pi*freq*V)
    return(C)

# Define Power Factor Correction Function
def pfcorrection(S,PFold,PFnew,VLL=None,VLN=None,V=None,freq=60):
    &#34;&#34;&#34;
    Power Factor Correction Function
    
    Function to evaluate the additional reactive power and
    capacitance required to achieve the desired power factor
    given the old power factor and new power factor.
    
    Parameters
    ----------
    S:          float
                Apparent power consumed by the load.
    PFold:      float
                The current (old) power factor, should be a decimal
                value.
    PFnew:      float
                The desired (new) power factor, should be a decimal
                value.
    VLL:        float, optional
                The Line-to-Line Voltage; default=None
    VLN:        float, optional
                The Line-to-Neutral Voltage; default=None
    V:          float, optional
                Voltage across the capacitor, ignores line-to-line
                or line-to-neutral constraints. default=None
    freq:       float, optional
                System frequency, default=60
    
    Returns
    -------
    C:          float
                Required capacitance in Farads.
    Qc:         float
                Difference of reactive power, (Qc = Qnew - Qold)
    &#34;&#34;&#34;
    # Condition Inputs
    S = abs(S)
    # Calculate Initial Terms
    Pold = S*PFold
    Qold = _np.sqrt(S**2 - Pold**2)
    # Evaluate Reactive Power Requirements
    Scorrected = Pold/PFnew
    Qcorrected = _np.sqrt(Scorrected**2 - Pold**2)
    Qc = Qold - Qcorrected
    # Evaluate Capacitance Based on Voltage Input
    if VLL == VLN == V == None:
        raise ValueError(&#34;One voltage must be specified.&#34;)
    elif VLN != None:
        C = Qc / (2*_np.pi*freq*3*VLN**2)
    else:
        if VLL != None:
            V = VLL
        C = Qc / (2*_np.pi*freq*V**2)
    # Return Value
    return(C,Qc)

# Define Apparent Power / Voltage / Current Relation Function
def acpiv(S=None,I=None,VLL=None,VLN=None,V=None,PF=None):
    &#34;&#34;&#34;
    AC Power-Voltage-Current Relation Function
    
    Relationship function to return apparent power, voltage, or
    current in one of various forms.
    
    Parameters
    ----------
    S:          complex, optional
                Apparent power, may be single or three-phase,
                specified in volt-amps (VAs)
    I:          complex, optional
                Phase current in amps
    VLL:        complex, optional
                Line-to-Line voltage in volts
    VLN:        complex, optional
                Line-to-Neutral voltage in volts
    V:          complex, optional
                Single-phase voltage in volts
    
    Returns
    -------
    S:          complex
                Apparent power, returned only if one voltage
                and current is specified
    I:          complex
                Phase current, returned only if one voltage
                and apparent power is specified
    VLL:        complex
                Line-to-Line voltage, returned only if current
                and apparent power specified, returned as set
                with other voltages in form: (VLL, VLN, V)
    VLN:        complex
                Line-to-Neutral voltage, returned only if
                current and apparent power specified, returned
                as set with other voltages in form: (VLL, VLN, V)
    V:          complex
                Single-phase voltage, returned only if current
                and apparent power specified, returned as set
                with other voltages in form: (VLL, VLN, V)
    PF:         float, optional
                Supporting argument to convert floating-point
                apparent power to complex representation.
    &#34;&#34;&#34;
    # Validate Inputs
    if S == I == None:
        raise ValueError(&#34;To few arguments.&#34;)
    # Convert Apparent Power to Complex
    if PF != None:
        S = S*PF + 1j*_np.sqrt(S**2 - (S*PF)**2)
    # Solve Single-Phase
    if V != None:
        if S == None:   # Solve for Apparent Power
            S = V * _np.conj( I )
            return(S)
        else:           # Solve for Current
            I = _np.conj( S/V )
            return(I)
    # Solve Line-to-Line
    elif VLL != None:
        if S == None:   # Solve for Apparent Power
            S = _np.sqrt(3) * VLL * _np.conj( I )
            return(S)
        else:           # Solve for Current
            I = _np.conj( S/(_np.sqrt(3) * VLL) )
            return(I)
    # Solve Line-to-Neutral
    elif VLN != None:
        if S == None:   # Solve for Apparent Power
            S = 3 * VLN * _np.conj( I )
            return(S)
        else:           # Solve for Current
            I = _np.conj( S/(3*VLN) )
            return(I)
    # Solve for Voltages
    else:
        V = S/_np.conj( I )
        VLL = S/(_np.sqrt(3) * _np.conj( I ))
        VLN = S/(3 * _np.conj( I ))
        return(VLL,VLN,V)

# Define Primary Ratio Function
def primary(val, Np, Ns=1, invert=False):
    &#34;&#34;&#34;
    Transformer Primary Evaluator
    
    Returns a current or voltage value reflected across
    a transformer with a specified turns ratio Np/Ns.
    Converts to the primary side.
    
    Parameters
    ----------
    val:        complex
                Value to be reflected across transformer.
    Np:         float
                Number of turns on primary side.
    Ns:         float, optional
                Number of turns on secondary side.
    invert:     bool, optional
                Control argument to invert the turns ratio,
                used when reflecting current across a
                voltage transformer, or voltage across a
                current transformer.
    
    Returns
    -------
    reflection: complex
                The reflected value referred to the primary
                side according to Np and Ns.
    &#34;&#34;&#34;
    if invert:
        return( val * Ns/Np )
    return( val * Np/Ns )

# Define Secondary Ratio Function
def secondary(val, Np, Ns=1,invert=False):
    &#34;&#34;&#34;
    Transformer Secondary Evaluator
    
    Returns a current or voltage value reflected across
    a transformer with a specified turns ratio Np/Ns.
    Converts to the secondary side.
    
    Parameters
    ----------
    val:        complex
                Value to be reflected across transformer.
    Np:         float
                Number of turns on primary side.
    Ns:         float, optional
                Number of turns on secondary side.
    invert:     bool, optional
                Control argument to invert the turns ratio,
                used when reflecting current across a
                voltage transformer, or voltage across a
                current transformer.
    
    Returns
    -------
    reflection: complex
                The reflected value referred to the secondary
                side according to Np and Ns.
    &#34;&#34;&#34;
    if invert:
        return( val * Np/Ns )
    return( val * Ns/Np )

# Define Natural Frequency/Resonant Frequency Calculator
def natfreq(C,L,Hz=True):
    &#34;&#34;&#34;
    Natural Frequency Evaluator
    
    Evaluates the natural frequency (resonant frequency)
    of a circuit given the circuit&#39;s C and L values. Defaults
    to returning values in Hz, but may also return in rad/sec.
    
    .. math:: freq=\\frac{1}{\\sqrt{L*C}*(2*\\pi)}
    
    Parameters
    ----------
    C:          float
                Capacitance Value in Farads.
    L:          float
                Inductance in Henries.
    Hz:         bool, optional
                Control argument to set return value in either
                Hz or rad/sec; default=True.
    
    Returns
    -------
    freq:       float
                Natural (Resonant) frequency, will be in Hz if
                argument *Hz* is set True (default), or rad/sec
                if argument is set False.
    &#34;&#34;&#34;
    # Evaluate Natural Frequency in rad/sec
    freq = 1/_np.sqrt(L*C)
    # Convert to Hz as requested
    if Hz:
        freq = freq / (2*_np.pi)
    return(freq)

# Define Voltage/Current Unbalance Equation
def unbalance(A,B,C,all=False):
    &#34;&#34;&#34;
    Voltage/Current Unbalance Function
    
    Performs a voltage/current unbalance calculation
    to determine the maximum current/voltage
    unbalance. Returns result as a decimal percentage.
    
    Parameters
    ----------
    A:          float
                Phase-A value
    B:          float
                Phase-B value
    C:          float
                Phase-C value
    all:        bool, optional
                Control argument to require function
                to return all voltage/current unbalances.
    
    Returns
    -------
    unbalance:  float
                The unbalance as a percentage of the
                average. (i.e. 80% = 0.8)
    &#34;&#34;&#34;
    # Condition Inputs
    A = abs(A)
    B = abs(B)
    C = abs(C)
    # Gather Average
    avg = (A + B + C)/3
    # Determine Variance
    dA = abs(A-avg)
    dB = abs(B-avg)
    dC = abs(C-avg)
    # Gather Maximum Variation
    mx = max(dA,dB,dC)
    # Calculate Maximum Variation
    unbalance = mx/avg
    # Return Results
    if all:
        return(dA/avg,dB/avg,dC/avg)
    else:
        return(unbalance)

# Define Cosine Filter Function
def cosfilt(arr,Srate,domain=False):
    &#34;&#34;&#34;
    Cosine Filter Function
    
    Cosine Filter function for filtering a dataset
    representing a sinusoidal function with or without
    harmonics to evaluate the fundamental value.
    
    Parameters
    ----------
    arr:        numpy.ndarray
                The input data array.
    Srate:      int
                Sampling rate for dataset, specified in
                number of values per fundamental cycle.
    domain:     bool, optional
                Control argument to force return of
                x-axis array for the filtered data.
    
    Returns
    -------
    cosf:       numpy.ndarray
                Cosine-filtered data
    xarray:     numpy.ndarray
                X-axis array for the filtered data.
    &#34;&#34;&#34;
    # Evaluate index set
    ind = _np.arange(Srate-1, len(arr)-1)
    # Define Cosine Coefficient Function
    def cos(k,Srate):
        return(_np.cos(2*_np.pi*k/Srate))
    # Calculate Constant
    const = 2/Srate
    # Iteratively Calculate
    cosf = 0
    for k in range(0,Srate-1):
        slc = (ind-(Srate-1))+k
        cosf += cos(k,Srate) * arr[slc]
    # Scale
    cosf = const * cosf
    # Return Cosine-Filtered Array
    if domain:
        xarray = _np.linspace(Srate+Srate/4-1,len(arr)-1,len(cosf))
        xarray = xarray / Srate
        return(cosf,xarray)
    return(cosf)

# Define Sine Filter Function
def sinfilt(arr,Srate,domain=False):
    &#34;&#34;&#34;
    Sine Filter Function
    
    Sine Filter function for filtering a dataset
    representing a sinusoidal function with or without
    harmonics to evaluate the fundamental value.
    
    Parameters
    ----------
    arr:        numpy.ndarray
                The input data array.
    Srate:      int
                Sampling rate for dataset, specified in
                number of values per fundamental cycle.
    domain:     bool, optional
                Control argument to force return of
                x-axis array for the filtered data.
    
    Returns
    -------
    sinf:       numpy.ndarray
                Sine-filtered data
    xarray:     numpy.ndarray
                X-axis array for the filtered data.
    &#34;&#34;&#34;
    # Evaluate index set
    ind = _np.arange(Srate-1, len(arr)-1)
    # Define Cosine Coefficient Function
    def sin(k,Srate):
        return(_np.sin(2*_np.pi*k/Srate))
    # Calculate Constant
    const = 2/Srate
    # Iteratively Calculate
    sinf = 0
    for k in range(0,Srate-1):
        slc = (ind-(Srate-1))+k
        sinf += sin(k,Srate) * arr[slc]
    # Scale
    sinf = const * sinf
    # Return Cosine-Filtered Array
    if domain:
        xarray = _np.linspace(Srate+Srate/4-1,len(arr)-1,len(sinf))
        xarray = xarray / Srate
        return(sinf,xarray)
    return(sinf)


# Define Characteristic Impedance Calculator
def characterz(R,G,L,C,freq=60):
    &#34;&#34;&#34;
    Characteristic Impedance Calculator
    
    Function to evaluate the characteristic 
    impedance of a system with specefied
    line parameters as defined. System uses
    the standard characteristic impedance
    equation :eq:`Zc`.
    
    .. math:: Z_c = \\sqrt{\\frac{R+j\\omega L}{G+j\\omega C}}
       :label: Zc
    
    Parameters
    ----------
    R:          float
                Resistance in ohms.
    G:          float
                Conductance in mhos (siemens).
    L:          float
                Inductance in Henries.
    C:          float
                Capacitance in Farads.
    freq:       float, optional
                System frequency in Hz, default=60
    
    Returns
    -------
    Zc:         complex
                Charcteristic Impedance of specified line.
    &#34;&#34;&#34;
    # Evaluate omega
    w = 2*_np.pi*freq
    # Evaluate Zc
    Zc = _np.sqrt((R+1j*w*L)/(G+1j*w*C))
    return(Zc)

# Define Simple Transformer Phase Shift Function
def xfmphs(style=&#34;DY&#34;,shift=30):
    &#34;&#34;&#34;
    Simple Transformer Phase-Shift Calculator
    
    Use with transformer orientation to evaluate
    the phase-shift across a transformer. For
    example, find the phase shift for a Delta-Wye
    transformer as seen from the delta side.
    
    Parameters
    ----------
    style:      {&#39;DY&#39;,&#39;YD&#39;,&#39;DD&#39;,&#39;YY&#39;}, optional
                String that denotes the transformer
                orientation. default=&#39;DY&#39;
    shift:      float, optional
                Transformer angle shift, default=30
    
    Returns
    -------
    phase:      complex
                Phasor including the phase shift and
                positive or negative characteristic.
    
    Examples
    --------
    &gt;&gt;&gt; import electricpy as ep
    &gt;&gt;&gt; # Find shift of Delta-Wye Transformer w/ 30° shift
    &gt;&gt;&gt; shift = ep.xfmphs(style=&#34;DY&#34;,shift=30)
    &gt;&gt;&gt; ep.cprint(shift)
    1.0 ∠ 30.0°
    &#34;&#34;&#34;
    # Define Direction Dictionary
    orientation = {
        &#34;DY&#34; : 1,
        &#34;YD&#34; : -1,
        &#34;DD&#34; : 0,
        &#34;YY&#34; : 0,
    }
    # Find Direction
    v = orientation[style.upper()]
    # Calculate Shift
    phase = _np.exp(1j*_np.radians(v*abs(shift)))
    # Return
    return(phase)

# Define Simple Radians to Hertz Converter
def rad_to_hz( radians ):
    &#34;&#34;&#34;
    Simple Radians to Hertz Converter
    
    Accepts a frequency in radians/sec and calculates
    the hertzian frequency (in Hz).
    
    .. math:: f_{\\text{Hz}} = \\frac{f_{\\text{rad/sec}}}{2\\cdot\\pi}
    
    Same as `hertz`.
    
    Paramters
    ---------
    radians:    float
                The frequency (represented in radians/sec)
    
    Returns
    -------
    hertz:      float
                The frequency (represented in Hertz)
    &#34;&#34;&#34;
    return( radians / (2*_np.pi) ) # Evaluate and Return
hertz = rad_to_hz # Make Duplicate Name
# Define Simple Hertz to Radians Converter
def hz_to_rad( hertz ):
    &#34;&#34;&#34;
    Simple Hertz to Radians Converter
    
    Accepts a frequency in Hertz and calculates
    the frequency in radians/sec.
    
    .. math:: f_{\\text{rad/sec}} = f_{\\text{Hz}}\\cdot2\\cdot\\pi
    
    Same as `radsec`.
    
    Paramters
    ---------
    hertz:      float
                The frequency (represented in Hertz)
    
    Returns
    -------
    radians:    float
                The frequency (represented in radians/sec)
    &#34;&#34;&#34;
    return( hertz * (2*_np.pi) ) # Evaluate and Return
radsec = hz_to_rad # Make Duplicate Name

# Define Induction Machine Thevenin Voltage Calculator
def indmachvth(Vas,Rs,Lm,Lls=0,Ls=None,freq=60,calcX=True):
    &#34;&#34;&#34;
    Induction Machine Thevenin Voltage Calculator
    
    Function to calculate the Thevenin equivalent voltage of an
    induction machine given a specific set of parameters.
    
    .. math:: V_{th}=\\frac{j\\omega L_m}{R_s+j\\omega(L_{ls}+L_m)}V_{as}
    
    where:
    
    .. math:: \\omega = \\omega_{es} = 2\\pi\\cdot f_{\\text{electric}}
    
    Parameters
    ----------
    Vas:        complex
                Terminal Stator Voltage in Volts
    Rs:         float
                Stator resistance in ohms
    Lm:         float
                Magnetizing inductance in Henrys
    Lls:        float, optional
                Stator leakage inductance in Henrys, default=0
    Ls:         float, optional
                Stator inductance in Henrys
    freq:       float, optional
                System (electrical) frequency in Hz, default=60
    calcX:      bool, optional
                Control argument to force system to calculate
                system reactances with system frequency, or to
                treat them as previously-calculated reactances.
                default=True
    
    Returns
    -------
    Vth:        complex
                Thevenin-Equivalent voltage (in volts) of induction
                machine described.
    
    See Also
    --------
    indmachzth:         Induction Machine Thevenin Impedance Calculator
    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
    indmachpkslip:      Induction Machine Peak Slip Calculator
    indmachpktorq:      Induction Machine Peak Torque Calculator
    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
    indmachstarttorq:   Induction Machine Starting Torque Calculator
    &#34;&#34;&#34;
    # Condition Inputs
    if Ls != None: # Use Ls instead of Lls
        Lls = Ls - Lm
    if calcX: # Convert Inductances to Reactances
        w = 2*_np.pi*freq
        Lm *= w
        Lls *= w
    # Calculate Thevenin Voltage, Return
    Vth = 1j*Lm / (Rs + 1j*(Lls+Lm)) * Vas
    return(Vth)

# Define Induction Machine Thevenin Impedance Calculator
def indmachzth(Rs,Lm,Lls=0,Llr=0,Ls=None,Lr=None,freq=60,calcX=True):
    &#34;&#34;&#34;
    Induction Machine Thevenin Impedance Calculator
    
    Function to calculate the Thevenin equivalent impedance of an
    induction machine given a specific set of parameters.
    
    .. math::
       Z_{th} = \\frac{(R_s+j\\omega L_{ls})j\\omega L_m}
       {R_s+j\\omega(L_{ls}+L_m)}+j\\omega L_{lr}
    
    where:
    
    .. math:: \\omega = \\omega_{es} = 2\\pi\\cdot f_{\\text{electric}}
    
    Parameters
    ----------
    Rs:         float
                Stator resistance in ohms
    Lm:         float
                Magnetizing inductance in Henrys
    Lls:        float, optional
                Stator leakage inductance in Henrys, default=0
    Llr:        float, optional
                Rotor leakage inductance in Henrys, default=0
    Ls:         float, optional
                Stator inductance in Henrys
    Lr:         float, optional
                Rotor inductance in Henrys
    freq:       float, optional
                System (electrical) frequency in Hz, default=60
    calcX:      bool, optional
                Control argument to force system to calculate
                system reactances with system frequency, or to
                treat them as previously-calculated reactances.
                default=True
    
    Returns
    -------
    Zth:        complex
                Thevenin-Equivalent impedance (in ohms) of induction
                machine described.
    
    See Also
    --------
    indmachvth:         Induction Machine Thevenin Voltage Calculator
    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
    indmachpkslip:      Induction Machine Peak Slip Calculator
    indmachpktorq:      Induction Machine Peak Torque Calculator
    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
    indmachstarttorq:   Induction Machine Starting Torque Calculator
    &#34;&#34;&#34;
    # Condition Inputs
    if Ls != None: # Use Ls instead of Lls
        Lls = Ls - Lm
    if Lr != None: # Use Lr instead of Llr
        Llr = Lr - Lm
    if calcX: # Convert Inductances to Reactances
        w = 2*_np.pi*freq
        Lm *= w
        Lls *= w
        Llr *= w
    # Calculate Thevenin Impedance
    Zth = (Rs+1j*Lls)*(1j*Lm) / (Rs+1j*(Lls+Lm)) + 1j*Llr
    return(Zth)
    
# Define Induction Machine Mechancal Power Calculator
def indmachpem(slip,Rr,Vth=None,Zth=None,Vas=0,Rs=0,Lm=0,Lls=0,
               Llr=0,Ls=None,Lr=None,freq=60,calcX=True):
    &#34;&#34;&#34;
    Mechanical Power Calculator for Induction Machines
    
    Function to calculate the mechanical power using the thevenin
    equivalent circuit terms.
    
    .. math:: 
       P_{em}=\\frac{|V_{th_{\\text{stator}}}|^2\\cdot\\frac{R_r}{slip}}
       {\\left[\\left(\\frac{R_r}{slip}+R_{th_{\\text{stator}}}\\right)^2
       +X_{th_{\\text{stator}}}^2\\right]\\cdot\\omega_{es}}\\cdot(1-slip)
    
    Parameters
    ----------
    slip:       float
                The mechanical/electrical slip factor of the
                induction machine.
    Rr:         float
                Rotor resistance in ohms
    Vth:        complex, optional
                Thevenin-equivalent stator voltage of the
                induction machine, may be calculated internally
                if given stator voltage and machine parameters.
    Zth:        complex, optional
                Thevenin-equivalent inductance (in ohms) of the
                induction machine, may be calculated internally
                if given machine parameters.
    Vas:        complex, optional
                Terminal Stator Voltage in Volts
    Rs:         float, optional
                Stator resistance in ohms
    Lm:         float, optional
                Magnetizing inductance in Henrys
    Lls:        float, optional
                Stator leakage inductance in Henrys, default=0
    Llr:        float, optional
                Rotor leakage inductance in Henrys, default=0
    Ls:         float, optional
                Stator inductance in Henrys
    Lr:         float, optional
                Rotor inductance in Henrys
    freq:       float, optional
                System (electrical) frequency in Hz, default=60
    calcX:      bool, optional
                Control argument to force system to calculate
                system reactances with system frequency, or to
                treat them as previously-calculated reactances.
                default=True
    
    Returns
    -------
    Pem:        float
                Power (in watts) that is produced or consumed
                by the mechanical portion of the induction machine.
    
    See Also
    --------
    indmachvth:         Induction Machine Thevenin Voltage Calculator
    indmachzth:         Induction Machine Thevenin Impedance Calculator
    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
    indmachpkslip:      Induction Machine Peak Slip Calculator
    indmachpktorq:      Induction Machine Peak Torque Calculator
    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
    indmachstarttorq:   Induction Machine Starting Torque Calculator
    &#34;&#34;&#34;
    # Condition Inputs
    w = 2*_np.pi*freq
    if Ls != None: # Use Ls instead of Lls
        Lls = Ls - Lm
    if Lr != None: # Use Lr instead of Llr
        Llr = Lr - Lm
    if calcX: # Convert Inductances to Reactances
        Lm *= w
        Lls *= w
        Llr *= w
    # Test for Valid Input Set
    if Vth == None:
        if not all((Vas,Rs,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Vth
        Vth = indmachvth(Vas,Rs,Lm,Lls,Ls,freq,calcX)
    if Zth == None:
        if not all((Rs,Llr,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Zth
        Zth = indmachzth(Rs,Lm,Lls,Llr,Ls,Lr,freq,calcX)
    # Use Terms to Calculate Pem
    Rth = Zth.real
    Xth = Zth.imag
    Pem = (abs(Vth)**2*Rr/slip)/(((Rr/slip+Rth)**2+Xth**2)*w) * (1-slip)
    return(Pem)

# Define Induction Machine Torque Calculator
def indmachtem(slip,Rr,p=0,Vth=None,Zth=None,Vas=0,Rs=0,Lm=0,Lls=0,
               Llr=0,Ls=None,Lr=None,wsyn=None,freq=60,calcX=True):
    &#34;&#34;&#34;
    Induction Machine Torque Calculator
    
    Calculate the torque generated or consumed by an induction
    machine given the machine parameters of Vth and Zth by use
    of the equation below.
    
    .. math:: 
       T_{em}=\\frac{3|V_{th_{\\text{stator}}}|^2}
       {\\left[\\left(\\frac{R_r}{slip}+R_{th_{\\text{stator}}}\\right)^2
       +X_{th_{\\text{stator}}}\\right]}\\frac{R_r}{slip*\\omega_{sync}}
    
    where:
    
    .. math:: 
       \\omega_{sync}=\\frac{\\omega_{es}}{\\left(\\frac{poles}{2}\\right)}
    
    Parameters
    ----------
    slip:       float
                The mechanical/electrical slip factor of the
                induction machine.
    Rr:         float
                Rotor resistance in ohms
    p:          int, optional
                Number of poles in the induction machine
    Vth:        complex, optional
                Thevenin-equivalent stator voltage of the
                induction machine, may be calculated internally
                if given stator voltage and machine parameters.
    Zth:        complex, optional
                Thevenin-equivalent inductance (in ohms) of the
                induction machine, may be calculated internally
                if given machine parameters.
    Vas:        complex, optional
                Terminal Stator Voltage in Volts
    Rs:         float, optional
                Stator resistance in ohms
    Lm:         float, optional
                Magnetizing inductance in Henrys
    Lls:        float, optional
                Stator leakage inductance in Henrys, default=0
    Llr:        float, optional
                Rotor leakage inductance in Henrys, default=0
    Ls:         float, optional
                Stator inductance in Henrys
    Lr:         float, optional
                Rotor inductance in Henrys
    wsyn:       float, optional
                Synchronous speed in rad/sec, may be specified
                directly as a replacement of p (number of poles).
    freq:       float, optional
                System (electrical) frequency in Hz, default=60
    calcX:      bool, optional
                Control argument to force system to calculate
                system reactances with system frequency, or to
                treat them as previously-calculated reactances.
                default=True
    
    Returns
    -------
    Tem:        float
                Torque (in Newton-meters) that is produced or consumed
                by the mechanical portion of the induction machine.
    
    See Also
    --------
    indmachvth:         Induction Machine Thevenin Voltage Calculator
    indmachzth:         Induction Machine Thevenin Impedance Calculator
    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
    indmachpkslip:      Induction Machine Peak Slip Calculator
    indmachpktorq:      Induction Machine Peak Torque Calculator
    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
    indmachstarttorq:   Induction Machine Starting Torque Calculator
    &#34;&#34;&#34;
    # Condition Inputs
    w = 2*_np.pi*freq
    if Ls != None: # Use Ls instead of Lls
        Lls = Ls - Lm
    if Lr != None: # Use Lr instead of Llr
        Llr = Lr - Lm
    if p != 0: # Calculate Sync. Speed from Num. Poles
        wsyn = w/(p/2)
    if calcX: # Convert Inductances to Reactances
        Lm *= w
        Lls *= w
        Llr *= w
    # Test for Valid Input Set
    if not any((p, wsync)):
        raise ValueError(&#34;Poles or Synchronous Speed must be specified.&#34;)
    if Vth == None:
        if not all((Vas,Rs,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Vth
        Vth = indmachvth(Vas,Rs,Lm,Lls,Ls,freq,calcX)
    if Zth == None:
        if not all((Rs,Llr,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Zth
        Zth = indmachzth(Rs,Lm,Lls,Ll,Ls,Lr,freq,calcX)
    # Use Terms to Calculate Pem
    Rth = Zth.real
    Xth = Zth.imag
    Tem = 3*abs(Vth)**2/((Rr/slip+Rth)**2+Xth) * Rr/(slip*wsyn)
    return(Tem)

# Define Induction Machine Peak Slip Calculator
def indmachpkslip(Rr,Zth=None,Rs=0,Lm=0,Lls=0,Llr=0,Ls=None,
                  Lr=None,freq=60,calcX=True):
    &#34;&#34;&#34;
    Induction Machine Slip at Peak Torque Calculator
    
    Function to calculate the slip encountered by an induction machine
    with the parameters specified when the machine is generating peak
    torque. Uses formula as shown below.
    
    .. math:: \\text{slip} = \\frac{R_r}{|Z_{th}|}
    
    where:

    .. math::
       Z_{th} = \\frac{(R_s+j\\omega L_{ls})j\\omega L_m}
       {R_s+j\\omega(L_{ls}+L_m)}+j\\omega L_{lr}
    
    Parameters
    ----------
    Rr:         float
                Rotor resistance in ohms
    Zth:        complex, optional
                Thevenin-equivalent inductance (in ohms) of the
                induction machine, may be calculated internally
                if given machine parameters.
    Rs:         float, optional
                Stator resistance in ohms
    Lm:         float, optional
                Magnetizing inductance in Henrys
    Lls:        float, optional
                Stator leakage inductance in Henrys, default=0
    Llr:        float, optional
                Rotor leakage inductance in Henrys, default=0
    Ls:         float, optional
                Stator inductance in Henrys
    Lr:         float, optional
                Rotor inductance in Henrys
    freq:       float, optional
                System (electrical) frequency in Hz, default=60
    calcX:      bool, optional
                Control argument to force system to calculate
                system reactances with system frequency, or to
                treat them as previously-calculated reactances.
                default=True
    
    Returns
    -------
    s_peak:     float
                The peak slip for the induction machine described.
    
    See Also
    --------
    indmachvth:         Induction Machine Thevenin Voltage Calculator
    indmachzth:         Induction Machine Thevenin Impedance Calculator
    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
    indmachpktorq:      Induction Machine Peak Torque Calculator
    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
    indmachstarttorq:   Induction Machine Starting Torque Calculator
    &#34;&#34;&#34;
    # Condition Inputs
    w = 2*_np.pi*freq
    if Ls != None: # Use Ls instead of Lls
        Lls = Ls - Lm
    if Lr != None: # Use Lr instead of Llr
        Llr = Lr - Lm
    if calcX: # Convert Inductances to Reactances
        Lm *= w
        Lls *= w
        Llr *= w
    # Test for Valid Input Set
    if Zth == None:
        if not all((Rs,Llr,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Zth
        Zth = indmachzth(Rs,Lm,Lls,Ll,Ls,Lr,freq,calcX)
    # Calculate Peak Slip
    s_peak = Rr / abs(Zth)
    return( s_peak )
    
# Define Induction Machine Phase-A, Rotor Current Calculator
def indmachiar(Vth=None,Zth=None,Vas=0,Rs=0,Lm=0,Lls=0,
               Llr=0,Ls=None,Lr=None,freq=60,calcX=True):
    &#34;&#34;&#34;
    Induction Machine Rotor Current Calculator
    
    Calculation function to find the phase-A, rotor current for an
    induction machine given the thevenin voltage and impedance.
    
    This current is calculated using the following formulas:
    
    .. math:: I_{a_{\\text{rotor}}} = \\frac{V_{th}}{|Z_{th}|+Z_{th}}
    
    where:
    
    .. math:: V_{th}=\\frac{j\\omega L_m}{R_s+j\\omega(L_{ls}+L_m)}V_{as}
    
    .. math::
       Z_{th} = \\frac{(R_s+j\\omega L_{ls})j\\omega L_m}
       {R_s+j\\omega(L_{ls}+L_m)}+j\\omega L_{lr}
    
    .. math:: \\omega = \\omega_{es} = 2\\pi\\cdot f_{\\text{electric}}
    
    Parameters
    ----------
    Vth:        complex, optional
                Thevenin-equivalent stator voltage of the
                induction machine, may be calculated internally
                if given stator voltage and machine parameters.
    Zth:        complex, optional
                Thevenin-equivalent inductance (in ohms) of the
                induction machine, may be calculated internally
                if given machine parameters.
    Vas:        complex, optional
                Terminal Stator Voltage in Volts
    Rs:         float, optional
                Stator resistance in ohms
    Lm:         float, optional
                Magnetizing inductance in Henrys
    Lls:        float, optional
                Stator leakage inductance in Henrys, default=0
    Llr:        float, optional
                Rotor leakage inductance in Henrys, default=0
    Ls:         float, optional
                Stator inductance in Henrys
    Lr:         float, optional
                Rotor inductance in Henrys
    freq:       float, optional
                System (electrical) frequency in Hz, default=60
    calcX:      bool, optional
                Control argument to force system to calculate
                system reactances with system frequency, or to
                treat them as previously-calculated reactances.
                default=True
    
    Returns
    -------
    Iar:        complex
                The rotor, phase-A current in amps.
    
    See Also
    --------
    indmachvth:         Induction Machine Thevenin Voltage Calculator
    indmachzth:         Induction Machine Thevenin Impedance Calculator
    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
    indmachpkslip:      Induction Machine Peak Slip Calculator
    indmachpktorq:      Induction Machine Peak Torque Calculator
    indmachstarttorq:   Induction Machine Starting Torque Calculator
    &#34;&#34;&#34;
    # Condition Inputs
    w = 2*_np.pi*freq
    if Ls != None: # Use Ls instead of Lls
        Lls = Ls - Lm
    if Lr != None: # Use Lr instead of Llr
        Llr = Lr - Lm
    if p != 0: # Calculate Sync. Speed from Num. Poles
        wsyn = w/(p/2)
    if calcX: # Convert Inductances to Reactances
        Lm *= w
        Lls *= w
        Llr *= w
    # Test for Valid Input Set
    if Vth == None:
        if not all((Vas,Rs,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Vth
        Vth = indmachvth(Vas,Rs,Lm,Lls,Ls,freq,calcX)
    if Zth == None:
        if not all((Rs,Llr,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Zth
        Zth = indmachzth(Rs,Lm,Lls,Ll,Ls,Lr,freq,calcX)
    # Calculate Rotor Current
    Iar = Vth / (Zth.real + Zth)
    return(Iar)

# Define Induction Machine Peak Torque Calculator
def indmachpktorq(Rr,s_pk=None,Iar=None,Vth=None,Zth=None,Vas=0,Rs=0,
                  Lm=0,Lls=0,Llr=0,Ls=None,Lr=None,freq=60,calcX=True):
    &#34;&#34;&#34;
    Induction Machine Peak Torque Calculator
    
    Calculation function to find the peak torque for an
    induction machine given the thevenin voltage and impedance.
    
    This current is calculated using the following formulas:
    
    .. math:: 
       T_{em}=(|I_{a_{\\text{rotor}}}|)^2\\cdot\\frac{R_r}
       {\\text{slip}_{\\text{peak}}}
    
    where:
    
    .. math:: I_{a_{\\text{rotor}}} = \\frac{V_{th}}{|Z_{th}|+Z_{th}}
    
    .. math:: V_{th}=\\frac{j\\omega L_m}{R_s+j\\omega(L_{ls}+L_m)}V_{as}
    
    .. math::
       Z_{th} = \\frac{(R_s+j\\omega L_{ls})j\\omega L_m}
       {R_s+j\\omega(L_{ls}+L_m)}+j\\omega L_{lr}
    
    .. math:: \\omega = \\omega_{es} = 2\\pi\\cdot f_{\\text{electric}}
    
    Parameters
    ----------
    Rr:         float
                Rotor resistance in Ohms
    s_pk:       float, optional
                Peak induction machine slip, may be calculated
                internally if remaining machine characteristics are
                provided.
    Iar:        complex, optional
                Phase-A, Rotor Current in Amps, may be calculated
                internally if remaining machine characteristics are
                provided.
    Vth:        complex, optional
                Thevenin-equivalent stator voltage of the
                induction machine, may be calculated internally
                if given stator voltage and machine parameters.
    Zth:        complex, optional
                Thevenin-equivalent inductance (in ohms) of the
                induction machine, may be calculated internally
                if given machine parameters.
    Vas:        complex, optional
                Terminal Stator Voltage in Volts
    Rs:         float, optional
                Stator resistance in ohms
    Lm:         float, optional
                Magnetizing inductance in Henrys
    Lls:        float, optional
                Stator leakage inductance in Henrys, default=0
    Llr:        float, optional
                Rotor leakage inductance in Henrys, default=0
    Ls:         float, optional
                Stator inductance in Henrys
    Lr:         float, optional
                Rotor inductance in Henrys
    freq:       float, optional
                System (electrical) frequency in Hz, default=60
    calcX:      bool, optional
                Control argument to force system to calculate
                system reactances with system frequency, or to
                treat them as previously-calculated reactances.
                default=True
    
    Returns
    -------
    Tpk:        float
                Peak torque of specified induction machine in
                newton-meters.
    
    See Also
    --------
    indmachvth:         Induction Machine Thevenin Voltage Calculator
    indmachzth:         Induction Machine Thevenin Impedance Calculator
    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
    indmachpkslip:      Induction Machine Peak Slip Calculator
    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
    indmachstarttorq:   Induction Machine Starting Torque Calculator
    &#34;&#34;&#34;
    # Condition Inputs
    w = 2*_np.pi*freq
    if Ls != None: # Use Ls instead of Lls
        Lls = Ls - Lm
    if Lr != None: # Use Lr instead of Llr
        Llr = Lr - Lm
    if p != 0: # Calculate Sync. Speed from Num. Poles
        wsyn = w/(p/2)
    if calcX: # Convert Inductances to Reactances
        Lm *= w
        Lls *= w
        Llr *= w
    # Test for Valid Input Set
    if Vth == None:
        if not all((Vas,Rs,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Vth
        Vth = indmachvth(Vas,Rs,Lm,Lls,Ls,freq,calcX)
    if Zth == None:
        if not all((Rs,Llr,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Zth
        Zth = indmachzth(Rs,Lm,Lls,Ll,Ls,Lr,freq,calcX)
    if Iar == None:
        if not all((Vth,Zth)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Ias
        Iar = indmachiar(Vth=Vth,Zth=Zth)
    if s_pk == None:
        if not all((Rr,Zth)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Peak Slip
        s_pk = indmachpkslip(Rr=Rr,Zth=Zth)
    # Use Terms to Calculate Peak Torque
    Tpk = abs(Iar)**2 * Rr/s_pk
    return(Tpk)
    
# Define Induction Machine Peak Torque Calculator
def indmachstarttorq(Rr,Iar=None,Vth=None,Zth=None,Vas=0,Rs=0,Lm=0,
                     Lls=0,Llr=0,Ls=None,Lr=None,freq=60,calcX=True):
    &#34;&#34;&#34;
    Induction Machine Starting Torque Calculator
    
    Calculation function to find the starting torque for an
    induction machine given the thevenin voltage and impedance.
    
    This current is calculated using the following formulas:
    
    .. math:: 
       T_{em}=(|I_{a_{\\text{rotor}}}|)^2\\cdot\\frac{R_r}
       {\\text{slip}_{\\text{peak}}}
    
    where:
    
    .. math:: \\text{slip} = 1
    
    .. math::
       I_{a_{\\text{rotor}}} = \\frac{V_{th}}{\\frac{R_r}{\\text{slip}}+Z_{th}}
    
    .. math:: V_{th}=\\frac{j\\omega L_m}{R_s+j\\omega(L_{ls}+L_m)}V_{as}
    
    .. math::
       Z_{th} = \\frac{(R_s+j\\omega L_{ls})j\\omega L_m}
       {R_s+j\\omega(L_{ls}+L_m)}+j\\omega L_{lr}
    
    .. math:: \\omega = \\omega_{es} = 2\\pi\\cdot f_{\\text{electric}}
    
    Parameters
    ----------
    Rr:         float
                Rotor resistance in Ohms
    Iar:        complex, optional
                Phase-A, Rotor Current in Amps, may be calculated
                internally if remaining machine characteristics are
                provided.
    Vth:        complex, optional
                Thevenin-equivalent stator voltage of the
                induction machine, may be calculated internally
                if given stator voltage and machine parameters.
    Zth:        complex, optional
                Thevenin-equivalent inductance (in ohms) of the
                induction machine, may be calculated internally
                if given machine parameters.
    Vas:        complex, optional
                Terminal Stator Voltage in Volts
    Rs:         float, optional
                Stator resistance in ohms
    Lm:         float, optional
                Magnetizing inductance in Henrys
    Lls:        float, optional
                Stator leakage inductance in Henrys, default=0
    Llr:        float, optional
                Rotor leakage inductance in Henrys, default=0
    Ls:         float, optional
                Stator inductance in Henrys
    Lr:         float, optional
                Rotor inductance in Henrys
    freq:       float, optional
                System (electrical) frequency in Hz, default=60
    calcX:      bool, optional
                Control argument to force system to calculate
                system reactances with system frequency, or to
                treat them as previously-calculated reactances.
                default=True
    
    Returns
    -------
    Tstart:     float
                Peak torque of specified induction machine in
                newton-meters.
    
    See Also
    --------
    indmachvth:         Induction Machine Thevenin Voltage Calculator
    indmachzth:         Induction Machine Thevenin Impedance Calculator
    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
    indmachpkslip:      Induction Machine Peak Slip Calculator
    indmachpktorq:      Induction Machine Peak Torque Calculator
    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
    &#34;&#34;&#34;
    # Condition Inputs
    w = 2*_np.pi*freq
    if Ls != None: # Use Ls instead of Lls
        Lls = Ls - Lm
    if Lr != None: # Use Lr instead of Llr
        Llr = Lr - Lm
    if p != 0: # Calculate Sync. Speed from Num. Poles
        wsyn = w/(p/2)
    if calcX: # Convert Inductances to Reactances
        Lm *= w
        Lls *= w
        Llr *= w
    # Slip is 1 (one) for starting
    slip = 1
    # Test for Valid Input Set
    if Vth == None:
        if not all((Vas,Rs,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Vth
        Vth = indmachvth(Vas,Rs,Lm,Lls,Ls,freq,calcX)
    if Zth == None:
        if not all((Rs,Llr,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Zth
        Zth = indmachzth(Rs,Lm,Lls,Ll,Ls,Lr,freq,calcX)
    if Iar == None:
        if not all((Vth,Zth)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Ias
        Iar = Vth / (Rr/slip + Zth)
    # Use Terms to Calculate Peak Torque
    Tstart = abs(Iar)**2 * Rr/s_pk
    return(Tstart)

# Define Induction Machine Stator Torque Calculator
def pstator(Pem, slip):
    &#34;&#34;&#34;
    Stator Power Calculator for Induction Machine
    
    Given the electromechanical power and the slip,
    this function will calculate the power related to the
    stator (provided or consumed).
    
    .. math:: P_s=\\frac{P_{em}}{1-\\text{slip}}
    
    Parameters
    ----------
    Pem:        float
                Electromechanical power in watts.
    slip:       float
                Slip factor in rad/sec.
    
    Returns
    -------
    Ps:         float
                Power related to the stator in watts.
    
    See Also
    --------
    protor:         Rotor Power Calculator for Induction Machines
    &#34;&#34;&#34;
    # Calculate and Return
    Ps = Pem / (1-slip)
    return(Ps)

# Define Induction Machine Rotor Torque Calculator
def protor(Pem, slip):
    &#34;&#34;&#34;
    Rotor Power Calculator for Induction Machine
    
    Given the electromechanical power and the slip,
    this function will calculate the power related to the
    rotor (provided or consumed).
    
    .. math:: P_r=-\\text{slip}\\cdot\\frac{P_{em}}{1-\\text{slip}}
    
    Parameters
    ----------
    Pem:        float
                Electromechanical power in watts.
    slip:       float
                Slip factor in rad/sec.
    
    Returns
    -------
    Pr:         float
                Power related to the rotor in watts.
    
    See Also
    --------
    pstator:         Stator Power Calculator for Induction Machines
    &#34;&#34;&#34;
    # Calculate and Return
    Pr = -slip * (Pem / (1-slip))
    return(Pr)

# Define De Calculator for Transmission Lines
def de_calc(rho,freq=60):
    &#34;&#34;&#34;
    Calculator for De Transmission Line Value
    
    Simple calculator to find the De value for a line
    with particular earth resistivity (rho).
    
    .. math:: D_e=D_{e_{\\text{constant}}}\\sqrt{\\frac{\\rho}{freq}}
    
    Parameters
    ----------
    rho:        float
                Earth resistivity (in ohm-meters), may also
                be passed a string in the set: {SEA, SWAMP,
                AVG,AVERAGE,DAMP,DRY,SAND,SANDSTONE}
    freq:       float, optional
                System frequency in Hertz, default=60
    &#34;&#34;&#34;
    # If Descriptive String Provided, Use to Determine Rho
    if isinstance(rho,str):
        rho = rho.upper()
        rho = { &#39;SEA&#39;:          0.01,
                &#39;SWAMP&#39;:        10,
                &#39;AVG&#39;:          100,
                &#39;AVERAGE&#39;:      100,
                &#39;DAMP&#39;:         100,
                &#39;DRY&#39;:          1000,
                &#39;SAND&#39;:         1E9,
                &#39;SANDSTONE&#39;:    1E9,
              }[rho]
    # Calculate De
    De = De0 * _np.sqrt( rho / freq )
    return(De)

# Define Impedance Per Length Calculator
def zperlength(Rd=None,Rself=None,Rac=None,Rgwac=None,De=None,
               rho=&#34;AVG&#34;,Ds=None,Dsgw=None,dia_gw=None,Dab=None,
               Dbc=None,Dca=None,Dagw=None,Dbgw=None,Dcgw=None,
               resolve=True,freq=60):
    &#34;&#34;&#34;
    Transmission Line Impedance (RL) Calculator
    
    Simple impedance matrix generator to provide the full
    impedance per length matrix.
    
    Parameters
    ----------
    Rd:         float, optional
                Resistance Rd term in ohms, will be generated
                automatically if set to None, default=None
    Rself:      float, optional
                Self Resistance term in ohms.
    Rac:        float, optional
                AC resistance in ohms.
    Rgwac:      float, optional
                Ground-Wire AC resistance in ohms.
    De:         float, optional
                De term, in feet, if None provided, and `rho`
                parameter is specified, will interpretively be
                calculated.
    rho:        float, optional
                Earth resistivity in ohm-meters. default=&#34;AVG&#34;
    Ds:         float, optional
                Distance (self) for each phase conductor in feet,
                commonly known as GMD.
    Dsgw:       float, optional
                Distance (self) for the ground wire conductor in
                feet, commonly known as GMD.
    dia_gw:     float, optional
                Ground-Wire diameter in feet, may be used to
                calculate an approximate Dsgw if no Dsgw is provided.
    Dab:        float, optional
                Distance between phases A and B, in feet.
    Dbc:        float, optional
                Distance between phases B and C, in feet.
    Dca:        float, optional
                Distance between phases C and A, in feet.
    Dagw:       float, optional
                Distance between phase A and ground conductor, in feet.
    Dbgw:       float, optional
                Distance between phase B and ground conductor, in feet.
    Dcgw:       float, optional
                Distance between phase C and ground conductor, in feet.
    resolve:    bool, optional
                Control argument to specify whether the resultant
                ground-wire inclusive per-length impedance matrix
                should be reduced to a 3x3 equivalent matrix.
                default=True
    freq:       float, optional
                System frequency in Hertz.
    &#34;&#34;&#34;
    # Start with Empty Arrays
    Rperlen = 0
    Lperlen = 0
    # Generate Rd
    if Rd==None:
        Rd = freq * carson_r
    # Generate Dsgw if Not Provided
    if Dsgw==None and dia_gw!=None:
        Dsgw = _np.exp(-1/4) * dia_gw/2
    # Generate Real Part
    if Rd &gt; 0:
        # Generate Rself if not Provided
        if Rself==None:
            # Validate Inputs
            if not all((Rd,Rac)):
                raise ValueError(&#34;Too few arguments&#34;)
            Rself = Rac + Rd
        # Generate RperLength Matrix
        Rperlen = _np.array([
            [Rself,Rd,Rd],
            [Rd,Rself,Rd],
            [Rd,Rd,Rself]
            ])
        # Add GW effects If Necessary
        if all((Rgwac,Dsgw,Dagw,Dbgw,Dcgw)):
            # Calculate Rselfgw
            Rselfgw = Rgwac + Rd
            # Append Right-Most Column
            Rperlen = _np.append(Rperlen,
                [[Rd],[Rd],[Rd]],axis=1)
            # Append New Row
            Rperlen = _np.append(Rperlen,
                [[Rd,Rd,Rd,Rselfgw]],axis=0)
    # Generate Imaginary Part
    if any((De,Ds,rho)):
        # Validate Inputs
        if not all((Dab,Dbc,Dca)):
            raise ValueError(&#34;Distance Terms [Dab,Dbc,Dca] Required&#34;)
        if Ds==None:
            raise ValueError(&#34;Distance Self (Ds) Required&#34;)
        # De must be generated
        if De==None:
            if rho==None:
                raise ValueError(&#34;Too few arguments&#34;)
            De = de_calc(rho,freq)
        # Generate LperLength Matrix
        Lperlen = _np.array([
            [_np.log(De/Ds),_np.log(De/Dab),_np.log(De/Dca)],
            [_np.log(De/Dab),_np.log(De/Ds),_np.log(De/Dbc)],
            [_np.log(De/Dca),_np.log(De/Dbc),_np.log(De/Ds)]
            ])
        # Add GW effects If Necessary
        if all((Rgwac,Dsgw,Dagw,Dbgw,Dcgw)):
            # Append Right-Most Column
            Lperlen = _np.append(Lperlen,
                [[_np.log(De/Dagw)],[_np.log(De/Dbgw)],[_np.log(De/Dcgw)]],
                axis=1)
            # Append New Row
            Lperlen = _np.append(Lperlen,
                [[_np.log(De/Dagw),_np.log(De/Dbgw),
                _np.log(De/Dcgw),_np.log(De/Dsgw)]],axis=0)
        Lperlen = Lperlen * (1j*u0*freq)
    # Add Real and Imaginary Parts
    Zperlen = Rperlen + Lperlen
    # Resolve to 3x3 Matrix if Needed
    if resolve and all((Rgwac,Dsgw,Dagw,Dbgw,Dcgw)):
        # Perform Slicing to Retrieve Useful Arrays
        Za = Zperlen[:3,:3]
        Zb = Zperlen[:3,3:4]
        Zc = Zperlen[3:4,:3]
        Zd = Zperlen[3:4,3:4]
        # Calculate New (3x3) Equivalent Zperlen
        Zperlen = Za - _np.dot(Zb,_np.dot(_np.linalg.inv(Zd),Zc))
    return(Zperlen)
    
# Define Transposition Matrix Formula
def transposez(Zeq,fabc=1/3,fcab=1/3,fbca=1/3,linelen=1):
    &#34;&#34;&#34;
    Transmission Matrix Equivalent Transposition Calculator
    
    Given the impedance matrix and the percent of the line spent
    in each transposition relation (ABC, CAB, and BCA).
    
    .. math::
       f_{abc}Z_{eq}+f_{cab}R_p^{-1}\\cdot Z_{eq}\\cdot R_p+
       f_{bca}Z_{eq}R_p\\cdot Z_{eq}\\cdot R_p^{-1}
    
    where:
    
    .. math:
       R_p=\\begin{bmatrix}\\\\
       0 &amp; 0 &amp; 1 \\\\
       1 &amp; 0 &amp; 0 \\\\
       0 &amp; 1 &amp; 0 \\\\
       \\end{bmatrix}
    
    Parameters
    ----------
    Zeq:        array_like
                Per-Length (or total length) line impedance in ohms.
    fabc:       float, optional
                Percentage of line set with phase relation ABC,
                default=1/3
    fcab:       float, optional
                Percentage of line set with phase relation CAB,
                default=1/3
    fbca:       float, optional
                Percentage of line set with phase relation BCA,
                default=1/3
    linelen:    Length of line (unitless), default=1
    &#34;&#34;&#34;
    # Condition Input
    Zeq = _np.asarray(Zeq)
    # Define Rp Array
    Rp = _np.array([
        [0,0,1],
        [1,0,0],
        [0,1,0]
    ])
    # Define Inverse Rp Array
    _Rp = np.linalg.inv(Rp)
    Zeq = fabc*Zeq + fcab*(_Rp.dot(Zeq.dot(Rp))) + fbca*(Rp.dot(Zeq.dot(_Rp)))
    Zeq = Zeq * linelen
    return(Zeq)
    
# Define GMD Calculator
def gmd(Ds,*args):
    &#34;&#34;&#34;
    Simple GMD Calculator
    
    Calculates the GMD (Geometric Mean Distance) for a system
    with the parameters of a list of arguments.
    
    .. math:: GMD=(D_s*D_1*\\ddot*D_n)^{\\frac{1}{1+n}}
    
    Parameters
    ----------
    Ds:         float
                Self distance (unitless), normally provided from
                datasheet/reference
    *args:      floats, optional
                Remaining set of distance values (unitless)
    &#34;&#34;&#34;
    # Find the Root from Number of Arguments
    root = len(args) + 1
    # Calculate the Root Term
    gmdx = Ds
    for dist in args:
        gmdx *= dist
    # Apply Root Calculation
    GMD = gmdx**(1/root)
    return(GMD)

# Define FOC IM Rated Value Calculator
def indmachfocratings(Rr,Rs,Lm,Llr=0,Lls=0,Lr=None,
                      Ls=None,Vdqs=1,Tem=1,wes=1):
    &#34;&#34;&#34;
    FOC Ind. Machine Rated Operation Calculator
    
    Determines the parameters and characteristics of a Field-
    Oriented-Controlled Induction Machine operating at its
    rated limits.
    
    Parameters
    ----------
    Rr:         float
                Rotor resistance in per-unit-ohms
    Rs:         float
                Stator resistance in per-unit-ohms
    Lm:         float
                Magnetizing inductance in per-unit-Henrys
    Llr:        float, optional
                Rotor leakage inductance in per-unit-Henrys,
                default=0
    Lls:        float, optional
                Stator leakage inductance in per-unit-Henrys,
                default=0
    Lr:         float, optional
                Rotor inductance in per-unit-Henrys
    Ls:         float, optional
                Stator inductance in per-unit-Henrys
    Vdqs:       complex, optional
                The combined DQ-axis voltage required for rated
                operation, in per-unit-volts, default=1+j0
    Tem:        float, optional
                The mechanical torque required for rated operation,
                in per-unit-newton-meters, default=1
    wes:        float, optional
                The per-unit electrical system frequency, default=1
    
    Returns
    -------
    Idqr:       complex
                Combined DQ-axis Rotor Current in per-unit-amps
    Idqs:       complex
                Combined DQ-axis Stator Current in per-unit-amps
    LAMdqr:     complex
                Combined DQ-axis Rotor Flux in per-unit
    LAMdqs:     complex
                Combined DQ-axis Stator Flux in per-unit
    slip_rat:   float
                Rated Slip as percent of rotational and system frequencies
    w_rat:      float
                Rated System frequency in per-unit-rad/sec
    lamdr_rat:  float
                Rated D-axis rotor flux in per-unit
    &#34;&#34;&#34;
    # Condition Inputs:
    if Ls == None: # Use Lls instead of Ls
        Ls = Lls + Lm
    if Lr == None: # Use Llr instead of Lr
        Lr = Llr + Lm
    # Define Equations Function as Solver
    def equations(val):
        Idr,Iqr,Ids,Iqs,LAMdr,LAMqr,LAMds,LAMqs,wr = val
        A = (Rs*Ids - wes*LAMqs) - Vdqs
        B = Rs*Iqs - wes*LAMds
        C = Rr*Idr - (wes-wr)*LAMqr
        D = Rr*Iqr + (wes-wr)*LAMdr
        E = (Ls*Ids + Lm*Idr) - LAMds
        F = (Ls*Iqs + Lm*Iqr) - LAMqs
        G = (Lm*Ids+Lr*Idr) - LAMdr
        H = (Lm*Iqs+Lr*Iqr) - LAMqr
        I = (Lm/Lr*(LAMdr*Iqs-LAMqr*Ids)) - Tem
        return(A,B,C,D,E,F,G,H,I)
    # Define Initial Guesses
    Idr0 = -1
    Iqr0 = -1
    Ids0 = 1
    Iqs0 = 1
    LAMdr0 = Lm*Ids0 + Lr*Idr0
    LAMqr0 = Lm*Iqs0 + Lr*Iqr0
    LAMds0 = Ls*Ids0 + Lm*Idr0
    LAMqs0 = Ls*Iqs0 + Lm*Iqr0
    wr = 1
    # Use Iterative Solver to Find Results
    Idr,Iqr,Ids,Iqs,LAMdr,LAMqr,LAMds,LAMqs,wr = _fsolve(equations,(
        Idr0,Iqr0,Ids0,Iqs0,LAMdr0,LAMqr0,LAMds0,LAMqs0,wr))
    # Calculate Remaining Rating Terms
    slip_rated = (wes-wr)/wes
    w_rated = wr
    lamdr_rated = abs(LAMdr+1j*LAMqr)
    return(
        compose(Idr,Iqr),
        compose(Ids,Iqs),
        compose(LAMdr,LAMqr),
        compose(LAMds,LAMqs),
        slip_rated,
        w_rated,
        lamdr_rated
    )

# Define FOC IM Control Equation Evaluation Function
def imfoc_control(Tem_cmd,LAMdr_cmd,wr_cmd,Rr,Rs,Lm,
                  Llr=0,Lls=0,Lr=None,Ls=None,s_err=0):
    &#34;&#34;&#34;
    FOC Ind. Machine Rated Operation Calculator
    
    Determines the parameters and characteristics of a Field-
    Oriented-Controlled Induction Machine operating at its
    rated limits.
    
    Parameters
    ----------
    Tem_cmd:    float
                Mechanical torque setpoint in per-unit-newton-meters
    LAMdr_cmd:  float
                D-axis flux setpoint in per-unit
    wr_cmd:     float
                Mechanical (rotor) speed in per-unit-rad/sec
    Rr:         float
                Rotor resistance in per-unit-ohms
    Rs:         float
                Stator resistance in per-unit-ohms
    Lm:         float
                Magnetizing inductance in per-unit-Henrys
    Llr:        float, optional
                Rotor leakage inductance in per-unit-Henrys,
                default=0
    Lls:        float, optional
                Stator leakage inductance in per-unit-Henrys,
                default=0
    Lr:         float, optional
                Rotor inductance in per-unit-Henrys
    Ls:         float, optional
                Stator inductance in per-unit-Henrys
    s_err:      float, optional
                Error in slip calculation as a percent (e.g. 0.25),
                default=0
    
    Returns
    -------
    Vdqs:       complex
                Combined DQ-axis Stator Voltage in per-unit volts
    Idqr:       complex
                Combined DQ-axis Rotor Current in per-unit-amps
    Idqs:       complex
                Combined DQ-axis Stator Current in per-unit-amps
    LAMdqr:     complex
                Combined DQ-axis Rotor Flux in per-unit
    LAMdqs:     complex
                Combined DQ-axis Stator Flux in per-unit
    wslip:      float
                Machine Slip frequency in per-unit-rad/sec
    wes:        float
                The electrical system frequency in per-unit-rad/sec
    &#34;&#34;&#34;
    # Condition Inputs:
    if Ls == None: # Use Lls instead of Ls
        Ls = Lls + Lm
    if Lr == None: # Use Llr instead of Lr
        Lr = Llr + Lm
    # Calculate Additional Constraints
    sigma = (1-Lm**2/(Ls*Lr))
    accuracy = 1+s_err
    # Command Values (Transient and Steady State)
    Ids = LAMdr_cmd/Lm
    Iqs = Tem_cmd/((Lm/Lr)*LAMdr_cmd)
    wslip = Rr/(Lr*accuracy) * (Lm*Iqs)/LAMdr_cmd
    wes = wslip + wr_cmd
    # Stator dq Voltages (Steady State)
    Vds = Rs*Ids - wes*sigma*Ls*Iqs
    Vqs = Rs*Iqs - wes*Ls*Ids
    # Remaining Steady State
    Iqr = -Lm/Lr * Iqs
    Idr = 0
    LAMqr = 0
    LAMqs = sigma*Ls*Iqs
    LAMds = Ls*Ids
    return(
        compose(Vds,Vqs),
        compose(Idr,Iqr),
        compose(Ids,Iqs),
        compose(LAMdr_cmd,LAMqr),
        compose(LAMds,LAMqs),
        wslip,
        wes
    )

# Define Synch. Machine Eq Calculator
def synmach_Eq(Vt_pu,Itmag,PF,Ra,Xd,Xq):
    &#34;&#34;&#34;
    Synchronous Machine Eq Calculator
    
    Given specified parameter set, will calculate
    the internal voltage on the q-axis (Eq).
    
    .. math:: E_q=V_{t_{pu}}-\\left[R_a\\cdot I_{t_{pu}}+
       j\\cdot X_q\\cdot I_{t_{pu}}+j(X_d-X_q)\\cdot I_{ad}\\right]
    
    where:
    
    .. math:: I_{t_{pu}}=I_{t_{mag}}\\cdot e^{-j(
       \\angle{V_{t_{pu}}}-\\cos^{-1}(PF))}
    
    .. math:: \\theta_q=\\angle{V_{t_{pu}}-\\left(R_a
       I_{t_{pu}}+j\\cdot X_qI_{t_{pu}}\\right)
    
    .. math:: I_{ad}=\\left|I_{t_{pu}}\\cdot\\sin(
       -\\cos^{-1}(PF)+\\theta_q)\\right|e^{j(\\theta_q
       -90°)}
    
    Parameters
    ----------
    Vt_pu:      complex
                Terminal voltage in per-unit-volts
    Itmag:      float
                Terminal current magnitude in per-
                unit-amps
    PF:         float
                Machine Power Factor, (+)ive values denote
                leading power factor, (-)ive values denote
                lagging power factor
    Ra:         float
                AC resistance in per-unit-ohms
    Xd:         float
                D-axis reactance in per-unit-ohms
    Xq:         float
                Q-axis reactance in per-unit-ohms
    
    Returns
    -------
    Eq:         complex
                Internal Synchronous Machine Voltage
                in per-unit-volts
    &#34;&#34;&#34;
    # Calculate Required Terms
    phi = _np.arccos(PF)
    Itmag = abs(Itmag)
    It_pu = Itmag*_np.exp(-1j*(_np.angle(Vt_pu)+phi))
    th_q = _np.angle(Vt_pu - (Ra*It_pu+1j*Xq*It_pu))
    Iad = (abs(It_pu)*_np.sin(phi+th_q))*_np.exp(1j*(th_q-_np.pi/2))
    # Calculate Eq
    Eq = Vt_pu - (Ra*It_pu+1j*Xq*It_pu+1j*(Xd-Xq)*Iad)
    return(Eq)

# Define Power-Factor Voltage/Current Relation
def vipf(V=None,I=None,PF=1,find=&#39;&#39;):
    &#34;&#34;&#34;
    Voltage / Current / Power Factor Solver
    
    Given two of the three parameters, will solve for the
    third; beit voltage, current, or power factor.
    
    Parameters
    ----------
    V:          complex
                System voltage (in volts), default=None
    I:          complex
                System current (in amps), default=None
    PF:         float
                System power factor, (+)ive values denote
                leading power factor, (-)ive values denote
                lagging power factor; default=1
    find:       str, optional
                Control argument to specify which value
                should be returned.
    
    Returns
    -------
    V:          complex
                System voltage (in volts), default=None
    I:          complex
                System current (in amps), default=None
    PF:         float
                System power factor, (+)ive values denote
                leading power factor, (-)ive values denote
                lagging poer factor; default=1
    &#34;&#34;&#34;
    # Test to find Voltage
    if isinstance(V,float) and isinstance(I,complex):
        phi = -_np.sign(PF)*_np.arccos(PF)
        V = V*_np.exp(-1j*phi)
    # Test to find Current
    elif isinstance(V,complex) and isinstance(I,float):
        phi = _np.sign(PF)*_np.arccos(PF)
        I = I*_np.exp(-1j*phi)
    # Test to find Power Factor
    elif all([V,I]):
        phi = _np.angle(V) - _np.angle(I)
        PF = _np.cos(phi)
    # Failed Mode
    else:
        raise ValueError(&#34;All values must be provided.&#34;)
    # Return
    find = find.upper()
    if find == &#39;V&#39;:
        return(V)
    elif find == &#39;I&#39;:
        return(I)
    elif find == &#39;PF&#39;:
        return(PF)
    else:
        return(V,I,PF)

# Define Angular Velocity Conversion Functions
def rad_to_rpm(rad):
    &#34;&#34;&#34;
    Radians-per-Second to RPM Converter
    
    Given the angular velocity in rad/sec, this
    function will evaluate the velocity in RPM
    (Revolutions-Per-Minute).
    
    Parameters
    ----------
    rad:        float
                The angular velocity in radians-
                per-second
    
    Returns
    -------
    rpm:        float
                The angular velocity in revolutions-
                per-minute (RPM)
    &#34;&#34;&#34;
    rpm = 60/(2*_np.pi)*rad
    return(rpm)

# Define Angular Velocity Conversion Functions
def rpm_to_rad(rpm):
    &#34;&#34;&#34;
    RPM to Radians-per-Second Converter
    
    Given the angular velocity in RPM (Revolutions-
    Per-Minute), this function will evaluate the
    velocity in rad/sec.
    
    Parameters
    ----------
    rpm:        float
                The angular velocity in revolutions-
                per-minute (RPM)
    
    Returns
    -------
    rad:        float
                The angular velocity in radians-
                per-second
    &#34;&#34;&#34;
    rad = 2*_np.pi/60*rpm
    return(rad)

# Define Angular Velocity Conversion Functions
def hz_to_rpm(hz):
    &#34;&#34;&#34;
    Hertz to RPM Converter
    
    Given the angular velocity in Hertz, this
    function will evaluate the velocity in RPM
    (Revolutions-Per-Minute).
    
    Parameters
    ----------
    hz:         float
                The angular velocity in Hertz
    
    Returns
    -------
    rpm:        float
                The angular velocity in revolutions-
                per-minute (RPM)
    &#34;&#34;&#34;
    rpm = hz*60
    return(rpm)

# Define Angular Velocity Conversion Functions
def rpm_to_hz(rpm):
    &#34;&#34;&#34;
    RPM to Hertz Converter
    
    Given the angular velocity in RPM (Revolutions-
    Per-Minute), this function will evaluate the
    velocity in Hertz.
    
    Parameters
    ----------
    rpm:        float
                The angular velocity in revolutions-
                per-minute (RPM)
    
    Returns
    -------
    hz:         float
                The angular velocity in Hertz
    &#34;&#34;&#34;
    hz = rpm/60
    return(hz)

# Define Synchronous Speed Calculator
def syncspeed(Npol,freq=60,Hz=False):
    &#34;&#34;&#34;
    Synchronous Speed Calculator Function
    
    Simple method of calculating the synchronous
    speed of an induction machine given the number
    of poles in the machine&#39;s construction, and
    the machine&#39;s operating electrical frequency.
    
    .. math:: \\omega_{\\text{syn}}=\\frac{2\\pi
       \\cdot\\text{freq}}{\\frac{N_{\\text{pol}}}{2}}
    
    Parameters
    ----------
    Npol:       int
                Number of electrical poles in
                machine&#39;s construction.
    freq:       float, optional
                Frequency of electrical system in
                Hertz, default=60
    Hz:         bool, optional
                Boolean control to enable return
                in Hertz. default=False
    
    Returns
    -------
    wsyn:       float
                Synchronous Speed of Induction Machine,
                defaults to units of rad/sec, but may
                be set to Hertz if `Hz` set to True.
    &#34;&#34;&#34;
    wsyn = 2*_np.pi*freq / (Npol/2)
    if Hz:
        return(wsyn / (2*_np.pi))
    return(wsyn)

# Define Machine Slip Calculation Function
def machslip(mech,syn=60):
    &#34;&#34;&#34;
    Machine Slip Calculator
    
    Given the two parameters (mechanical and synchronous
    speed, or frequency) this function will return the
    unitless slip of the rotating machine.
    
    .. math:: \\text{slip}=\\frac{\\text{syn}-\\text{mech}}
       {\\text{syn}}
    
    Parameters
    ----------
    mech:       float
                The mechanical frequency (or speed),
                of the rotating machine.
    syn:        float, optional
                The synchronous frequency (or speed),
                defaults as a frequency set to 60Hz,
                default=60
    
    Returns
    -------
    slip:       float
                The rotating machine&#39;s slip constant.
    &#34;&#34;&#34;
    slip = (syn-mech)/syn
    return(slip)
    
# Define 3-Phase Valpha Calculator
def phs3valpha( VA, VB=0, VC=0 ):
    &#34;&#34;&#34;
    Three-Phase V-Alpha Calculator
    
    Accepts the three-phase voltages for which the
    accumulated Alpha voltage should be calculated.
    
    .. math:: V_{\\alpha}=V_A-\\frac{V_B}{2}-\\frac{V_C}{2}
    
    Parameters
    ----------
    VA:         [float, complex]
                A-phase voltage, (or tuple/list of
                voltages), unitless.
    VB:         [float, complex], optional
                B-phase voltage, unitless.
    VC:         [float, complex], optional
                C-phase voltage, unitless.
    
    Returns
    -------
    Valpha:     [float, complex]
                Alpha-voltage as calculated from
                input three-phase voltages. Matches
                type of inputs.
    &#34;&#34;&#34;
    # Handle Combined (list/tuple) Input
    if (isinstance(VA, (tuple,list)) and
        VB==0 and VC==C):
        if len(VA) != 3:
            raise ValueError(&#34;Invalid input set, must &#34;
                +&#34;be list of three elements, three inputs,&#34;
                +&#34; or three array-like objects of equal &#34;
                +&#34;length.&#34;)
        Valpha = VA[0] - VA[1]/2 - VA[2]/2
    # Handle Separated Inputs
    else:
        Valpha = VA - VB/2 - VC/2
    # Return the Alpha-Voltage
    return( Valpha )


# END OF FILE</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="electricpy.bode" href="bode.html">electricpy.bode</a></code></dt>
<dd>
<div class="desc"><p><code>electricpy.bode.py</code>
…</p></div>
</dd>
<dt><code class="name"><a title="electricpy.constants" href="constants.html">electricpy.constants</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="electricpy.fault" href="fault.html">electricpy.fault</a></code></dt>
<dd>
<div class="desc"><p><code>electricpy.fault.py</code>
…</p></div>
</dd>
<dt><code class="name"><a title="electricpy.sim" href="sim.html">electricpy.sim</a></code></dt>
<dd>
<div class="desc"><p><code>electricpy.fault.py</code>
…</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="electricpy.abc_to_seq"><code class="name flex">
<span>def <span class="ident">abc_to_seq</span></span>(<span>Mabc, reference='A')</span>
</code></dt>
<dd>
<div class="desc"><p>Phase-System to Sequence-System Conversion</p>
<p>Converts phase-based values to sequence
components.</p>
<p>[
]
Same as phs_to_seq.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Mabc</code></strong> :&ensp;<code>
list</code> of <code>complex</code></dt>
<dd>Phase-based values to be converted.</dd>
<dt><strong><code>reference</code></strong> :&ensp;<code>{'A', 'B', 'C'}</code></dt>
<dd>Single character denoting the reference,
default='A'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>M012</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>Sequence-based values in order of 0-1-2</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.seq_to_abc" href="#electricpy.seq_to_abc">seq_to_abc()</a></code></dt>
<dd>Sequence to Phase Conversion</dd>
<dt><code><a title="electricpy.sequencez" href="#electricpy.sequencez">sequencez()</a></code></dt>
<dd>Phase Impedance to Sequence Converter</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abc_to_seq(Mabc,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Phase-System to Sequence-System Conversion
    
    Converts phase-based values to sequence
    components.
    
    .. math:: M_{\\text{012}}=A_{\\text{012}}\\cdot M_{\\text{ABC}}
    
    Same as phs_to_seq.
    
    Parameters
    ----------
    Mabc:       list of complex
                Phase-based values to be converted.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    
    Returns
    -------
    M012:       numpy.ndarray
                Sequence-based values in order of 0-1-2
    
    See Also
    --------
    seq_to_abc: Sequence to Phase Conversion
    sequencez:  Phase Impedance to Sequence Converter
    &#34;&#34;&#34;
    # Condition Reference:
    reference = reference.upper()
    if reference == &#39;A&#39;:
        M = Aabc
    elif reference == &#39;B&#39;:
        M = _np.roll(Aabc, 1, 0)
    elif reference == &#39;C&#39;:
        M = _np.roll(Aabc, 2, 0)
    else:
        raise ValueError(&#34;Invalid Phase Reference.&#34;)
    return(M.dot(Mabc))</code></pre>
</details>
</dd>
<dt id="electricpy.acpiv"><code class="name flex">
<span>def <span class="ident">acpiv</span></span>(<span>S=None, I=None, VLL=None, VLN=None, V=None, PF=None)</span>
</code></dt>
<dd>
<div class="desc"><p>AC Power-Voltage-Current Relation Function</p>
<p>Relationship function to return apparent power, voltage, or
current in one of various forms.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Apparent power, may be single or three-phase,
specified in volt-amps (VAs)</dd>
<dt><strong><code>I</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Phase current in amps</dd>
<dt><strong><code>VLL</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Line-to-Line voltage in volts</dd>
<dt><strong><code>VLN</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Line-to-Neutral voltage in volts</dd>
<dt><strong><code>V</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Single-phase voltage in volts</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Apparent power, returned only if one voltage
and current is specified</dd>
<dt><strong><code>I</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Phase current, returned only if one voltage
and apparent power is specified</dd>
<dt><strong><code>VLL</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Line-to-Line voltage, returned only if current
and apparent power specified, returned as set
with other voltages in form: (VLL, VLN, V)</dd>
<dt><strong><code>VLN</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Line-to-Neutral voltage, returned only if
current and apparent power specified, returned
as set with other voltages in form: (VLL, VLN, V)</dd>
<dt><strong><code>V</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Single-phase voltage, returned only if current
and apparent power specified, returned as set
with other voltages in form: (VLL, VLN, V)</dd>
<dt><strong><code>PF</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Supporting argument to convert floating-point
apparent power to complex representation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acpiv(S=None,I=None,VLL=None,VLN=None,V=None,PF=None):
    &#34;&#34;&#34;
    AC Power-Voltage-Current Relation Function
    
    Relationship function to return apparent power, voltage, or
    current in one of various forms.
    
    Parameters
    ----------
    S:          complex, optional
                Apparent power, may be single or three-phase,
                specified in volt-amps (VAs)
    I:          complex, optional
                Phase current in amps
    VLL:        complex, optional
                Line-to-Line voltage in volts
    VLN:        complex, optional
                Line-to-Neutral voltage in volts
    V:          complex, optional
                Single-phase voltage in volts
    
    Returns
    -------
    S:          complex
                Apparent power, returned only if one voltage
                and current is specified
    I:          complex
                Phase current, returned only if one voltage
                and apparent power is specified
    VLL:        complex
                Line-to-Line voltage, returned only if current
                and apparent power specified, returned as set
                with other voltages in form: (VLL, VLN, V)
    VLN:        complex
                Line-to-Neutral voltage, returned only if
                current and apparent power specified, returned
                as set with other voltages in form: (VLL, VLN, V)
    V:          complex
                Single-phase voltage, returned only if current
                and apparent power specified, returned as set
                with other voltages in form: (VLL, VLN, V)
    PF:         float, optional
                Supporting argument to convert floating-point
                apparent power to complex representation.
    &#34;&#34;&#34;
    # Validate Inputs
    if S == I == None:
        raise ValueError(&#34;To few arguments.&#34;)
    # Convert Apparent Power to Complex
    if PF != None:
        S = S*PF + 1j*_np.sqrt(S**2 - (S*PF)**2)
    # Solve Single-Phase
    if V != None:
        if S == None:   # Solve for Apparent Power
            S = V * _np.conj( I )
            return(S)
        else:           # Solve for Current
            I = _np.conj( S/V )
            return(I)
    # Solve Line-to-Line
    elif VLL != None:
        if S == None:   # Solve for Apparent Power
            S = _np.sqrt(3) * VLL * _np.conj( I )
            return(S)
        else:           # Solve for Current
            I = _np.conj( S/(_np.sqrt(3) * VLL) )
            return(I)
    # Solve Line-to-Neutral
    elif VLN != None:
        if S == None:   # Solve for Apparent Power
            S = 3 * VLN * _np.conj( I )
            return(S)
        else:           # Solve for Current
            I = _np.conj( S/(3*VLN) )
            return(I)
    # Solve for Voltages
    else:
        V = S/_np.conj( I )
        VLL = S/(_np.sqrt(3) * _np.conj( I ))
        VLN = S/(3 * _np.conj( I ))
        return(VLL,VLN,V)</code></pre>
</details>
</dd>
<dt id="electricpy.btu"><code class="name flex">
<span>def <span class="ident">btu</span></span>(<span>kWh)</span>
</code></dt>
<dd>
<div class="desc"><p>Killo-Watt-Hours to BTU Function:</p>
<p>Converts kWh (killo-Watt-hours) to BTU
(British Thermal Units).</p>
<p>[
]
Same as <code><a title="electricpy.btu" href="#electricpy.btu">kwh_to_btu()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kWh</code></strong> :&ensp;<code>
float</code></dt>
<dd>The number of killo-Watt-hours</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>BTU</code></strong> :&ensp;<code>
float</code></dt>
<dd>The number of British Thermal Units</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kwh_to_btu(kWh):
    &#34;&#34;&#34;
    Killo-Watt-Hours to BTU Function:
    
    Converts kWh (killo-Watt-hours) to BTU
    (British Thermal Units).
    
    .. math:: \\text{BTU} = \\text{kWh}\\cdot3412.14
    
    Same as `btu`.
    
    Parameters
    ----------
    kWh:        float
                The number of killo-Watt-hours
    
    Returns
    -------
    BTU:        float
                The number of British Thermal Units
    &#34;&#34;&#34;
    return(kWh*3412.14)</code></pre>
</details>
</dd>
<dt id="electricpy.btu_to_kwh"><code class="name flex">
<span>def <span class="ident">btu_to_kwh</span></span>(<span>BTU)</span>
</code></dt>
<dd>
<div class="desc"><p>BTU to Killo-Watt-Hours Function:</p>
<p>Converts BTU (British Thermal Units) to
kWh (killo-Watt-hours).</p>
<p>[
]
Same as <code><a title="electricpy.kwh" href="#electricpy.kwh">btu_to_kwh()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>BTU</code></strong> :&ensp;<code>
float</code></dt>
<dd>The number of British Thermal Units</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>kWh</code></strong> :&ensp;<code>
float</code></dt>
<dd>The number of killo-Watt-hours</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def btu_to_kwh(BTU):
    &#34;&#34;&#34;
    BTU to Killo-Watt-Hours Function:
    
    Converts BTU (British Thermal Units) to
    kWh (killo-Watt-hours).
    
    .. math:: \\text{kWh} = \\frac{\\text{BTU}}{3412.14}
    
    Same as `kwh`.
    
    Parameters
    ----------
    BTU:        float
                The number of British Thermal Units
    
    Returns
    -------
    kWh:        float
                The number of killo-Watt-hours
    &#34;&#34;&#34;
    return(BTU/3412.14)</code></pre>
</details>
</dd>
<dt id="electricpy.capbacktoback"><code class="name flex">
<span>def <span class="ident">capbacktoback</span></span>(<span>C1, C2, Lm, VLN=None, VLL=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Back to Back Capacitor Transient Current Calculator</p>
<p>Function to calculate the maximum current and the
frequency of the inrush current of two capacitors
connected in parallel when one (energized) capacitor
is switched into another (non-engergized) capacitor.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This formula is only valid for three-phase systems.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>C1</code></strong> :&ensp;<code>
float</code></dt>
<dd>The capacitance of the</dd>
<dt><strong><code>VLN</code></strong> :&ensp;<code>
float, exclusive</code></dt>
<dd>The line-to-neutral voltage experienced by
any one of the (three) capacitors in the
three-phase capacitor bank.</dd>
<dt><strong><code>VLL</code></strong> :&ensp;<code>
float, exclusive</code></dt>
<dd>The line-to-line voltage experienced by the
three-phase capacitor bank.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>imax</code></strong> :&ensp;<code>
float</code></dt>
<dd>Maximum Current Magnitude during Transient</dd>
<dt><strong><code>ifreq</code></strong> :&ensp;<code>
float</code></dt>
<dd>Transient current frequency</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capbacktoback(C1,C2,Lm,VLN=None,VLL=None):
    &#34;&#34;&#34;
    Back to Back Capacitor Transient Current Calculator
    
    Function to calculate the maximum current and the 
    frequency of the inrush current of two capacitors
    connected in parallel when one (energized) capacitor
    is switched into another (non-engergized) capacitor.
    
    .. note:: This formula is only valid for three-phase systems.
    
    Parameters
    ----------
    C1:         float
                The capacitance of the
    VLN:        float, exclusive
                The line-to-neutral voltage experienced by
                any one of the (three) capacitors in the
                three-phase capacitor bank.
    VLL:        float, exclusive
                The line-to-line voltage experienced by the
                three-phase capacitor bank.
    
    Returns
    -------
    imax:       float
                Maximum Current Magnitude during Transient
    ifreq:      float
                Transient current frequency
    &#34;&#34;&#34;
    # Evaluate Max Current
    imax = _np.sqrt(2/3)*VLL*_np.sqrt((C1*C2)/((C1+C2)*Lm))
    # Evaluate Inrush Current Frequency
    ifreq = 1/(2*_np.pi*_np.sqrt(Lm*(C1*C2)/(C1+C2)))
    return(imax,ifreq)</code></pre>
</details>
</dd>
<dt id="electricpy.capenergy"><code class="name flex">
<span>def <span class="ident">capenergy</span></span>(<span>C, v)</span>
</code></dt>
<dd>
<div class="desc"><p>Capacitor Energy Formula</p>
<p>A simple function to calculate the stored voltage (in Joules)
in a capacitor with a charged voltage.</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>
float</code></dt>
<dd>Capacitance in Farads.</dd>
<dt><strong><code>V</code></strong> :&ensp;<code>
float</code></dt>
<dd>Voltage across capacitor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>energy</code></strong> :&ensp;<code>
float</code></dt>
<dd>Energy stored in capacitor (Joules).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capenergy(C,v):
    &#34;&#34;&#34;
    Capacitor Energy Formula
    
    A simple function to calculate the stored voltage (in Joules)
    in a capacitor with a charged voltage.
    
    .. math:: E=\\frac{1}{2}*C*V^2
    
    Parameters
    ----------
    C:          float
                Capacitance in Farads.
    V:          float
                Voltage across capacitor.
    
    Returns
    -------
    energy:     float
                Energy stored in capacitor (Joules).
    &#34;&#34;&#34;
    energy = 1/2 * C * V**2
    return(energy)</code></pre>
</details>
</dd>
<dt id="electricpy.captransfer"><code class="name flex">
<span>def <span class="ident">captransfer</span></span>(<span>t, Vs, R, Cs, Cd)</span>
</code></dt>
<dd>
<div class="desc"><p>Capacitor Energy Transfer Function</p>
<p>Calculate the voltage across a joining
resistor (R) that connects Cs and Cd, the
energy-source and -destination capacitors,
respectively. Calculate the final voltage
across both capacitors.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>
float</code></dt>
<dd>Time at which to calculate resistor voltage.</dd>
<dt><strong><code>Vs</code></strong> :&ensp;<code>
float</code></dt>
<dd>Initial voltage across source-capacitor (Cs).</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>
float</code></dt>
<dd>Value of resistor that connects capacitors.</dd>
<dt><strong><code>Cs</code></strong> :&ensp;<code>
float</code></dt>
<dd>Source capacitance value in Farads.</dd>
<dt><strong><code>Cd</code></strong> :&ensp;<code>
float</code></dt>
<dd>Destination capacitance value in Farads.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rvolt</code></strong> :&ensp;<code>
float</code></dt>
<dd>Voltage across the resistor at time t.</dd>
<dt><strong><code>vfinal</code></strong> :&ensp;<code>
float</code></dt>
<dd>Final voltage that both capacitors settle to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def captransfer(t,Vs,R,Cs,Cd):
    &#34;&#34;&#34;
    Capacitor Energy Transfer Function
    
    Calculate the voltage across a joining
    resistor (R) that connects Cs and Cd, the
    energy-source and -destination capacitors,
    respectively. Calculate the final voltage
    across both capacitors.
    
    Parameters
    ----------
    t:          float
                Time at which to calculate resistor voltage.
    Vs:         float
                Initial voltage across source-capacitor (Cs).
    R:          float
                Value of resistor that connects capacitors.
    Cs:         float
                Source capacitance value in Farads.
    Cd:         float
                Destination capacitance value in Farads.
    
    Returns
    -------
    rvolt:      float
                Voltage across the resistor at time t.
    vfinal:     float
                Final voltage that both capacitors settle to.
    &#34;&#34;&#34;
    tau = (R*Cs*Cd) / (Cs+Cd)
    rvolt = Vs*_np.exp(-t/tau)
    vfinal = Vs*Cs/(Cs+Cd)
    return(rvolt,vfinal)</code></pre>
</details>
</dd>
<dt id="electricpy.characterz"><code class="name flex">
<span>def <span class="ident">characterz</span></span>(<span>R, G, L, C, freq=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Characteristic Impedance Calculator</p>
<p>Function to evaluate the characteristic
impedance of a system with specefied
line parameters as defined. System uses
the standard characteristic impedance
equation :eq:<code>Zc</code>.</p>
<p>[ :label: Zc ]
Parameters</p>
<hr>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>
float</code></dt>
<dd>Resistance in ohms.</dd>
<dt><strong><code>G</code></strong> :&ensp;<code>
float</code></dt>
<dd>Conductance in mhos (siemens).</dd>
<dt><strong><code>L</code></strong> :&ensp;<code>
float</code></dt>
<dd>Inductance in Henries.</dd>
<dt><strong><code>C</code></strong> :&ensp;<code>
float</code></dt>
<dd>Capacitance in Farads.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System frequency in Hz, default=60</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Zc</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Charcteristic Impedance of specified line.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def characterz(R,G,L,C,freq=60):
    &#34;&#34;&#34;
    Characteristic Impedance Calculator
    
    Function to evaluate the characteristic 
    impedance of a system with specefied
    line parameters as defined. System uses
    the standard characteristic impedance
    equation :eq:`Zc`.
    
    .. math:: Z_c = \\sqrt{\\frac{R+j\\omega L}{G+j\\omega C}}
       :label: Zc
    
    Parameters
    ----------
    R:          float
                Resistance in ohms.
    G:          float
                Conductance in mhos (siemens).
    L:          float
                Inductance in Henries.
    C:          float
                Capacitance in Farads.
    freq:       float, optional
                System frequency in Hz, default=60
    
    Returns
    -------
    Zc:         complex
                Charcteristic Impedance of specified line.
    &#34;&#34;&#34;
    # Evaluate omega
    w = 2*_np.pi*freq
    # Evaluate Zc
    Zc = _np.sqrt((R+1j*w*L)/(G+1j*w*C))
    return(Zc)</code></pre>
</details>
</dd>
<dt id="electricpy.clatex"><code class="name flex">
<span>def <span class="ident">clatex</span></span>(<span>val, round=3, polar=True, predollar=True, postdollar=True, double=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Complex Value Latex Generator</p>
<p>Function to generate a LaTeX string of complex value(s)
in either polar or rectangular form. May generate both dollar
signs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>val</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The complex value to be printed, if value
is a list or numpy array, the result will be
demonstrated as a matrix.</dd>
<dt><strong><code>round</code></strong> :&ensp;<code>
int</code>, optional</dt>
<dd>Control to specify number of decimal places
that should displayed. default=True</dd>
<dt><strong><code>polar</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force result into polar
coordinates instead of rectangular. default=True</dd>
<dt><strong><code>predollar</code></strong> :&ensp;<code> bool</code>, optional</dt>
<dd>Control argument to enable/disable the dollar
sign before the string. default=True</dd>
<dt><strong><code>postdollar</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Control argument to enable/disable the dollar
sign after the string. default=True</dd>
<dt><strong><code>double</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to specify whether or not
LaTeX dollar signs should be double or single,
default=False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>latex</code></strong> :&ensp;<code>
str</code></dt>
<dd>LaTeX string for the complex value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clatex(val,round=3,polar=True,predollar=True,postdollar=True,double=False):
    &#34;&#34;&#34;
    Complex Value Latex Generator
    
    Function to generate a LaTeX string of complex value(s)
    in either polar or rectangular form. May generate both dollar
    signs.
    
    Parameters
    ----------
    val:        complex
                The complex value to be printed, if value
                is a list or numpy array, the result will be
                demonstrated as a matrix.
    round:      int, optional
                Control to specify number of decimal places
                that should displayed. default=True
    polar:      bool, optional
                Control argument to force result into polar
                coordinates instead of rectangular. default=True
    predollar:  bool, optional
                Control argument to enable/disable the dollar
                sign before the string. default=True
    postdollar: bool, optional
                Control argument to enable/disable the dollar
                sign after the string. default=True
    double:     bool, optional
                Control argument to specify whether or not
                LaTeX dollar signs should be double or single,
                default=False
    
    Returns
    -------
    latex:      str
                LaTeX string for the complex value.
    &#34;&#34;&#34;
    # Define Interpretation Functions
    def polarstring( val, round ):
        mag, ang_r = _c.polar(val) #Convert to polar form
        ang = _np.degrees(ang_r) #Convert to degrees
        mag = _np.around( mag, round ) #Round
        ang = _np.around( ang, round ) #Round
        latex = str(mag) + &#39;∠&#39; + str(ang) + &#39;°&#39;
        return(latex)
    def rectstring( val, round ):
        real = _np.around( val.real, round ) #Round
        imag = _np.around( val.imag, round ) #Round
        if imag &gt; 0:
            latex = str(real) + &#34;+j&#34; + str(imag)
        else:
            latex = str(real) + &#34;-j&#34; + str(abs(imag))
        return(latex)
    # Interpret as numpy array if simple list
    if isinstance(val, list):
        val = _np.asarray(val) # Ensure that input is array
    # Find length of the input array
    if isinstance(val,_np.ndarray):
        shp = val.shape
        try:
            row, col = shp # Interpret Shape of Object
        except:
            row = shp[0]
            col = 1
        sz = val.size
        # Open Matrix
        latex = r&#39;\begin{bmatrix}&#39;
        # Iteratively Process Each Item in Array
        for ri in range(row):
            if ri != 0: # Insert Row Separator
                latex += r&#39;\\&#39;
            if col &gt; 1:
                for ci in range(col):
                    if ci != 0: # Insert Column Separator
                        latex += r&#39; &amp; &#39;
                    # Add Complex Represetation of Value
                    if polar: latex += polarstring( val[ri][ci], round )
                    else: latex += rectstring( val[ri][ci], round )
            else:
                # Add Complex Represetation of Value
                if polar: latex += polarstring( val[ri], round )
                else: latex += rectstring( val[ri], round )
        # Close Matrix
        latex += r&#39;\end{bmatrix}&#39;
    elif isinstance(val, complex):
        # Treat as Polar When Directed
        if polar:
            latex = polarstring( val, round )
        else:
            latex = rectstring( val, round )
    else:
        raise ValueError(&#34;Invalid Input Type&#34;)
    # Add Dollar Sign pre-post
    if double:
        dollar = r&#39;$$&#39;
    else:
        dollar = r&#39;$&#39;
    if predollar:
        latex = dollar + latex
    if postdollar:
        latex = latex + dollar
    return( latex )</code></pre>
</details>
</dd>
<dt id="electricpy.coldjunction"><code class="name flex">
<span>def <span class="ident">coldjunction</span></span>(<span>Tcj, coupletype='K', To=None, Vo=None, P1=None, P2=None, P3=None, P4=None, Q1=None, Q2=None, round=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Thermocouple Cold-Junction Formula</p>
<p>Function to calculate the expected cold-junction-voltage given
the temperature at the cold-junction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Tcj</code></strong> :&ensp;<code>
float</code></dt>
<dd>The temperature (in degrees C) that the junction is
currently subjected to.</dd>
<dt><strong><code>coupletype</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Thermocouple Type, may be one of (B,E,J,K,N,R,S,T), default="K"</dd>
<dt><strong><code>To</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Temperature Constant used in Polynomial.</dd>
<dt><strong><code>Vo</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Voltage Constant used in Polynomial.</dd>
<dt><strong><code>P1</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Polynomial constant.</dd>
<dt><strong><code>P2</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Polynomial constant.</dd>
<dt><strong><code>P3</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Polynomial constant.</dd>
<dt><strong><code>P4</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Polynomial constant.</dd>
<dt><strong><code>Q1</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Polynomial constant.</dd>
<dt><strong><code>Q2</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Polynomial constant.</dd>
<dt><strong><code>Q3</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Polynomial constant.</dd>
<dt><strong><code>round</code></strong> :&ensp;<code>
int</code>, optional</dt>
<dd>Control input to specify how many decimal places the result
should be rounded to, default=1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Vcj</code></strong> :&ensp;<code>
float</code></dt>
<dd>The calculated cold-junction-voltage in volts.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coldjunction(Tcj,coupletype=&#34;K&#34;,To=None,Vo=None,P1=None,P2=None,
                 P3=None,P4=None,Q1=None,Q2=None,round=None):
    &#34;&#34;&#34;
    Thermocouple Cold-Junction Formula
    
    Function to calculate the expected cold-junction-voltage given
    the temperature at the cold-junction.
    
    Parameters
    ----------
    Tcj:        float
                The temperature (in degrees C) that the junction is
                currently subjected to.
    coupletype: string, optional
                Thermocouple Type, may be one of (B,E,J,K,N,R,S,T), default=&#34;K&#34;
    To:         float, optional
                Temperature Constant used in Polynomial.
    Vo:         float, optional
                Voltage Constant used in Polynomial.
    P1:         float, optional
                Polynomial constant.
    P2:         float, optional
                Polynomial constant.
    P3:         float, optional
                Polynomial constant.
    P4:         float, optional
                Polynomial constant.
    Q1:         float, optional
                Polynomial constant.
    Q2:         float, optional
                Polynomial constant.
    Q3:         float, optional
                Polynomial constant.
    round:      int, optional
                Control input to specify how many decimal places the result
                should be rounded to, default=1.
    
    Returns
    -------
    Vcj:        float
                The calculated cold-junction-voltage in volts.
    &#34;&#34;&#34;
    # Condition Inputs
    coupletype = coupletype.upper()
    # Validate Temperature Range
    if coupletype == &#34;B&#34;:
        if not (0 &lt; Tcj and Tcj &lt; 70):
            raise ValueError(&#34;Temperature out of range.&#34;)
    else:
        if not (-20 &lt; Tcj and Tcj &lt; 70):
            raise ValueError(&#34;Temperature out of range.&#34;)
    # Define Constant Lookup System
    lookup = [&#34;B&#34;,&#34;E&#34;,&#34;J&#34;,&#34;K&#34;,&#34;N&#34;,&#34;R&#34;,&#34;S&#34;,&#34;T&#34;]
    if not (coupletype in lookup):
        raise ValueError(&#34;Invalid Thermocouple Type&#34;)
    index = lookup.index(coupletype)
    # Define Constant Dictionary
    constants = {   &#34;To&#34; : [4.2000000E+01,2.5000000E+01,2.5000000E+01,2.5000000E+01,7.0000000E+00,2.5000000E+01,2.5000000E+01,2.5000000E+01],
                    &#34;Vo&#34; : [3.3933898E-04,1.4950582E+00,1.2773432E+00,1.0003453E+00,1.8210024E-01,1.4067016E-01,1.4269163E-01,9.9198279E-01],
                    &#34;P1&#34; : [2.1196684E-04,6.0958443E-02,5.1744084E-02,4.0514854E-02,2.6228256E-02,5.9330356E-03,5.9829057E-03,4.0716564E-02],
                    &#34;P2&#34; : [3.3801250E-06,-2.7351789E-04,-5.4138663E-05,-3.8789638E-05,-1.5485539E-04,2.7736904E-05,4.5292259E-06,7.1170297E-04],
                    &#34;P3&#34; : [-1.4793289E-07,-1.9130146E-05,-2.2895769E-06,-2.8608478E-06,2.1366031E-06,-1.0819644E-06,-1.3380281E-06,6.8782631E-07],
                    &#34;P4&#34; : [-3.3571424E-09,-1.3948840E-08,-7.7947143E-10,-9.5367041E-10,9.2047105E-10,-2.3098349E-09,-2.3742577E-09,4.3295061E-11],
                    &#34;Q1&#34; : [-1.0920410E-02,-5.2382378E-03,-1.5173342E-03,-1.3948675E-03,-6.4070932E-03,2.6146871E-03,-1.0650446E-03,1.6458102E-02],
                    &#34;Q2&#34; : [-4.9782932E-04,-3.0970168E-04,-4.2314514E-05,-6.7976627E-05,8.2161781E-05,-1.8621487E-04,-2.2042420E-04,0.0000000E+00]
                }
    # Load Data Into Terms
    if To == None:
        To = constants[&#34;To&#34;][index]
    if Vo == None:
        Vo = constants[&#34;Vo&#34;][index]
    if P1 == None:
        P1 = constants[&#34;P1&#34;][index]
    if P2 == None:
        P2 = constants[&#34;P2&#34;][index]
    if P3 == None:
        P3 = constants[&#34;P3&#34;][index]
    if P4 == None:
        P4 = constants[&#34;P4&#34;][index]
    if Q1 == None:
        Q1 = constants[&#34;Q1&#34;][index]
    if Q2 == None:
        Q2 = constants[&#34;Q2&#34;][index]
    # Define Formula Terms
    tx = (Tcj-To)
    num = tx*(P1+tx*(P2+tx*(P3+P4*tx)))
    den = 1+tx*(Q1+Q2*tx)
    Vcj = Vo + num/den
    # Round Value if Allowed
    if round != None:
        Vcj = _np.around(Vcj, round)
    # Return in milivolts
    return(Vcj*m)</code></pre>
</details>
</dd>
<dt id="electricpy.compose"><code class="name flex">
<span>def <span class="ident">compose</span></span>(<span>*arr)</span>
</code></dt>
<dd>
<div class="desc"><p>Complex Composition Function</p>
<p>Accepts a set of real values and generates an array
of complex values. Input must be array-like, but can
appear in various forms:</p>
<ul>
<li>[ real, imag]</li>
<li>[ [ real1, &hellip;, realn ], [ imag1, &hellip;, imagn ] ]</li>
<li>[ [ real1, imag1 ], &hellip;, [ realn, imagn ] ]</li>
</ul>
<p>Will always return values in form:</p>
<p>[ complex1, &hellip; complexn ]</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>
array_like</code></dt>
<dd>The input of real and imaginary term(s)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compose(*arr):
    &#34;&#34;&#34;
    Complex Composition Function
    
    Accepts a set of real values and generates an array
    of complex values. Input must be array-like, but can
    appear in various forms:
    
    - [ real, imag]
    - [ [ real1, ..., realn ], [ imag1, ..., imagn ] ]
    - [ [ real1, imag1 ], ..., [ realn, imagn ] ]
    
    Will always return values in form:
    
    [ complex1, ... complexn ]
    
    Parameters
    ----------
    arr:        array_like
                The input of real and imaginary term(s)
    &#34;&#34;&#34;
    # Condition Input
    if len(arr) == 1:
        arr = arr[0] # Extract 0-th term
    # Input comes in various forms, we must first detect shape
    arr = _np.asarray( arr ) # Format as Numpy Array
    # Gather Shape to Detect Format
    try:
        row, col = arr.shape
        # Passed Test, Valid Shape
        retarr = _np.array([]) # Empty Return Array
        # Now, Determine whether is type 2 or 3
        if col == 2: # Type 3
            for i in range(row): # Iterate over each row
                item = arr[i][0] + 1j*arr[i][1]
                retarr = _np.append(retarr, item)
        elif row == 2: # Type 2
            for i in range(col): # Iterate over each column
                item = arr[0][i] + 1j*arr[1][i]
                retarr = _np.append(retarr, item)
        else:
            raise ValueError(&#34;Invalid Array Shape, must be 2xN or Nx2.&#34;)
        # Successfully Generated Array, Return
        return( retarr )
    except: # 1-Dimension Array
        length = arr.size
        # Test for invalid Array Size
        if length != 2:
            raise ValueError(&#34;Invalid Array Size, Saw Length of &#34;+str(length))
        # Valid Size, Calculate and Return
        return( arr[0] + 1j*arr[1] )</code></pre>
</details>
</dd>
<dt id="electricpy.convbar"><code class="name flex">
<span>def <span class="ident">convbar</span></span>(<span>h, x, outline=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Convolution Bar-Graph Plotter Function</p>
<p>Generates plots of each of two input arrays as bar-graphs, then
generates a convolved bar-graph of the two inputs to demonstrate
and illustrate convolution, typically for an educational purpose.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>h</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>Impulse Response - Given as Array (Prefferably Numpy Array)</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>Input Function - Given as Array (Prefferably Numpy Array)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convbar(h, x, outline=True):
    &#34;&#34;&#34;
    Convolution Bar-Graph Plotter Function
    
    Generates plots of each of two input arrays as bar-graphs, then
    generates a convolved bar-graph of the two inputs to demonstrate
    and illustrate convolution, typically for an educational purpose.
    
    Parameters
    ----------
    h:      numpy.ndarray
            Impulse Response - Given as Array (Prefferably Numpy Array)
    x:      numpy.ndarray
            Input Function - Given as Array (Prefferably Numpy Array)
    &#34;&#34;&#34;
    
    # The impulse response
    M = len(h)
    t = _np.arange(M)
    # Plot
    _plt.subplot(121)
    if(outline): _plt.plot(t,h,color=&#39;red&#39;)
    _plt.bar(t,h,color=&#39;black&#39;)
    _plt.xticks([0,5,9])
    _plt.ylabel(&#39;h&#39;)
    _plt.title(&#39;Impulse Response&#39;)
    _plt.grid()

    # The input function
    N = len(x)
    s = _np.arange(N)
    # Plot
    _plt.subplot(122)
    if(outline): _plt.plot(s,x,color=&#39;red&#39;)
    _plt.bar(s,x,color=&#39;black&#39;)
    _plt.xticks([0,10,19])
    _plt.title(&#39;Input Function&#39;)
    _plt.grid()
    _plt.ylabel(&#39;x&#39;)

    # The output
    L = M+N-1
    w = _np.arange(L)
    _plt.figure(3)
    y = _np.convolve(h,x)
    if(outline): _plt.plot(w,y,color=&#39;red&#39;)
    _plt.bar(w,y,color=&#39;black&#39;)
    _plt.ylabel(&#39;y&#39;)
    _plt.grid()
    _plt.title(&#39;Convolved Output&#39;)
    _plt.show()</code></pre>
</details>
</dd>
<dt id="electricpy.convolve"><code class="name flex">
<span>def <span class="ident">convolve</span></span>(<span>tuple)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter Convolution Function</p>
<p>Given a tuple of terms, convolves all terms in tuple to
return one tuple as a numpy array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tuple</code></strong> :&ensp;<code>
tuple</code> of <code>numpy.ndarray</code></dt>
<dd>Tuple of terms to be convolved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>c:
The convolved set of the individual terms.
i.e. numpy.ndarray([ x1, x2, x3, &hellip;, xn ])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convolve(tuple):
    &#34;&#34;&#34;
    Filter Convolution Function
    
    Given a tuple of terms, convolves all terms in tuple to
    return one tuple as a numpy array.
    
    Parameters
    ---------
    tuple:      tuple of numpy.ndarray
                Tuple of terms to be convolved.
    
    Returns
    -------
    c:          The convolved set of the individual terms.
                i.e. numpy.ndarray([ x1, x2, x3, ..., xn ])
    &#34;&#34;&#34;
    c = sig.convolve(tuple[0],tuple[1])
    if (len(tuple) &gt; 2):
        # Iterate starting with second element and continuing
        for i in range(2,len(tuple)):
            c = sig.convolve(c,tuple[i])
    return(c)</code></pre>
</details>
</dd>
<dt id="electricpy.cosfilt"><code class="name flex">
<span>def <span class="ident">cosfilt</span></span>(<span>arr, Srate, domain=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Cosine Filter Function</p>
<p>Cosine Filter function for filtering a dataset
representing a sinusoidal function with or without
harmonics to evaluate the fundamental value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>The input data array.</dd>
<dt><strong><code>Srate</code></strong> :&ensp;<code>
int</code></dt>
<dd>Sampling rate for dataset, specified in
number of values per fundamental cycle.</dd>
<dt><strong><code>domain</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force return of
x-axis array for the filtered data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cosf</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>Cosine-filtered data</dd>
<dt><strong><code>xarray</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>X-axis array for the filtered data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cosfilt(arr,Srate,domain=False):
    &#34;&#34;&#34;
    Cosine Filter Function
    
    Cosine Filter function for filtering a dataset
    representing a sinusoidal function with or without
    harmonics to evaluate the fundamental value.
    
    Parameters
    ----------
    arr:        numpy.ndarray
                The input data array.
    Srate:      int
                Sampling rate for dataset, specified in
                number of values per fundamental cycle.
    domain:     bool, optional
                Control argument to force return of
                x-axis array for the filtered data.
    
    Returns
    -------
    cosf:       numpy.ndarray
                Cosine-filtered data
    xarray:     numpy.ndarray
                X-axis array for the filtered data.
    &#34;&#34;&#34;
    # Evaluate index set
    ind = _np.arange(Srate-1, len(arr)-1)
    # Define Cosine Coefficient Function
    def cos(k,Srate):
        return(_np.cos(2*_np.pi*k/Srate))
    # Calculate Constant
    const = 2/Srate
    # Iteratively Calculate
    cosf = 0
    for k in range(0,Srate-1):
        slc = (ind-(Srate-1))+k
        cosf += cos(k,Srate) * arr[slc]
    # Scale
    cosf = const * cosf
    # Return Cosine-Filtered Array
    if domain:
        xarray = _np.linspace(Srate+Srate/4-1,len(arr)-1,len(cosf))
        xarray = xarray / Srate
        return(cosf,xarray)
    return(cosf)</code></pre>
</details>
</dd>
<dt id="electricpy.cprint"><code class="name flex">
<span>def <span class="ident">cprint</span></span>(<span>val, unit=None, label=None, title=None, pretty=True, printval=True, ret=False, round=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Phasor (Complex) Printing Function</p>
<p>This function is designed to accept a complex value (val) and print
the value in the standard electrical engineering notation:</p>
<p><strong>magnitude ∠ angle °</strong></p>
<p>This function will print the magnitude in degrees, and can print
a unit and label in addition to the value itself.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>val</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The Complex Value to be Printed, may be singular value,
tuple of values, or list/array.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>
string</code>, optional</dt>
<dd>The string to be printed corresponding to the unit mark.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>
str</code>, optional</dt>
<dd>The pre-pended string used as a descriptive labeling string.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>
str</code>, optional</dt>
<dd>The pre-pended string describing a set of complex values.</dd>
<dt><strong><code>pretty</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force printed result to a <em>pretty</em>
format without array braces. default=True</dd>
<dt><strong><code>printval</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument enabling/disabling printing of the string.
default=True</dd>
<dt><strong><code>ret</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument allowing the evaluated value to be returned.
default=False</dd>
<dt><strong><code>round</code></strong> :&ensp;<code>
int</code>, optional</dt>
<dd>Control argument specifying how many decimals of the complex
value to be printed. May be negative to round to spaces
to the left of the decimal place (follows standard round()
functionality). default=3</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>numarr</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>The array of values corresponding to the magnitude and angle,
values are returned in the form: [[ mag, ang ],&hellip;,[ mag, ang ]]
where the angles are evaluated in degrees.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; import electricpy as ep
&gt;&gt;&gt; v = ep.phasor(67, 120)
&gt;&gt;&gt; ep.cprint(v)
67.0 ∠ 120.0°
&gt;&gt;&gt; voltages = _np.array([[67,0],
                         [67,-120],
                         [67,120]])
&gt;&gt;&gt; Vset = ep.phasorlist( voltages )
&gt;&gt;&gt; ep.cprint(Vset)
[['67.0 ∠ 0.0°']
['67.0 ∠ -120.0°']
['67.0 ∠ 120.0°']]
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.phasor" href="#electricpy.phasor">phasor()</a></code></dt>
<dd>Phasor Generating Function</dd>
<dt><code><a title="electricpy.phasorlist" href="#electricpy.phasorlist">phasorlist()</a></code></dt>
<dd>Phasor Generating Function for Lists or Arrays</dd>
<dt><code><a title="electricpy.phasorz" href="#electricpy.phasorz">phasorz()</a></code></dt>
<dd>Impedance Phasor Generator</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cprint(val,unit=None,label=None,title=None,
           pretty=True,printval=True,ret=False,round=3):
    &#34;&#34;&#34;
    Phasor (Complex) Printing Function
    
    This function is designed to accept a complex value (val) and print
    the value in the standard electrical engineering notation:
    
    **magnitude ∠ angle °**
    
    This function will print the magnitude in degrees, and can print
    a unit and label in addition to the value itself.
    
    Parameters
    ----------
    val:        complex
                The Complex Value to be Printed, may be singular value,
                tuple of values, or list/array.
    unit:       string, optional
                The string to be printed corresponding to the unit mark.
    label:      str, optional
                The pre-pended string used as a descriptive labeling string.
    title:      str, optional
                The pre-pended string describing a set of complex values.
    pretty:     bool, optional
                Control argument to force printed result to a *pretty*
                format without array braces. default=True
    printval:   bool, optional
                Control argument enabling/disabling printing of the string.
                default=True
    ret:        bool, optional
                Control argument allowing the evaluated value to be returned.
                default=False
    round:      int, optional
                Control argument specifying how many decimals of the complex
                value to be printed. May be negative to round to spaces
                to the left of the decimal place (follows standard round()
                functionality). default=3
    
    Returns
    -------
    numarr:     numpy.ndarray
                The array of values corresponding to the magnitude and angle,
                values are returned in the form: [[ mag, ang ],...,[ mag, ang ]]
                where the angles are evaluated in degrees.
    
    Examples
    --------
    &gt;&gt;&gt; import electricpy as ep
    &gt;&gt;&gt; v = ep.phasor(67, 120)
    &gt;&gt;&gt; ep.cprint(v)
    67.0 ∠ 120.0°
    &gt;&gt;&gt; voltages = _np.array([[67,0],
                             [67,-120],
                             [67,120]])
    &gt;&gt;&gt; Vset = ep.phasorlist( voltages )
    &gt;&gt;&gt; ep.cprint(Vset)
    [[&#39;67.0 ∠ 0.0°&#39;]
    [&#39;67.0 ∠ -120.0°&#39;]
    [&#39;67.0 ∠ 120.0°&#39;]]

    
    See Also
    --------
    phasor:     Phasor Generating Function
    phasorlist: Phasor Generating Function for Lists or Arrays
    phasorz:    Impedance Phasor Generator
    &#34;&#34;&#34;
    # Interpret as numpy array if simple list
    if isinstance(val, list):
        val = _np.asarray(val) # Ensure that input is array
    # Find length of the input array
    if isinstance(val,_np.ndarray):
        shp = val.shape
        try:
            row, col = shp # Interpret Shape of Object
        except:
            row = shp[0]
            col = 1
        sz = val.size
        # Handle Label as a List or Array
        if isinstance(label, (list,_np.ndarray)):
            if len(label)==1:
                tmp = label
                for _ in range(sz):
                    label = _np.append(label,[tmp])
            elif sz != len(label):
                raise ValueError(&#34;Too Few Label Arguments&#34;)
        # Handle Label as String
        elif isinstance(label, str):
            tmp = label
            for _ in range(sz):
                label = _np.append(label,[tmp])
        # Handle Lack of Label
        elif label == None:
            label = _np.array([])
            for _ in range(sz):
                label = _np.append(label,None)
        # Handle all Other Cases
        else:
            raise ValueError(&#34;Invalid Label&#34;)
        # Handle Unit as a List or Array
        if isinstance(unit, (list,_np.ndarray)):
            if len(unit)==1:
                tmp = unit
                for _ in range(sz):
                    unit = _np.append(unit,[tmp])
            elif sz != len(unit):
                raise ValueError(&#34;Too Few Unit Arguments&#34;)
        # Handle Unit as String
        elif isinstance(unit, str):
            tmp = unit
            for _ in range(sz):
                unit = _np.append(unit,[tmp])
        # Handle Lack of Unit
        elif unit == None:
            unit = _np.array([])
            for _ in range(sz):
                unit = _np.append(unit,None)
        # Handle all Other Cases
        else:
            raise ValueError(&#34;Invalid Unit&#34;)
        # Generate Default Arrays
        printarr = _np.array([]) # Empty array
        numarr = _np.array([]) # Empty array
        # Operate on List/Array
        for i in range(row):
            _val = val[i]
            _label = label[i]
            _unit = unit[i]
            mag, ang_r = _c.polar(_val) #Convert to polar form
            ang = _np.degrees(ang_r) #Convert to degrees
            mag = _np.around( mag, round ) #Round
            ang = _np.around( ang, round ) #Round
            strg = &#34;&#34;
            if _label != None:
                strg += _label + &#34; &#34;
            strg += str(mag)+&#34; ∠ &#34;+str(ang)+&#34;°&#34;
            if _unit != None:
                strg += &#34; &#34; + _unit
            printarr = _np.append(printarr, strg)
            numarr = _np.append(numarr, [mag, ang])
        # Reshape Arrays
        printarr = _np.reshape(printarr, (row,col))
        numarr = _np.reshape(numarr, (sz, 2))
        # Print
        if printval and row==1:
            if title != None:
                print(title)
            print(strg)
        elif printval and pretty:
            strg = &#39;&#39;
            start = True
            for i in printarr:
                if not start:
                    strg += &#39;\n&#39;
                strg += str(i[0])
                start = False
            if title != None:
                print(title)
            print(strg)
        elif printval:
            if title != None:
                print(title)
            print(printarr)
        # Return if Necessary
        if ret:
            return(numarr)
    elif isinstance(val, (int,float,complex)):
        # Handle Invalid Unit/Label
        if unit != None and not isinstance(unit, str):
            raise ValueError(&#34;Invalid Unit Type for Value&#34;)
        if label != None and not isinstance(label, str):
            raise ValueError(&#34;Invalid Label Type for Value&#34;)
        mag, ang_r = _c.polar(val) #Convert to polar form
        ang = _np.degrees(ang_r) #Convert to degrees
        mag = _np.around( mag, round ) #Round
        ang = _np.around( ang, round ) #Round
        strg = &#34;&#34;
        if label != None:
            strg += label + &#34; &#34;
        strg += str(mag)+&#34; ∠ &#34;+str(ang)+&#34;°&#34;
        if unit != None:
            strg += &#34; &#34; + unit
        # Print values (by default)
        if printval:
            if title != None:
                print(title)
            print(strg)
        # Return values when requested
        if ret:
            return([mag, ang])
    else:
        raise ValueError(&#34;Invalid Input Type&#34;)</code></pre>
</details>
</dd>
<dt id="electricpy.crcremainder"><code class="name flex">
<span>def <span class="ident">crcremainder</span></span>(<span>data, key)</span>
</code></dt>
<dd>
<div class="desc"><p>CRC Remainder Function</p>
<p>Function to calculate the CRC
remainder of a CRC message.</p>
<p>Contributing Author Credit:
Shaurya Uppal
Available from: geeksforgeeks.org</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>
string</code> of <code>bits</code></dt>
<dd>The bit-string to be decoded.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>
string</code> of <code>bits</code></dt>
<dd>Bit-string representing key.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>remainder</code></strong> :&ensp;<code>string</code> of <code>bits</code></dt>
<dd>Bit-string representation of
encoded message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crcremainder(data, key):
    &#34;&#34;&#34;
    CRC Remainder Function
    
    Function to calculate the CRC
    remainder of a CRC message.
    
    Contributing Author Credit:
    Shaurya Uppal
    Available from: geeksforgeeks.org
    
    Parameters
    ----------
    data:       string of bits
                The bit-string to be decoded.
    key:        string of bits
                Bit-string representing key.
    
    Returns
    -------
    remainder: string of bits
                Bit-string representation of
                encoded message.
    &#34;&#34;&#34;
    # Define Sub-Functions
    def xor(a, b): 
        # initialize result 
        result = [] 

        # Traverse all bits, if bits are 
        # same, then XOR is 0, else 1 
        for i in range(1, len(b)): 
            if a[i] == b[i]: 
                result.append(&#39;0&#39;) 
            else: 
                result.append(&#39;1&#39;) 

        return(&#39;&#39;.join(result))

    # Performs Modulo-2 division 
    def mod2div(divident, divisor):
        # Number of bits to be XORed at a time. 
        pick = len(divisor) 

        # Slicing the divident to appropriate 
        # length for particular step 
        tmp = divident[0 : pick] 

        while pick &lt; len(divident): 

            if tmp[0] == &#39;1&#39;: 

                # replace the divident by the result 
                # of XOR and pull 1 bit down 
                tmp = xor(divisor, tmp) + divident[pick] 

            else:   # If leftmost bit is &#39;0&#39; 

                # If the leftmost bit of the dividend (or the 
                # part used in each step) is 0, the step cannot 
                # use the regular divisor; we need to use an 
                # all-0s divisor. 
                tmp = xor(&#39;0&#39;*pick, tmp) + divident[pick] 

            # increment pick to move further 
            pick += 1

        # For the last n bits, we have to carry it out 
        # normally as increased value of pick will cause 
        # Index Out of Bounds. 
        if tmp[0] == &#39;1&#39;: 
            tmp = xor(divisor, tmp) 
        else: 
            tmp = xor(&#39;0&#39;*pick, tmp) 

        checkword = tmp 
        return(checkword)
    
    # Condition data
    data = str(data)
    # Condition Key
    key = str(key)
    l_key = len(key)
   
    # Appends n-1 zeroes at end of data 
    appended_data = data + &#39;0&#39;*(l_key-1) 
    remainder = mod2div(appended_data, key) 
   
    return(remainder)</code></pre>
</details>
</dd>
<dt id="electricpy.crcsender"><code class="name flex">
<span>def <span class="ident">crcsender</span></span>(<span>data, key)</span>
</code></dt>
<dd>
<div class="desc"><p>CRC Sender Function</p>
<p>Function to generate a CRC-embedded
message ready for transmission.</p>
<p>Contributing Author Credit:
Shaurya Uppal
Available from: geeksforgeeks.org</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>
string</code> of <code>bits</code></dt>
<dd>The bit-string to be encoded.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>
string</code> of <code>bits</code></dt>
<dd>Bit-string representing key.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>codeword</code></strong> :&ensp;<code>
string</code> of <code>bits</code></dt>
<dd>Bit-string representation of
encoded message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crcsender(data, key):
    &#34;&#34;&#34;
    CRC Sender Function
    
    Function to generate a CRC-embedded
    message ready for transmission.
    
    Contributing Author Credit:
    Shaurya Uppal
    Available from: geeksforgeeks.org
    
    Parameters
    ----------
    data:       string of bits
                The bit-string to be encoded.
    key:        string of bits
                Bit-string representing key.
    
    Returns
    -------
    codeword:   string of bits
                Bit-string representation of
                encoded message.
    &#34;&#34;&#34;
    # Define Sub-Functions
    def xor(a, b): 
        # initialize result 
        result = [] 

        # Traverse all bits, if bits are 
        # same, then XOR is 0, else 1 
        for i in range(1, len(b)): 
            if a[i] == b[i]: 
                result.append(&#39;0&#39;) 
            else: 
                result.append(&#39;1&#39;) 

        return(&#39;&#39;.join(result))

    # Performs Modulo-2 division 
    def mod2div(divident, divisor):
        # Number of bits to be XORed at a time. 
        pick = len(divisor) 

        # Slicing the divident to appropriate 
        # length for particular step 
        tmp = divident[0 : pick] 

        while pick &lt; len(divident): 

            if tmp[0] == &#39;1&#39;: 

                # replace the divident by the result 
                # of XOR and pull 1 bit down 
                tmp = xor(divisor, tmp) + divident[pick] 

            else:   # If leftmost bit is &#39;0&#39; 

                # If the leftmost bit of the dividend (or the 
                # part used in each step) is 0, the step cannot 
                # use the regular divisor; we need to use an 
                # all-0s divisor. 
                tmp = xor(&#39;0&#39;*pick, tmp) + divident[pick] 

            # increment pick to move further 
            pick += 1

        # For the last n bits, we have to carry it out 
        # normally as increased value of pick will cause 
        # Index Out of Bounds. 
        if tmp[0] == &#39;1&#39;: 
            tmp = xor(divisor, tmp) 
        else: 
            tmp = xor(&#39;0&#39;*pick, tmp) 

        checkword = tmp 
        return(checkword)
    
    # Condition data
    data = str(data)
    # Condition Key
    key = str(key)
    l_key = len(key)
   
    # Appends n-1 zeroes at end of data 
    appended_data = data + &#39;0&#39;*(l_key-1) 
    remainder = mod2div(appended_data, key) 
   
    # Append remainder in the original data 
    codeword = data + remainder 
    return(codeword)</code></pre>
</details>
</dd>
<dt id="electricpy.curdiv"><code class="name flex">
<span>def <span class="ident">curdiv</span></span>(<span>Ri, Rset, Vin=None, Iin=None, Vout=False, combine=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Current Divider Function</p>
<p>This function is disigned to accept the input current, or input
voltage to a resistor (or impedance) network of parallel resistors
(impedances) and calculate the current through a particular element.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Ri</code></strong> :&ensp;<code>
float</code></dt>
<dd>The Particular Resistor of Interest, should not be included in
the tuple passed to Rset.</dd>
<dt><strong><code>Rset</code></strong> :&ensp;<code>
float</code></dt>
<dd>Tuple of remaining resistances (impedances) in network.</dd>
<dt><strong><code>Vin</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The input voltage for the system, default=None</dd>
<dt><strong><code>Iin</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The input current for the system, default=None</dd>
<dt><strong><code>Vout</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to enable return of the voltage across the
resistor (impedance) of interest (Ri)</dd>
<dt><strong><code>combine</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force resistance combination. default=True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Opt1 - Ii:
The Current through the resistor (impedance)</code> of <code>interest</code></dt>
<dd>&nbsp;</dd>
<dt><code>Opt2 - (Ii,Vi):
The afore mentioned current, and voltage across the</code></dt>
<dd>resistor (impedance) of interest</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curdiv(Ri,Rset,Vin=None,Iin=None,Vout=False,combine=True):
    &#34;&#34;&#34;
    Current Divider Function
    
    This function is disigned to accept the input current, or input
    voltage to a resistor (or impedance) network of parallel resistors
    (impedances) and calculate the current through a particular element.
    
    Parameters
    ----------
    Ri:         float
                The Particular Resistor of Interest, should not be included in
                the tuple passed to Rset.
    Rset:       float
                Tuple of remaining resistances (impedances) in network.
    Vin:        float, optional
                The input voltage for the system, default=None
    Iin:        float, optional
                The input current for the system, default=None
    Vout:       bool, optional
                Control argument to enable return of the voltage across the
                resistor (impedance) of interest (Ri)
    combine:    bool, optional
                Control argument to force resistance combination. default=True
    
    Returns
    -------
    Opt1 - Ii:          The Current through the resistor (impedance) of interest
    Opt2 - (Ii,Vi):     The afore mentioned current, and voltage across the
                        resistor (impedance) of interest
    &#34;&#34;&#34;
    # Validate Tuple
    if not isinstance(Rset,tuple):
        Rset = (Rset,) # Set as Tuple
    # Calculate The total impedance
    if combine:
        Rtot = parallelz( Rset + (Ri,) ) # Combine tuples, then calculate total resistance
    else:
        Rtot = parallelz( Rset )
    # Determine Whether Input was given as Voltage or Current
    if(Vin!=None and Iin==None): # Vin Provided
        Iin = Vin / Rtot # Calculate total current
        Ii = Iin * Rtot/Ri # Calculate the current of interest
    elif(Vin==None and Iin!=None): # Iin provided
        Ii = Iin * Rtot/Ri # Calculate the current of interest
    else:
        raise ValueError(&#34;ERROR: Too many or too few constraints provided.&#34;)
    if(Vout): # Asked for voltage across resistor of interest
        Vi = Ii * Ri
        return(Ii, Vi)
    else:
        return(Ii)</code></pre>
</details>
</dd>
<dt id="electricpy.de_calc"><code class="name flex">
<span>def <span class="ident">de_calc</span></span>(<span>rho, freq=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculator for De Transmission Line Value</p>
<p>Simple calculator to find the De value for a line
with particular earth resistivity (rho).</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>rho</code></strong> :&ensp;<code>
float</code></dt>
<dd>Earth resistivity (in ohm-meters), may also
be passed a string in the set: {SEA, SWAMP,
AVG,AVERAGE,DAMP,DRY,SAND,SANDSTONE}</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System frequency in Hertz, default=60</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def de_calc(rho,freq=60):
    &#34;&#34;&#34;
    Calculator for De Transmission Line Value
    
    Simple calculator to find the De value for a line
    with particular earth resistivity (rho).
    
    .. math:: D_e=D_{e_{\\text{constant}}}\\sqrt{\\frac{\\rho}{freq}}
    
    Parameters
    ----------
    rho:        float
                Earth resistivity (in ohm-meters), may also
                be passed a string in the set: {SEA, SWAMP,
                AVG,AVERAGE,DAMP,DRY,SAND,SANDSTONE}
    freq:       float, optional
                System frequency in Hertz, default=60
    &#34;&#34;&#34;
    # If Descriptive String Provided, Use to Determine Rho
    if isinstance(rho,str):
        rho = rho.upper()
        rho = { &#39;SEA&#39;:          0.01,
                &#39;SWAMP&#39;:        10,
                &#39;AVG&#39;:          100,
                &#39;AVERAGE&#39;:      100,
                &#39;DAMP&#39;:         100,
                &#39;DRY&#39;:          1000,
                &#39;SAND&#39;:         1E9,
                &#39;SANDSTONE&#39;:    1E9,
              }[rho]
    # Calculate De
    De = De0 * _np.sqrt( rho / freq )
    return(De)</code></pre>
</details>
</dd>
<dt id="electricpy.dynetz"><code class="name flex">
<span>def <span class="ident">dynetz</span></span>(<span>delta=None, wye=None, round=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Delta-Wye Impedance Converter</p>
<p>This function is designed to act as the conversion utility
to transform delta-connected impedance values to wye-
connected and vice-versa.</p>
<p>[ Z_{sum} = Z_{1/2} + Z_{2/3} + Z_{3/1}//
Z_1 = \frac{Z_{1/2}<em>Z_{3/1}}{Z_{sum}}//
Z_2 = \frac{Z_{1/2}</em>Z_{2/3}}{Z_{sum}}//
Z_3 = \frac{Z_{2/3}<em>Z_{3/1}}{Z_{sum}} ]
[ Z_{ms} = Z_1</em>Z_2 + Z_2<em>Z_3 + Z_3</em>Z_1//
Z_{2/3} = \frac{Z_{ms}}{Z_1}//
Z_{3/1} = \frac{Z_{ms}}{Z_2}//
Z_{1/2} = \frac{Z_{ms}}{Z_3} ]
Parameters</p>
<hr>
<dl>
<dt><strong><code>delta</code></strong> :&ensp;<code> tuple</code> of <code>float, exclusive</code></dt>
<dd>Tuple of the delta-connected impedance values as:
{ Z12, Z23, Z31 }, default=None</dd>
<dt><strong><code>wye</code></strong> :&ensp;<code>
tuple</code> of <code>float, exclusive</code></dt>
<dd>Tuple of the wye-connected impedance valuse as:
{ Z1, Z2, Z3 }, default=None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>delta-set:
tuple</code> of <code>float</code></dt>
<dd>Delta-Connected impedance values { Z12, Z23, Z31 }</dd>
<dt><code>wye-set:
tuple</code> of <code>float</code></dt>
<dd>Wye-Connected impedance values { Z1, Z2, Z3 }</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dynetz(delta=None,wye=None,round=None):
    &#34;&#34;&#34;
    Delta-Wye Impedance Converter
    
    This function is designed to act as the conversion utility
    to transform delta-connected impedance values to wye-
    connected and vice-versa.
    
    .. math:: 
       Z_{sum} = Z_{1/2} + Z_{2/3} + Z_{3/1}//
       Z_1 = \\frac{Z_{1/2}*Z_{3/1}}{Z_{sum}}//
       Z_2 = \\frac{Z_{1/2}*Z_{2/3}}{Z_{sum}}//
       Z_3 = \\frac{Z_{2/3}*Z_{3/1}}{Z_{sum}}
    
    .. math::
       Z_{ms} = Z_1*Z_2 + Z_2*Z_3 + Z_3*Z_1//
       Z_{2/3} = \\frac{Z_{ms}}{Z_1}//
       Z_{3/1} = \\frac{Z_{ms}}{Z_2}//
       Z_{1/2} = \\frac{Z_{ms}}{Z_3}
    
    Parameters
    ----------
    delta:  tuple of float, exclusive
            Tuple of the delta-connected impedance values as:
            { Z12, Z23, Z31 }, default=None
    wye:    tuple of float, exclusive
            Tuple of the wye-connected impedance valuse as:
            { Z1, Z2, Z3 }, default=None
    
    Returns
    -------
    delta-set:  tuple of float
                Delta-Connected impedance values { Z12, Z23, Z31 }
    wye-set:    tuple of float
                Wye-Connected impedance values { Z1, Z2, Z3 }
    &#34;&#34;&#34;
    # Determine which set of impedances was provided
    if(delta!=None and wye==None):
        Z12, Z23, Z31 = delta # Gather particular impedances
        Zsum = Z12 + Z23 + Z31 # Find Sum
        # Calculate Wye Impedances
        Z1 = Z12*Z31 / Zsum
        Z2 = Z12*Z23 / Zsum
        Z3 = Z23*Z31 / Zsum
        Zset = ( Z1, Z2, Z3 )
        if round!=None: Zset = _np.around(Zset,round)
        return(Zset) # Return Wye Impedances
    elif(delta==None and wye!=None):
        Z1, Z2, Z3 = wye # Gather particular impedances
        Zmultsum = Z1*Z2 + Z2*Z3 + Z3*Z1
        Z23 = Zmultsum / Z1
        Z31 = Zmultsum / Z2
        Z12 = Zmultsum / Z3
        Zset = ( Z12, Z23, Z31 )
        if round!=None: Zset = _np.around(Zset,round)
        return(Zset) # Return Delta Impedances
    else:
        raise ValueError(&#34;ERROR: Either delta or wye impedances must be specified.&#34;)</code></pre>
</details>
</dd>
<dt id="electricpy.farads"><code class="name flex">
<span>def <span class="ident">farads</span></span>(<span>VAR, V, freq=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Capacitance from Apparent Power Formula</p>
<p>Function to calculate the required capacitance
in Farads to provide the desired power rating
(VARs).</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>VAR</code></strong> :&ensp;<code>
float</code></dt>
<dd>The rated power to meet.</dd>
<dt><strong><code>V</code></strong> :&ensp;<code>
float</code></dt>
<dd>The voltage across the capacitor;
not described as VLL or VLN, merely
the capacitor voltage.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The System frequency</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>
float</code></dt>
<dd>The evaluated capacitance (in Farads).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def farads(VAR,V,freq=60):
    &#34;&#34;&#34;
    Capacitance from Apparent Power Formula
    
    Function to calculate the required capacitance
    in Farads to provide the desired power rating
    (VARs).
    
    .. math:: C = \\frac{VAR}{2*\\pi*freq*V^2}
    
    Parameters
    ----------
    VAR:        float
                The rated power to meet.
    V:          float
                The voltage across the capacitor;
                not described as VLL or VLN, merely
                the capacitor voltage.
    freq:       float, optional
                The System frequency
    
    Returns
    -------
    C:          float
                The evaluated capacitance (in Farads).
    &#34;&#34;&#34;
    return(VAR / (2*_np.pi*freq*V**2))</code></pre>
</details>
</dd>
<dt id="electricpy.fftplot"><code class="name flex">
<span>def <span class="ident">fftplot</span></span>(<span>dc, real, imag=None, title='Fourier Coefficients')</span>
</code></dt>
<dd>
<div class="desc"><p>FFT System Plotter</p>
<p>Plotting function for FFT (harmonic) values,
plots the DC, Real, and Imaginary components.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dc</code></strong> :&ensp;<code>
float</code></dt>
<dd>The DC offset term</dd>
<dt><strong><code>real</code></strong> :&ensp;<code>
list</code> of <code>float</code></dt>
<dd>Real terms of FFT (cosine terms)</dd>
<dt><strong><code>imag</code></strong> :&ensp;<code>
list</code> of <code>float</code>, optional</dt>
<dd>Imaginary terms of FFT (sine terms)</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>
str</code>, optional</dt>
<dd>String appended to plot title,
default="Fourier Coefficients"</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fftplot(dc, real, imag=None, title=&#34;Fourier Coefficients&#34;):
    &#34;&#34;&#34;
    FFT System Plotter
    
    Plotting function for FFT (harmonic) values,
    plots the DC, Real, and Imaginary components.
    
    Parameters
    ----------
    dc:         float
                The DC offset term
    real:       list of float
                Real terms of FFT (cosine terms)
    imag:       list of float, optional
                Imaginary terms of FFT (sine terms)
    title:      str, optional
                String appended to plot title,
                default=&#34;Fourier Coefficients&#34;
    &#34;&#34;&#34;
    # Define Range values for plots
    rng = range(1,len(real)+1,1)
    xtic = range(0,len(real)+1,1)
    # Set up Arguments
    a0x = [0,0]
    a0y = [0,dc/2]
    # Plot
    _plt.title(title)
    _plt.plot(a0x,a0y,&#39;g&#39;,label=&#34;DC-Term&#34;)
    _plt.stem(rng,real,&#39;r&#39;,&#39;ro&#39;,label=&#34;Real-Terms&#34;,use_line_collection=True)
    try:
        imag != None
    except ValueError:
        _plt.stem(rng,imag,&#39;b&#39;,&#39;bo&#39;,label=&#34;Imaginary-Terms&#34;,use_line_collection=True)
    _plt.xlabel(&#34;Harmonics (Multiple of Fundamental)&#34;)
    _plt.ylabel(&#34;Harmonic Magnitude&#34;)
    _plt.axhline(0.0,color=&#39;k&#39;)
    _plt.legend()
    if(len(xtic) &lt; 50):
        _plt.xticks(xtic)
    _plt.show()</code></pre>
</details>
</dd>
<dt id="electricpy.fftsumplot"><code class="name flex">
<span>def <span class="ident">fftsumplot</span></span>(<span>dc, real, imag=None, freq=60, xrange=None, npts=1000, plotall=False, title='Fourier Series Summation')</span>
</code></dt>
<dd>
<div class="desc"><p>FFT Summation Plotter</p>
<p>Function to generate the plot of the sumed FFT results.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dc</code></strong> :&ensp;<code>
float</code></dt>
<dd>The DC offset term</dd>
<dt><strong><code>real</code></strong> :&ensp;<code>
list</code> of <code>float</code></dt>
<dd>Real terms of FFT (cosine terms)</dd>
<dt><strong><code>imag</code></strong> :&ensp;<code>
list</code> of <code>float</code></dt>
<dd>Imaginary terms of FFT (sine terms)</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Fundamental (minimum nonzero) frequency in Hz,
default=60</dd>
<dt><strong><code>xrange</code></strong> :&ensp;<code>
list</code> of <code>float</code>, optional</dt>
<dd>List of two floats containing the minimum
time and the maximum time.</dd>
<dt><strong><code>npts</code></strong> :&ensp;<code>
int</code>, optional</dt>
<dd>Number of time step points, default=1000</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>
str</code>, optional</dt>
<dd>String appended to plot title,
default="Fourier Series Summation"</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fftsumplot(dc,real,imag=None,freq=60,xrange=None,npts=1000,
               plotall=False,title=&#34;Fourier Series Summation&#34;):
    &#34;&#34;&#34;
    FFT Summation Plotter
    
    Function to generate the plot of the sumed FFT results.
    
    Parameters
    ----------
    dc:         float
                The DC offset term
    real:       list of float
                Real terms of FFT (cosine terms)
    imag:       list of float
                Imaginary terms of FFT (sine terms)
    freq:       float, optional
                Fundamental (minimum nonzero) frequency in Hz,
                default=60
    xrange:     list of float, optional
                List of two floats containing the minimum
                time and the maximum time.
    npts:       int, optional
                Number of time step points, default=1000
    title:      str, optional
                String appended to plot title,
                default=&#34;Fourier Series Summation&#34;
    &#34;&#34;&#34;
    # Determine the number (N) of terms
    N = len(real)
    # Determine the system period (T)
    T = 1/freq
    # Generate Domain Array
    if xrange == None:
        x = _np.linspace(0,T,npts)
    else:
        x = _np.linspace(xrange[0],xrange[1],npts)
    # Initialize output with DC term
    yout = _np.ones(len(x))*dc
    # Plot each iteration of the Fourier Series
    for k in range(1,N):
        if plotall:
            _plt.plot(x,yout)
        yout += real[k-1]*_np.cos(k*2*_np.pi*x/T)
        if imag != None:
            yout += imag[k-1]*_np.sin(k*2*_np.pi*x/T)
    _plt.plot(x,yout)
    _plt.title(title)
    _plt.xlabel(&#34;Time (seconds)&#34;)
    _plt.ylabel(&#34;Magnitude&#34;)
    _plt.show()</code></pre>
</details>
</dd>
<dt id="electricpy.funcfft"><code class="name flex">
<span>def <span class="ident">funcfft</span></span>(<span>func, minfreq=60, maxmult=15, complex=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function FFT Evaluator</p>
<p>Given the callable function handle for a periodic function,
evaluates the harmonic components of the function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>
function</code></dt>
<dd>Callable function from which to evaluate values.</dd>
<dt><strong><code>minfreq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Minimum frequency (in Hz) at which to evaluate FFT.
default=60</dd>
<dt><strong><code>maxmult</code></strong> :&ensp;<code>
int</code>, optional</dt>
<dd>Maximum harmonic (multiple of minfreq) which to
evaluate. default=15</dd>
<dt><strong><code>complex</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force returned values into
complex format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>DC</code></strong> :&ensp;<code>
float</code></dt>
<dd>The DC offset of the FFT result.</dd>
<dt><strong><code>A</code></strong> :&ensp;<code>
list</code> of <code>float</code></dt>
<dd>The real components from the FFT.</dd>
<dt><strong><code>B</code></strong> :&ensp;<code>
list</code> of <code>float</code></dt>
<dd>The imaginary components from the FFT.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def funcfft(func, minfreq=60, maxmult=15, complex=False):
    &#34;&#34;&#34;
    Function FFT Evaluator
    
    Given the callable function handle for a periodic function,
    evaluates the harmonic components of the function.
    
    Parameters
    ----------
    func:       function
                Callable function from which to evaluate values.
    minfreq:    float, optional
                Minimum frequency (in Hz) at which to evaluate FFT.
                default=60
    maxmult:    int, optional
                Maximum harmonic (multiple of minfreq) which to
                evaluate. default=15
    complex:    bool, optional
                Control argument to force returned values into
                complex format.
    
    Returns
    -------
    DC:         float
                The DC offset of the FFT result.
    A:          list of float
                The real components from the FFT.
    B:          list of float
                The imaginary components from the FFT.
    &#34;&#34;&#34;
    # Apply Nyquist scaling
    NN = 2 * maxmult + 2
    # Determine Time from Fundamental Frequency
    T = 1/minfreq
    # Generate time range to apply for FFT
    t, dt = _np.linspace(0, T, NN, endpoint=False, retstep=True)
    # Evaluate FFT
    y = _np.fft.rfft(func(t)) / t.size
    # Return Complex Values
    if complex:
       return(y)
    # Split out useful values
    else:
       y *= 2
       return(y[0].real, y[1:-1].real, -y[1:-1].imag)</code></pre>
</details>
</dd>
<dt id="electricpy.funcrms"><code class="name flex">
<span>def <span class="ident">funcrms</span></span>(<span>f, T)</span>
</code></dt>
<dd>
<div class="desc"><p>Function Root-Mean-Square (RMS) Evaluator</p>
<p>Integral-based RMS calculator, evaluates the RMS value
of a repetative signal (f) given the signal's specific
period (T)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>
float</code></dt>
<dd>The periodic function, a callable like f(t)</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>
float</code></dt>
<dd>The period of the function f, so that f(0)==f(T)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>RMS</code></strong> :&ensp;<code>
The RMS value</code> of <code>the function (f) over the interval ( 0, T )</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def funcrms(f, T):
    &#34;&#34;&#34;
    Function Root-Mean-Square (RMS) Evaluator
    
    Integral-based RMS calculator, evaluates the RMS value
    of a repetative signal (f) given the signal&#39;s specific
    period (T)

    Parameters
    ----------
    f:      float
            The periodic function, a callable like f(t)
    T:      float
            The period of the function f, so that f(0)==f(T)

    Returns
    -------
    RMS:    The RMS value of the function (f) over the interval ( 0, T )

    &#34;&#34;&#34;
    fn = lambda x: f(x)**2
    integral = integrate(fn,0,T)
    RMS = _np.sqrt(1/T*integral)
    return(RMS)</code></pre>
</details>
</dd>
<dt id="electricpy.gausdist"><code class="name flex">
<span>def <span class="ident">gausdist</span></span>(<span>x, mu=0, sigma=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Gaussian Distribution Function:</p>
<p>This function is designed to calculate the generic
distribution of a gaussian function with controls
for mu and sigma.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>The input (array) x</dd>
<dt><strong><code>mu</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Optional control argument, default=0</dd>
<dt><strong><code>sigma</code></strong> :&ensp;<code> float</code>, optional</dt>
<dd>Optional control argument, default=1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>F</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>Computed distribution of the gausian function at the
points specified by (array) x</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gausdist(x,mu=0,sigma=1):
    &#34;&#34;&#34;
    Gaussian Distribution Function:
    
    This function is designed to calculate the generic
    distribution of a gaussian function with controls
    for mu and sigma.
    
    Parameters
    ----------
    x:      numpy.ndarray
            The input (array) x
    mu:     float, optional
            Optional control argument, default=0
    sigma:  float, optional
            Optional control argument, default=1
    
    Returns
    -------
    F:      numpy.ndarray
            Computed distribution of the gausian function at the
            points specified by (array) x
    &#34;&#34;&#34;
    F = _np.array([])
    try:
        lx = len(x) # Find length of Input
    except:
        lx = 1 # Length 1
        x = [x] # Pack into list
    for i in range(lx):
        x_tmp = x[i]
        # Evaluate X (altered by mu and sigma)
        X = (x_tmp-mu) / sigma
        # Define Integrand
        def integrand(sq):
            return( _np.exp(-sq**2/2) )
        integral = integrate(integrand,_np.NINF,X) # Integrate
        result = 1/_np.sqrt(2*_np.pi) * integral[0] # Evaluate Result
        F = _np.append(F, result) # Append to output list
    # Return only the 0-th value if there&#39;s only 1 value available
    if(len(F)==1):
        F = F[0]
    return(F)</code></pre>
</details>
</dd>
<dt id="electricpy.gaussian"><code class="name flex">
<span>def <span class="ident">gaussian</span></span>(<span>x, mu=0, sigma=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Gaussian Function:</p>
<p>This function is designed to generate the gaussian
distribution curve with configuration mu and sigma.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>
float</code></dt>
<dd>The input (array) x.</dd>
<dt><strong><code>mu</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Optional control argument, default=0</dd>
<dt><strong><code>sigma</code></strong> :&ensp;<code> float</code>, optional</dt>
<dd>Optional control argument, default=1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Computed <a title="electricpy.gaussian" href="#electricpy.gaussian">gaussian()</a> (numpy.ndarray)</code> of <code>the input x</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gaussian(x,mu=0,sigma=1):
    &#34;&#34;&#34;
    Gaussian Function:
    
    This function is designed to generate the gaussian
    distribution curve with configuration mu and sigma.
    
    Parameters
    ----------
    x:      float
            The input (array) x.
    mu:     float, optional
            Optional control argument, default=0
    sigma:  float, optional
            Optional control argument, default=1
    
    Returns
    -------
    Computed gaussian (numpy.ndarray) of the input x
    &#34;&#34;&#34;
    return( 1/(sigma * _np.sqrt(2 * _np.pi)) *
            _np.exp(-(x - mu)**2 / (2 * sigma**2)) )</code></pre>
</details>
</dd>
<dt id="electricpy.geninternalv"><code class="name flex">
<span>def <span class="ident">geninternalv</span></span>(<span>I, Zs, Vt, Vgn=None, Zm=None, Ip=None, Ipp=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generator Internal Voltage Evaluator</p>
<p>Evaluates the internal voltage for a generator given the
generator's internal impedance and internal mutual coupling
impedance values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>I</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The current on the phase of interest.</dd>
<dt><strong><code>Zs</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The internal impedance of the phase of
interest in ohms.</dd>
<dt><strong><code>Vt</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The generator's terminal voltage.</dd>
<dt><strong><code>Vgn</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>The ground-to-neutral connection voltage.</dd>
<dt><strong><code>Zmp</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>The mutual coupling with the first additional
phase impedance in ohms.</dd>
<dt><strong><code>Zmpp</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>The mutual coupling with the second additional
phase impedance in ohms.</dd>
<dt><strong><code>Ip</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>The first mutual phase current in amps.</dd>
<dt><strong><code>Ipp</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>The second mutual phase current in amps.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Ea</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The internal voltage of the generator.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def geninternalv(I,Zs,Vt,Vgn=None,Zm=None,Ip=None,Ipp=None):
    &#34;&#34;&#34;
    Generator Internal Voltage Evaluator
    
    Evaluates the internal voltage for a generator given the
    generator&#39;s internal impedance and internal mutual coupling
    impedance values.
    
    Parameters
    ----------
    I:          complex
                The current on the phase of interest.
    Zs:         complex
                The internal impedance of the phase of
                interest in ohms.
    Vt:         complex
                The generator&#39;s terminal voltage.
    Vgn:        complex, optional
                The ground-to-neutral connection voltage.
    Zmp:        complex, optional
                The mutual coupling with the first additional
                phase impedance in ohms.
    Zmpp:       complex, optional
                The mutual coupling with the second additional
                phase impedance in ohms.
    Ip:         complex, optional
                The first mutual phase current in amps.
    Ipp:        complex, optional
                The second mutual phase current in amps.
    
    Returns
    -------
    Ea:         complex
                The internal voltage of the generator.
    &#34;&#34;&#34;
    # All Parameters Provided
    if Zmp == Zmpp == Ip == Ipp != None :
        if Vgn == None:
            Vgn = 0
        Ea = Zs*I + Zmp*Ip + Zmpp*Ipp + Vt + Vgn
    # Select Parameters Provided
    elif Vgn == Zm == Ip == Ipp == None :
        Ea = Zs*I + Vt
    # Invalid Parameter Set
    else:
        raise ValueError(&#34;Invalid Parameter Set&#34;)
    return(Ea)</code></pre>
</details>
</dd>
<dt id="electricpy.gmd"><code class="name flex">
<span>def <span class="ident">gmd</span></span>(<span>Ds, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple GMD Calculator</p>
<p>Calculates the GMD (Geometric Mean Distance) for a system
with the parameters of a list of arguments.</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Ds</code></strong> :&ensp;<code>
float</code></dt>
<dd>Self distance (unitless), normally provided from
datasheet/reference</dd>
<dt><strong><code>*args</code></strong> :&ensp;<code>
floats</code>, optional</dt>
<dd>Remaining set of distance values (unitless)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gmd(Ds,*args):
    &#34;&#34;&#34;
    Simple GMD Calculator
    
    Calculates the GMD (Geometric Mean Distance) for a system
    with the parameters of a list of arguments.
    
    .. math:: GMD=(D_s*D_1*\\ddot*D_n)^{\\frac{1}{1+n}}
    
    Parameters
    ----------
    Ds:         float
                Self distance (unitless), normally provided from
                datasheet/reference
    *args:      floats, optional
                Remaining set of distance values (unitless)
    &#34;&#34;&#34;
    # Find the Root from Number of Arguments
    root = len(args) + 1
    # Calculate the Root Term
    gmdx = Ds
    for dist in args:
        gmdx *= dist
    # Apply Root Calculation
    GMD = gmdx**(1/root)
    return(GMD)</code></pre>
</details>
</dd>
<dt id="electricpy.harmonics"><code class="name flex">
<span>def <span class="ident">harmonics</span></span>(<span>real, imag=None, dc=0, freq=60, domain=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Harmonic Function Generator</p>
<p>Generate a function or dataset for a harmonic system
given the real (cosine), imaginary (sine), and DC
components of the system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>real</code></strong> :&ensp;<code>
list</code> of <code>float</code></dt>
<dd>The real (cosine) component coefficients
for the harmonic system.</dd>
<dt><strong><code>imag</code></strong> :&ensp;<code>
list</code> of <code>float</code>, optional</dt>
<dd>The imaginary (sine) component coefficients
for the harmonic system.</dd>
<dt><strong><code>dc</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The DC offset for the harmonic system,
default=0</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The fundamental frequency of the system in
Hz, default=60</dd>
<dt><strong><code>domain</code></strong> :&ensp;<code>
list</code> of <code>float</code>, optional</dt>
<dd>Domain of time samples at which to calculate
the harmonic system, must be array-like, will
cause function to return numpy array instead
of function object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<code>
function</code></dt>
<dd>Function object handle which can be used to
call the function to evaluate the harmonic
system at specified times.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def harmonics(real,imag=None,dc=0,freq=60,domain=None):
    &#34;&#34;&#34;
    Harmonic Function Generator
    
    Generate a function or dataset for a harmonic system
    given the real (cosine), imaginary (sine), and DC
    components of the system.
    
    Parameters
    ----------
    real:       list of float
                The real (cosine) component coefficients
                for the harmonic system.
    imag:       list of float, optional
                The imaginary (sine) component coefficients
                for the harmonic system.
    dc:         float, optional
                The DC offset for the harmonic system,
                default=0
    freq:       float, optional
                The fundamental frequency of the system in
                Hz, default=60
    domain:     list of float, optional
                Domain of time samples at which to calculate
                the harmonic system, must be array-like, will
                cause function to return numpy array instead
                of function object.
    
    Returns
    -------
    system:     function
                Function object handle which can be used to
                call the function to evaluate the harmonic
                system at specified times.
    &#34;&#34;&#34;
    # Validate Inputs
    if not isinstance(real,(list,_np.ndarray)):
        raise ValueError(&#34;Argument *real* must be array-like.&#34;)
    if imag != None and not isinstance(imag,(list,_np.ndarray)):
        raise ValueError(&#34;Argument *imag* must be array-like.&#34;)
    # Calculate Omega
    w = 2*_np.pi*freq
    def _harmonic_(t):
        out = dc
        for k in range(len(real)):
            # Evaluate Current Coefficient
            A = real[k]
            if imag != None:
                B = imag[k]
            else:
                B = 0
            m = k + 1
            # Calculate Output
            out += A*_np.cos(m*w*t) + B*_np.sin(m*w*t)
        # Return Value
        return(out)
    if domain is None:
        system = _harmonic_
    else:
        system = _harmonic_(domain)
    return(system)</code></pre>
</details>
</dd>
<dt id="electricpy.hartleydata"><code class="name flex">
<span>def <span class="ident">hartleydata</span></span>(<span>BW, M)</span>
</code></dt>
<dd>
<div class="desc"><p>Hartley Data Function</p>
<p>Function to calculate Hartley's Law,
the maximum data rate achievable for
a given noiseless channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>BW</code></strong> :&ensp;<code>
float</code></dt>
<dd>Bandwidth of the data channel.</dd>
<dt><strong><code>M</code></strong> :&ensp;<code>
float</code></dt>
<dd>Number of signal levels.</dd>
</dl>
<h2 id="returns">Returns:</h2>
<p>C:
float
Capacity of channel (in bits per second)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hartleydata(BW,M):
    &#34;&#34;&#34;
    Hartley Data Function
    
    Function to calculate Hartley&#39;s Law,
    the maximum data rate achievable for
    a given noiseless channel.
    
    Parameters
    ----------
    BW:         float
                Bandwidth of the data channel.
    M:          float
                Number of signal levels.
    
    Returns:
    --------
    C:          float
                Capacity of channel (in bits per second)
    &#34;&#34;&#34;
    C = 2*BW*_np.log2(M)
    return(C)</code></pre>
</details>
</dd>
<dt id="electricpy.hertz"><code class="name flex">
<span>def <span class="ident">hertz</span></span>(<span>radians)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple Radians to Hertz Converter</p>
<p>Accepts a frequency in radians/sec and calculates
the hertzian frequency (in Hz).</p>
<p>[
]
Same as <code><a title="electricpy.hertz" href="#electricpy.hertz">rad_to_hz()</a></code>.</p>
<h2 id="paramters">Paramters</h2>
<p>radians:
float
The frequency (represented in radians/sec)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hertz</code></strong> :&ensp;<code>
float</code></dt>
<dd>The frequency (represented in Hertz)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rad_to_hz( radians ):
    &#34;&#34;&#34;
    Simple Radians to Hertz Converter
    
    Accepts a frequency in radians/sec and calculates
    the hertzian frequency (in Hz).
    
    .. math:: f_{\\text{Hz}} = \\frac{f_{\\text{rad/sec}}}{2\\cdot\\pi}
    
    Same as `hertz`.
    
    Paramters
    ---------
    radians:    float
                The frequency (represented in radians/sec)
    
    Returns
    -------
    hertz:      float
                The frequency (represented in Hertz)
    &#34;&#34;&#34;
    return( radians / (2*_np.pi) ) # Evaluate and Return</code></pre>
</details>
</dd>
<dt id="electricpy.horsepower"><code class="name flex">
<span>def <span class="ident">horsepower</span></span>(<span>watts)</span>
</code></dt>
<dd>
<div class="desc"><p>Watts to Horsepower Function</p>
<p>Calculates the power (in horsepower) given
the power in watts.</p>
<p>[
]
Same as <code><a title="electricpy.horsepower" href="#electricpy.horsepower">watts_to_hp()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>watts</code></strong> :&ensp;<code>
float</code></dt>
<dd>The wattage to compute.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hp</code></strong> :&ensp;<code>
float</code></dt>
<dd>The power in horsepower.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watts_to_hp(watts):
    &#34;&#34;&#34;
    Watts to Horsepower Function
    
    Calculates the power (in horsepower) given
    the power in watts.
    
    .. math:: P_{\\text{horsepower}}=\\frac{P_{\\text{watts}}}{745.699872}
    
    Same as `horsepower`.
    
    Parameters
    ----------
    watts:      float
                The wattage to compute.
    
    Returns
    -------
    hp:         float
                The power in horsepower.
    &#34;&#34;&#34;
    return(watts / 745.699872)</code></pre>
</details>
</dd>
<dt id="electricpy.hp_to_watts"><code class="name flex">
<span>def <span class="ident">hp_to_watts</span></span>(<span>hp)</span>
</code></dt>
<dd>
<div class="desc"><p>Horsepower to Watts Formula</p>
<p>Calculates the power (in watts) given the
horsepower.</p>
<p>[
]
Same as <code><a title="electricpy.watts" href="#electricpy.watts">hp_to_watts()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hp</code></strong> :&ensp;<code>
float</code></dt>
<dd>The horspower to compute.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>watts</code></strong> :&ensp;<code>
float</code></dt>
<dd>The power in watts.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hp_to_watts(hp):
    &#34;&#34;&#34;
    Horsepower to Watts Formula
    
    Calculates the power (in watts) given the
    horsepower.
    
    .. math:: P_{\\text{watts}}=P_{\\text{horsepower}}\\cdot745.699872
    
    Same as `watts`.
    
    Parameters
    ----------
    hp:         float
                The horspower to compute.
    
    Returns
    -------
    watts:      float
                The power in watts.
    &#34;&#34;&#34;
    return(hp * 745.699872)</code></pre>
</details>
</dd>
<dt id="electricpy.hz_to_rad"><code class="name flex">
<span>def <span class="ident">hz_to_rad</span></span>(<span>hertz)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple Hertz to Radians Converter</p>
<p>Accepts a frequency in Hertz and calculates
the frequency in radians/sec.</p>
<p>[
]
Same as <code><a title="electricpy.radsec" href="#electricpy.radsec">hz_to_rad()</a></code>.</p>
<h2 id="paramters">Paramters</h2>
<p>hertz:
float
The frequency (represented in Hertz)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>radians</code></strong> :&ensp;<code>
float</code></dt>
<dd>The frequency (represented in radians/sec)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hz_to_rad( hertz ):
    &#34;&#34;&#34;
    Simple Hertz to Radians Converter
    
    Accepts a frequency in Hertz and calculates
    the frequency in radians/sec.
    
    .. math:: f_{\\text{rad/sec}} = f_{\\text{Hz}}\\cdot2\\cdot\\pi
    
    Same as `radsec`.
    
    Paramters
    ---------
    hertz:      float
                The frequency (represented in Hertz)
    
    Returns
    -------
    radians:    float
                The frequency (represented in radians/sec)
    &#34;&#34;&#34;
    return( hertz * (2*_np.pi) ) # Evaluate and Return</code></pre>
</details>
</dd>
<dt id="electricpy.hz_to_rpm"><code class="name flex">
<span>def <span class="ident">hz_to_rpm</span></span>(<span>hz)</span>
</code></dt>
<dd>
<div class="desc"><p>Hertz to RPM Converter</p>
<p>Given the angular velocity in Hertz, this
function will evaluate the velocity in RPM
(Revolutions-Per-Minute).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hz</code></strong> :&ensp;<code>
float</code></dt>
<dd>The angular velocity in Hertz</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rpm</code></strong> :&ensp;<code>
float</code></dt>
<dd>The angular velocity in revolutions-
per-minute (RPM)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hz_to_rpm(hz):
    &#34;&#34;&#34;
    Hertz to RPM Converter
    
    Given the angular velocity in Hertz, this
    function will evaluate the velocity in RPM
    (Revolutions-Per-Minute).
    
    Parameters
    ----------
    hz:         float
                The angular velocity in Hertz
    
    Returns
    -------
    rpm:        float
                The angular velocity in revolutions-
                per-minute (RPM)
    &#34;&#34;&#34;
    rpm = hz*60
    return(rpm)</code></pre>
</details>
</dd>
<dt id="electricpy.imfoc_control"><code class="name flex">
<span>def <span class="ident">imfoc_control</span></span>(<span>Tem_cmd, LAMdr_cmd, wr_cmd, Rr, Rs, Lm, Llr=0, Lls=0, Lr=None, Ls=None, s_err=0)</span>
</code></dt>
<dd>
<div class="desc"><p>FOC Ind. Machine Rated Operation Calculator</p>
<p>Determines the parameters and characteristics of a Field-
Oriented-Controlled Induction Machine operating at its
rated limits.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Tem_cmd</code></strong> :&ensp;<code>
float</code></dt>
<dd>Mechanical torque setpoint in per-unit-newton-meters</dd>
<dt><strong><code>LAMdr_cmd</code></strong> :&ensp;<code> float</code></dt>
<dd>D-axis flux setpoint in per-unit</dd>
<dt><strong><code>wr_cmd</code></strong> :&ensp;<code>
float</code></dt>
<dd>Mechanical (rotor) speed in per-unit-rad/sec</dd>
<dt><strong><code>Rr</code></strong> :&ensp;<code>
float</code></dt>
<dd>Rotor resistance in per-unit-ohms</dd>
<dt><strong><code>Rs</code></strong> :&ensp;<code>
float</code></dt>
<dd>Stator resistance in per-unit-ohms</dd>
<dt><strong><code>Lm</code></strong> :&ensp;<code>
float</code></dt>
<dd>Magnetizing inductance in per-unit-Henrys</dd>
<dt><strong><code>Llr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor leakage inductance in per-unit-Henrys,
default=0</dd>
<dt><strong><code>Lls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator leakage inductance in per-unit-Henrys,
default=0</dd>
<dt><strong><code>Lr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor inductance in per-unit-Henrys</dd>
<dt><strong><code>Ls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator inductance in per-unit-Henrys</dd>
<dt><strong><code>s_err</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Error in slip calculation as a percent (e.g. 0.25),
default=0</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Vdqs</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Combined DQ-axis Stator Voltage in per-unit volts</dd>
<dt><strong><code>Idqr</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Combined DQ-axis Rotor Current in per-unit-amps</dd>
<dt><strong><code>Idqs</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Combined DQ-axis Stator Current in per-unit-amps</dd>
<dt><strong><code>LAMdqr</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Combined DQ-axis Rotor Flux in per-unit</dd>
<dt><strong><code>LAMdqs</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Combined DQ-axis Stator Flux in per-unit</dd>
<dt><strong><code>wslip</code></strong> :&ensp;<code>
float</code></dt>
<dd>Machine Slip frequency in per-unit-rad/sec</dd>
<dt><strong><code>wes</code></strong> :&ensp;<code>
float</code></dt>
<dd>The electrical system frequency in per-unit-rad/sec</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imfoc_control(Tem_cmd,LAMdr_cmd,wr_cmd,Rr,Rs,Lm,
                  Llr=0,Lls=0,Lr=None,Ls=None,s_err=0):
    &#34;&#34;&#34;
    FOC Ind. Machine Rated Operation Calculator
    
    Determines the parameters and characteristics of a Field-
    Oriented-Controlled Induction Machine operating at its
    rated limits.
    
    Parameters
    ----------
    Tem_cmd:    float
                Mechanical torque setpoint in per-unit-newton-meters
    LAMdr_cmd:  float
                D-axis flux setpoint in per-unit
    wr_cmd:     float
                Mechanical (rotor) speed in per-unit-rad/sec
    Rr:         float
                Rotor resistance in per-unit-ohms
    Rs:         float
                Stator resistance in per-unit-ohms
    Lm:         float
                Magnetizing inductance in per-unit-Henrys
    Llr:        float, optional
                Rotor leakage inductance in per-unit-Henrys,
                default=0
    Lls:        float, optional
                Stator leakage inductance in per-unit-Henrys,
                default=0
    Lr:         float, optional
                Rotor inductance in per-unit-Henrys
    Ls:         float, optional
                Stator inductance in per-unit-Henrys
    s_err:      float, optional
                Error in slip calculation as a percent (e.g. 0.25),
                default=0
    
    Returns
    -------
    Vdqs:       complex
                Combined DQ-axis Stator Voltage in per-unit volts
    Idqr:       complex
                Combined DQ-axis Rotor Current in per-unit-amps
    Idqs:       complex
                Combined DQ-axis Stator Current in per-unit-amps
    LAMdqr:     complex
                Combined DQ-axis Rotor Flux in per-unit
    LAMdqs:     complex
                Combined DQ-axis Stator Flux in per-unit
    wslip:      float
                Machine Slip frequency in per-unit-rad/sec
    wes:        float
                The electrical system frequency in per-unit-rad/sec
    &#34;&#34;&#34;
    # Condition Inputs:
    if Ls == None: # Use Lls instead of Ls
        Ls = Lls + Lm
    if Lr == None: # Use Llr instead of Lr
        Lr = Llr + Lm
    # Calculate Additional Constraints
    sigma = (1-Lm**2/(Ls*Lr))
    accuracy = 1+s_err
    # Command Values (Transient and Steady State)
    Ids = LAMdr_cmd/Lm
    Iqs = Tem_cmd/((Lm/Lr)*LAMdr_cmd)
    wslip = Rr/(Lr*accuracy) * (Lm*Iqs)/LAMdr_cmd
    wes = wslip + wr_cmd
    # Stator dq Voltages (Steady State)
    Vds = Rs*Ids - wes*sigma*Ls*Iqs
    Vqs = Rs*Iqs - wes*Ls*Ids
    # Remaining Steady State
    Iqr = -Lm/Lr * Iqs
    Idr = 0
    LAMqr = 0
    LAMqs = sigma*Ls*Iqs
    LAMds = Ls*Ids
    return(
        compose(Vds,Vqs),
        compose(Idr,Iqr),
        compose(Ids,Iqs),
        compose(LAMdr_cmd,LAMqr),
        compose(LAMds,LAMqs),
        wslip,
        wes
    )</code></pre>
</details>
</dd>
<dt id="electricpy.indmachfocratings"><code class="name flex">
<span>def <span class="ident">indmachfocratings</span></span>(<span>Rr, Rs, Lm, Llr=0, Lls=0, Lr=None, Ls=None, Vdqs=1, Tem=1, wes=1)</span>
</code></dt>
<dd>
<div class="desc"><p>FOC Ind. Machine Rated Operation Calculator</p>
<p>Determines the parameters and characteristics of a Field-
Oriented-Controlled Induction Machine operating at its
rated limits.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Rr</code></strong> :&ensp;<code>
float</code></dt>
<dd>Rotor resistance in per-unit-ohms</dd>
<dt><strong><code>Rs</code></strong> :&ensp;<code>
float</code></dt>
<dd>Stator resistance in per-unit-ohms</dd>
<dt><strong><code>Lm</code></strong> :&ensp;<code>
float</code></dt>
<dd>Magnetizing inductance in per-unit-Henrys</dd>
<dt><strong><code>Llr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor leakage inductance in per-unit-Henrys,
default=0</dd>
<dt><strong><code>Lls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator leakage inductance in per-unit-Henrys,
default=0</dd>
<dt><strong><code>Lr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor inductance in per-unit-Henrys</dd>
<dt><strong><code>Ls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator inductance in per-unit-Henrys</dd>
<dt><strong><code>Vdqs</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>The combined DQ-axis voltage required for rated
operation, in per-unit-volts, default=1+j0</dd>
<dt><strong><code>Tem</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The mechanical torque required for rated operation,
in per-unit-newton-meters, default=1</dd>
<dt><strong><code>wes</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The per-unit electrical system frequency, default=1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Idqr</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Combined DQ-axis Rotor Current in per-unit-amps</dd>
<dt><strong><code>Idqs</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Combined DQ-axis Stator Current in per-unit-amps</dd>
<dt><strong><code>LAMdqr</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Combined DQ-axis Rotor Flux in per-unit</dd>
<dt><strong><code>LAMdqs</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Combined DQ-axis Stator Flux in per-unit</dd>
<dt><strong><code>slip_rat</code></strong> :&ensp;<code>
float</code></dt>
<dd>Rated Slip as percent of rotational and system frequencies</dd>
<dt><strong><code>w_rat</code></strong> :&ensp;<code>
float</code></dt>
<dd>Rated System frequency in per-unit-rad/sec</dd>
<dt><strong><code>lamdr_rat</code></strong> :&ensp;<code> float</code></dt>
<dd>Rated D-axis rotor flux in per-unit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indmachfocratings(Rr,Rs,Lm,Llr=0,Lls=0,Lr=None,
                      Ls=None,Vdqs=1,Tem=1,wes=1):
    &#34;&#34;&#34;
    FOC Ind. Machine Rated Operation Calculator
    
    Determines the parameters and characteristics of a Field-
    Oriented-Controlled Induction Machine operating at its
    rated limits.
    
    Parameters
    ----------
    Rr:         float
                Rotor resistance in per-unit-ohms
    Rs:         float
                Stator resistance in per-unit-ohms
    Lm:         float
                Magnetizing inductance in per-unit-Henrys
    Llr:        float, optional
                Rotor leakage inductance in per-unit-Henrys,
                default=0
    Lls:        float, optional
                Stator leakage inductance in per-unit-Henrys,
                default=0
    Lr:         float, optional
                Rotor inductance in per-unit-Henrys
    Ls:         float, optional
                Stator inductance in per-unit-Henrys
    Vdqs:       complex, optional
                The combined DQ-axis voltage required for rated
                operation, in per-unit-volts, default=1+j0
    Tem:        float, optional
                The mechanical torque required for rated operation,
                in per-unit-newton-meters, default=1
    wes:        float, optional
                The per-unit electrical system frequency, default=1
    
    Returns
    -------
    Idqr:       complex
                Combined DQ-axis Rotor Current in per-unit-amps
    Idqs:       complex
                Combined DQ-axis Stator Current in per-unit-amps
    LAMdqr:     complex
                Combined DQ-axis Rotor Flux in per-unit
    LAMdqs:     complex
                Combined DQ-axis Stator Flux in per-unit
    slip_rat:   float
                Rated Slip as percent of rotational and system frequencies
    w_rat:      float
                Rated System frequency in per-unit-rad/sec
    lamdr_rat:  float
                Rated D-axis rotor flux in per-unit
    &#34;&#34;&#34;
    # Condition Inputs:
    if Ls == None: # Use Lls instead of Ls
        Ls = Lls + Lm
    if Lr == None: # Use Llr instead of Lr
        Lr = Llr + Lm
    # Define Equations Function as Solver
    def equations(val):
        Idr,Iqr,Ids,Iqs,LAMdr,LAMqr,LAMds,LAMqs,wr = val
        A = (Rs*Ids - wes*LAMqs) - Vdqs
        B = Rs*Iqs - wes*LAMds
        C = Rr*Idr - (wes-wr)*LAMqr
        D = Rr*Iqr + (wes-wr)*LAMdr
        E = (Ls*Ids + Lm*Idr) - LAMds
        F = (Ls*Iqs + Lm*Iqr) - LAMqs
        G = (Lm*Ids+Lr*Idr) - LAMdr
        H = (Lm*Iqs+Lr*Iqr) - LAMqr
        I = (Lm/Lr*(LAMdr*Iqs-LAMqr*Ids)) - Tem
        return(A,B,C,D,E,F,G,H,I)
    # Define Initial Guesses
    Idr0 = -1
    Iqr0 = -1
    Ids0 = 1
    Iqs0 = 1
    LAMdr0 = Lm*Ids0 + Lr*Idr0
    LAMqr0 = Lm*Iqs0 + Lr*Iqr0
    LAMds0 = Ls*Ids0 + Lm*Idr0
    LAMqs0 = Ls*Iqs0 + Lm*Iqr0
    wr = 1
    # Use Iterative Solver to Find Results
    Idr,Iqr,Ids,Iqs,LAMdr,LAMqr,LAMds,LAMqs,wr = _fsolve(equations,(
        Idr0,Iqr0,Ids0,Iqs0,LAMdr0,LAMqr0,LAMds0,LAMqs0,wr))
    # Calculate Remaining Rating Terms
    slip_rated = (wes-wr)/wes
    w_rated = wr
    lamdr_rated = abs(LAMdr+1j*LAMqr)
    return(
        compose(Idr,Iqr),
        compose(Ids,Iqs),
        compose(LAMdr,LAMqr),
        compose(LAMds,LAMqs),
        slip_rated,
        w_rated,
        lamdr_rated
    )</code></pre>
</details>
</dd>
<dt id="electricpy.indmachiar"><code class="name flex">
<span>def <span class="ident">indmachiar</span></span>(<span>Vth=None, Zth=None, Vas=0, Rs=0, Lm=0, Lls=0, Llr=0, Ls=None, Lr=None, freq=60, calcX=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Induction Machine Rotor Current Calculator</p>
<p>Calculation function to find the phase-A, rotor current for an
induction machine given the thevenin voltage and impedance.</p>
<p>This current is calculated using the following formulas:</p>
<p>[
]
where:</p>
<p>[
]
[ Z_{th} = \frac{(R_s+j\omega L_{ls})j\omega L_m}
{R_s+j\omega(L_{ls}+L_m)}+j\omega L_{lr} ]
[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Vth</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Thevenin-equivalent stator voltage of the
induction machine, may be calculated internally
if given stator voltage and machine parameters.</dd>
<dt><strong><code>Zth</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Thevenin-equivalent inductance (in ohms) of the
induction machine, may be calculated internally
if given machine parameters.</dd>
<dt><strong><code>Vas</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Terminal Stator Voltage in Volts</dd>
<dt><strong><code>Rs</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator resistance in ohms</dd>
<dt><strong><code>Lm</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Magnetizing inductance in Henrys</dd>
<dt><strong><code>Lls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator leakage inductance in Henrys, default=0</dd>
<dt><strong><code>Llr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor leakage inductance in Henrys, default=0</dd>
<dt><strong><code>Ls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator inductance in Henrys</dd>
<dt><strong><code>Lr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor inductance in Henrys</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System (electrical) frequency in Hz, default=60</dd>
<dt><strong><code>calcX</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force system to calculate
system reactances with system frequency, or to
treat them as previously-calculated reactances.
default=True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Iar</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The rotor, phase-A current in amps.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.indmachvth" href="#electricpy.indmachvth">indmachvth()</a></code></dt>
<dd>Induction Machine Thevenin Voltage Calculator</dd>
<dt><code><a title="electricpy.indmachzth" href="#electricpy.indmachzth">indmachzth()</a></code></dt>
<dd>Induction Machine Thevenin Impedance Calculator</dd>
<dt><code><a title="electricpy.indmachpem" href="#electricpy.indmachpem">indmachpem()</a></code></dt>
<dd>Induction Machine Electro-Mechanical Power Calculator</dd>
<dt><code><a title="electricpy.indmachtem" href="#electricpy.indmachtem">indmachtem()</a></code></dt>
<dd>Induction Machine Electro-Mechanical Torque Calculator</dd>
<dt><code><a title="electricpy.indmachpkslip" href="#electricpy.indmachpkslip">indmachpkslip()</a></code></dt>
<dd>Induction Machine Peak Slip Calculator</dd>
<dt><code><a title="electricpy.indmachpktorq" href="#electricpy.indmachpktorq">indmachpktorq()</a></code></dt>
<dd>Induction Machine Peak Torque Calculator</dd>
<dt><code><a title="electricpy.indmachstarttorq" href="#electricpy.indmachstarttorq">indmachstarttorq()</a></code></dt>
<dd>Induction Machine Starting Torque Calculator</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indmachiar(Vth=None,Zth=None,Vas=0,Rs=0,Lm=0,Lls=0,
               Llr=0,Ls=None,Lr=None,freq=60,calcX=True):
    &#34;&#34;&#34;
    Induction Machine Rotor Current Calculator
    
    Calculation function to find the phase-A, rotor current for an
    induction machine given the thevenin voltage and impedance.
    
    This current is calculated using the following formulas:
    
    .. math:: I_{a_{\\text{rotor}}} = \\frac{V_{th}}{|Z_{th}|+Z_{th}}
    
    where:
    
    .. math:: V_{th}=\\frac{j\\omega L_m}{R_s+j\\omega(L_{ls}+L_m)}V_{as}
    
    .. math::
       Z_{th} = \\frac{(R_s+j\\omega L_{ls})j\\omega L_m}
       {R_s+j\\omega(L_{ls}+L_m)}+j\\omega L_{lr}
    
    .. math:: \\omega = \\omega_{es} = 2\\pi\\cdot f_{\\text{electric}}
    
    Parameters
    ----------
    Vth:        complex, optional
                Thevenin-equivalent stator voltage of the
                induction machine, may be calculated internally
                if given stator voltage and machine parameters.
    Zth:        complex, optional
                Thevenin-equivalent inductance (in ohms) of the
                induction machine, may be calculated internally
                if given machine parameters.
    Vas:        complex, optional
                Terminal Stator Voltage in Volts
    Rs:         float, optional
                Stator resistance in ohms
    Lm:         float, optional
                Magnetizing inductance in Henrys
    Lls:        float, optional
                Stator leakage inductance in Henrys, default=0
    Llr:        float, optional
                Rotor leakage inductance in Henrys, default=0
    Ls:         float, optional
                Stator inductance in Henrys
    Lr:         float, optional
                Rotor inductance in Henrys
    freq:       float, optional
                System (electrical) frequency in Hz, default=60
    calcX:      bool, optional
                Control argument to force system to calculate
                system reactances with system frequency, or to
                treat them as previously-calculated reactances.
                default=True
    
    Returns
    -------
    Iar:        complex
                The rotor, phase-A current in amps.
    
    See Also
    --------
    indmachvth:         Induction Machine Thevenin Voltage Calculator
    indmachzth:         Induction Machine Thevenin Impedance Calculator
    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
    indmachpkslip:      Induction Machine Peak Slip Calculator
    indmachpktorq:      Induction Machine Peak Torque Calculator
    indmachstarttorq:   Induction Machine Starting Torque Calculator
    &#34;&#34;&#34;
    # Condition Inputs
    w = 2*_np.pi*freq
    if Ls != None: # Use Ls instead of Lls
        Lls = Ls - Lm
    if Lr != None: # Use Lr instead of Llr
        Llr = Lr - Lm
    if p != 0: # Calculate Sync. Speed from Num. Poles
        wsyn = w/(p/2)
    if calcX: # Convert Inductances to Reactances
        Lm *= w
        Lls *= w
        Llr *= w
    # Test for Valid Input Set
    if Vth == None:
        if not all((Vas,Rs,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Vth
        Vth = indmachvth(Vas,Rs,Lm,Lls,Ls,freq,calcX)
    if Zth == None:
        if not all((Rs,Llr,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Zth
        Zth = indmachzth(Rs,Lm,Lls,Ll,Ls,Lr,freq,calcX)
    # Calculate Rotor Current
    Iar = Vth / (Zth.real + Zth)
    return(Iar)</code></pre>
</details>
</dd>
<dt id="electricpy.indmachpem"><code class="name flex">
<span>def <span class="ident">indmachpem</span></span>(<span>slip, Rr, Vth=None, Zth=None, Vas=0, Rs=0, Lm=0, Lls=0, Llr=0, Ls=None, Lr=None, freq=60, calcX=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Mechanical Power Calculator for Induction Machines</p>
<p>Function to calculate the mechanical power using the thevenin
equivalent circuit terms.</p>
<p>[ P_{em}=\frac{|V_{th_{\text{stator}}}|^2\cdot\frac{R_r}{slip}}
{\left[\left(\frac{R_r}{slip}+R_{th_{\text{stator}}}\right)^2
+X_{th_{\text{stator}}}^2\right]\cdot\omega_{es}}\cdot(1-slip) ]
Parameters</p>
<hr>
<dl>
<dt><strong><code>slip</code></strong> :&ensp;<code>
float</code></dt>
<dd>The mechanical/electrical slip factor of the
induction machine.</dd>
<dt><strong><code>Rr</code></strong> :&ensp;<code>
float</code></dt>
<dd>Rotor resistance in ohms</dd>
<dt><strong><code>Vth</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Thevenin-equivalent stator voltage of the
induction machine, may be calculated internally
if given stator voltage and machine parameters.</dd>
<dt><strong><code>Zth</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Thevenin-equivalent inductance (in ohms) of the
induction machine, may be calculated internally
if given machine parameters.</dd>
<dt><strong><code>Vas</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Terminal Stator Voltage in Volts</dd>
<dt><strong><code>Rs</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator resistance in ohms</dd>
<dt><strong><code>Lm</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Magnetizing inductance in Henrys</dd>
<dt><strong><code>Lls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator leakage inductance in Henrys, default=0</dd>
<dt><strong><code>Llr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor leakage inductance in Henrys, default=0</dd>
<dt><strong><code>Ls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator inductance in Henrys</dd>
<dt><strong><code>Lr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor inductance in Henrys</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System (electrical) frequency in Hz, default=60</dd>
<dt><strong><code>calcX</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force system to calculate
system reactances with system frequency, or to
treat them as previously-calculated reactances.
default=True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Pem</code></strong> :&ensp;<code>
float</code></dt>
<dd>Power (in watts) that is produced or consumed
by the mechanical portion of the induction machine.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.indmachvth" href="#electricpy.indmachvth">indmachvth()</a></code></dt>
<dd>Induction Machine Thevenin Voltage Calculator</dd>
<dt><code><a title="electricpy.indmachzth" href="#electricpy.indmachzth">indmachzth()</a></code></dt>
<dd>Induction Machine Thevenin Impedance Calculator</dd>
<dt><code><a title="electricpy.indmachtem" href="#electricpy.indmachtem">indmachtem()</a></code></dt>
<dd>Induction Machine Electro-Mechanical Torque Calculator</dd>
<dt><code><a title="electricpy.indmachpkslip" href="#electricpy.indmachpkslip">indmachpkslip()</a></code></dt>
<dd>Induction Machine Peak Slip Calculator</dd>
<dt><code><a title="electricpy.indmachpktorq" href="#electricpy.indmachpktorq">indmachpktorq()</a></code></dt>
<dd>Induction Machine Peak Torque Calculator</dd>
<dt><code><a title="electricpy.indmachiar" href="#electricpy.indmachiar">indmachiar()</a></code></dt>
<dd>Induction Machine Phase-A Rotor Current Calculator</dd>
<dt><code><a title="electricpy.indmachstarttorq" href="#electricpy.indmachstarttorq">indmachstarttorq()</a></code></dt>
<dd>Induction Machine Starting Torque Calculator</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indmachpem(slip,Rr,Vth=None,Zth=None,Vas=0,Rs=0,Lm=0,Lls=0,
               Llr=0,Ls=None,Lr=None,freq=60,calcX=True):
    &#34;&#34;&#34;
    Mechanical Power Calculator for Induction Machines
    
    Function to calculate the mechanical power using the thevenin
    equivalent circuit terms.
    
    .. math:: 
       P_{em}=\\frac{|V_{th_{\\text{stator}}}|^2\\cdot\\frac{R_r}{slip}}
       {\\left[\\left(\\frac{R_r}{slip}+R_{th_{\\text{stator}}}\\right)^2
       +X_{th_{\\text{stator}}}^2\\right]\\cdot\\omega_{es}}\\cdot(1-slip)
    
    Parameters
    ----------
    slip:       float
                The mechanical/electrical slip factor of the
                induction machine.
    Rr:         float
                Rotor resistance in ohms
    Vth:        complex, optional
                Thevenin-equivalent stator voltage of the
                induction machine, may be calculated internally
                if given stator voltage and machine parameters.
    Zth:        complex, optional
                Thevenin-equivalent inductance (in ohms) of the
                induction machine, may be calculated internally
                if given machine parameters.
    Vas:        complex, optional
                Terminal Stator Voltage in Volts
    Rs:         float, optional
                Stator resistance in ohms
    Lm:         float, optional
                Magnetizing inductance in Henrys
    Lls:        float, optional
                Stator leakage inductance in Henrys, default=0
    Llr:        float, optional
                Rotor leakage inductance in Henrys, default=0
    Ls:         float, optional
                Stator inductance in Henrys
    Lr:         float, optional
                Rotor inductance in Henrys
    freq:       float, optional
                System (electrical) frequency in Hz, default=60
    calcX:      bool, optional
                Control argument to force system to calculate
                system reactances with system frequency, or to
                treat them as previously-calculated reactances.
                default=True
    
    Returns
    -------
    Pem:        float
                Power (in watts) that is produced or consumed
                by the mechanical portion of the induction machine.
    
    See Also
    --------
    indmachvth:         Induction Machine Thevenin Voltage Calculator
    indmachzth:         Induction Machine Thevenin Impedance Calculator
    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
    indmachpkslip:      Induction Machine Peak Slip Calculator
    indmachpktorq:      Induction Machine Peak Torque Calculator
    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
    indmachstarttorq:   Induction Machine Starting Torque Calculator
    &#34;&#34;&#34;
    # Condition Inputs
    w = 2*_np.pi*freq
    if Ls != None: # Use Ls instead of Lls
        Lls = Ls - Lm
    if Lr != None: # Use Lr instead of Llr
        Llr = Lr - Lm
    if calcX: # Convert Inductances to Reactances
        Lm *= w
        Lls *= w
        Llr *= w
    # Test for Valid Input Set
    if Vth == None:
        if not all((Vas,Rs,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Vth
        Vth = indmachvth(Vas,Rs,Lm,Lls,Ls,freq,calcX)
    if Zth == None:
        if not all((Rs,Llr,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Zth
        Zth = indmachzth(Rs,Lm,Lls,Llr,Ls,Lr,freq,calcX)
    # Use Terms to Calculate Pem
    Rth = Zth.real
    Xth = Zth.imag
    Pem = (abs(Vth)**2*Rr/slip)/(((Rr/slip+Rth)**2+Xth**2)*w) * (1-slip)
    return(Pem)</code></pre>
</details>
</dd>
<dt id="electricpy.indmachpkslip"><code class="name flex">
<span>def <span class="ident">indmachpkslip</span></span>(<span>Rr, Zth=None, Rs=0, Lm=0, Lls=0, Llr=0, Ls=None, Lr=None, freq=60, calcX=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Induction Machine Slip at Peak Torque Calculator</p>
<p>Function to calculate the slip encountered by an induction machine
with the parameters specified when the machine is generating peak
torque. Uses formula as shown below.</p>
<p>[
]
where:</p>
<p>[ Z_{th} = \frac{(R_s+j\omega L_{ls})j\omega L_m}
{R_s+j\omega(L_{ls}+L_m)}+j\omega L_{lr} ]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Rr</code></strong> :&ensp;<code>
float</code></dt>
<dd>Rotor resistance in ohms</dd>
<dt><strong><code>Zth</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Thevenin-equivalent inductance (in ohms) of the
induction machine, may be calculated internally
if given machine parameters.</dd>
<dt><strong><code>Rs</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator resistance in ohms</dd>
<dt><strong><code>Lm</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Magnetizing inductance in Henrys</dd>
<dt><strong><code>Lls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator leakage inductance in Henrys, default=0</dd>
<dt><strong><code>Llr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor leakage inductance in Henrys, default=0</dd>
<dt><strong><code>Ls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator inductance in Henrys</dd>
<dt><strong><code>Lr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor inductance in Henrys</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System (electrical) frequency in Hz, default=60</dd>
<dt><strong><code>calcX</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force system to calculate
system reactances with system frequency, or to
treat them as previously-calculated reactances.
default=True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>s_peak</code></strong> :&ensp;<code>
float</code></dt>
<dd>The peak slip for the induction machine described.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.indmachvth" href="#electricpy.indmachvth">indmachvth()</a></code></dt>
<dd>Induction Machine Thevenin Voltage Calculator</dd>
<dt><code><a title="electricpy.indmachzth" href="#electricpy.indmachzth">indmachzth()</a></code></dt>
<dd>Induction Machine Thevenin Impedance Calculator</dd>
<dt><code><a title="electricpy.indmachpem" href="#electricpy.indmachpem">indmachpem()</a></code></dt>
<dd>Induction Machine Electro-Mechanical Power Calculator</dd>
<dt><code><a title="electricpy.indmachtem" href="#electricpy.indmachtem">indmachtem()</a></code></dt>
<dd>Induction Machine Electro-Mechanical Torque Calculator</dd>
<dt><code><a title="electricpy.indmachpktorq" href="#electricpy.indmachpktorq">indmachpktorq()</a></code></dt>
<dd>Induction Machine Peak Torque Calculator</dd>
<dt><code><a title="electricpy.indmachiar" href="#electricpy.indmachiar">indmachiar()</a></code></dt>
<dd>Induction Machine Phase-A Rotor Current Calculator</dd>
<dt><code><a title="electricpy.indmachstarttorq" href="#electricpy.indmachstarttorq">indmachstarttorq()</a></code></dt>
<dd>Induction Machine Starting Torque Calculator</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indmachpkslip(Rr,Zth=None,Rs=0,Lm=0,Lls=0,Llr=0,Ls=None,
                  Lr=None,freq=60,calcX=True):
    &#34;&#34;&#34;
    Induction Machine Slip at Peak Torque Calculator
    
    Function to calculate the slip encountered by an induction machine
    with the parameters specified when the machine is generating peak
    torque. Uses formula as shown below.
    
    .. math:: \\text{slip} = \\frac{R_r}{|Z_{th}|}
    
    where:

    .. math::
       Z_{th} = \\frac{(R_s+j\\omega L_{ls})j\\omega L_m}
       {R_s+j\\omega(L_{ls}+L_m)}+j\\omega L_{lr}
    
    Parameters
    ----------
    Rr:         float
                Rotor resistance in ohms
    Zth:        complex, optional
                Thevenin-equivalent inductance (in ohms) of the
                induction machine, may be calculated internally
                if given machine parameters.
    Rs:         float, optional
                Stator resistance in ohms
    Lm:         float, optional
                Magnetizing inductance in Henrys
    Lls:        float, optional
                Stator leakage inductance in Henrys, default=0
    Llr:        float, optional
                Rotor leakage inductance in Henrys, default=0
    Ls:         float, optional
                Stator inductance in Henrys
    Lr:         float, optional
                Rotor inductance in Henrys
    freq:       float, optional
                System (electrical) frequency in Hz, default=60
    calcX:      bool, optional
                Control argument to force system to calculate
                system reactances with system frequency, or to
                treat them as previously-calculated reactances.
                default=True
    
    Returns
    -------
    s_peak:     float
                The peak slip for the induction machine described.
    
    See Also
    --------
    indmachvth:         Induction Machine Thevenin Voltage Calculator
    indmachzth:         Induction Machine Thevenin Impedance Calculator
    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
    indmachpktorq:      Induction Machine Peak Torque Calculator
    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
    indmachstarttorq:   Induction Machine Starting Torque Calculator
    &#34;&#34;&#34;
    # Condition Inputs
    w = 2*_np.pi*freq
    if Ls != None: # Use Ls instead of Lls
        Lls = Ls - Lm
    if Lr != None: # Use Lr instead of Llr
        Llr = Lr - Lm
    if calcX: # Convert Inductances to Reactances
        Lm *= w
        Lls *= w
        Llr *= w
    # Test for Valid Input Set
    if Zth == None:
        if not all((Rs,Llr,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Zth
        Zth = indmachzth(Rs,Lm,Lls,Ll,Ls,Lr,freq,calcX)
    # Calculate Peak Slip
    s_peak = Rr / abs(Zth)
    return( s_peak )</code></pre>
</details>
</dd>
<dt id="electricpy.indmachpktorq"><code class="name flex">
<span>def <span class="ident">indmachpktorq</span></span>(<span>Rr, s_pk=None, Iar=None, Vth=None, Zth=None, Vas=0, Rs=0, Lm=0, Lls=0, Llr=0, Ls=None, Lr=None, freq=60, calcX=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Induction Machine Peak Torque Calculator</p>
<p>Calculation function to find the peak torque for an
induction machine given the thevenin voltage and impedance.</p>
<p>This current is calculated using the following formulas:</p>
<p>[ T_{em}=(|I_{a_{\text{rotor}}}|)^2\cdot\frac{R_r}
{\text{slip}_{\text{peak}}} ]
where:</p>
<p>[
]
[
]
[ Z_{th} = \frac{(R_s+j\omega L_{ls})j\omega L_m}
{R_s+j\omega(L_{ls}+L_m)}+j\omega L_{lr} ]
[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Rr</code></strong> :&ensp;<code>
float</code></dt>
<dd>Rotor resistance in Ohms</dd>
<dt><strong><code>s_pk</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Peak induction machine slip, may be calculated
internally if remaining machine characteristics are
provided.</dd>
<dt><strong><code>Iar</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Phase-A, Rotor Current in Amps, may be calculated
internally if remaining machine characteristics are
provided.</dd>
<dt><strong><code>Vth</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Thevenin-equivalent stator voltage of the
induction machine, may be calculated internally
if given stator voltage and machine parameters.</dd>
<dt><strong><code>Zth</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Thevenin-equivalent inductance (in ohms) of the
induction machine, may be calculated internally
if given machine parameters.</dd>
<dt><strong><code>Vas</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Terminal Stator Voltage in Volts</dd>
<dt><strong><code>Rs</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator resistance in ohms</dd>
<dt><strong><code>Lm</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Magnetizing inductance in Henrys</dd>
<dt><strong><code>Lls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator leakage inductance in Henrys, default=0</dd>
<dt><strong><code>Llr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor leakage inductance in Henrys, default=0</dd>
<dt><strong><code>Ls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator inductance in Henrys</dd>
<dt><strong><code>Lr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor inductance in Henrys</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System (electrical) frequency in Hz, default=60</dd>
<dt><strong><code>calcX</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force system to calculate
system reactances with system frequency, or to
treat them as previously-calculated reactances.
default=True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Tpk</code></strong> :&ensp;<code>
float</code></dt>
<dd>Peak torque of specified induction machine in
newton-meters.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.indmachvth" href="#electricpy.indmachvth">indmachvth()</a></code></dt>
<dd>Induction Machine Thevenin Voltage Calculator</dd>
<dt><code><a title="electricpy.indmachzth" href="#electricpy.indmachzth">indmachzth()</a></code></dt>
<dd>Induction Machine Thevenin Impedance Calculator</dd>
<dt><code><a title="electricpy.indmachpem" href="#electricpy.indmachpem">indmachpem()</a></code></dt>
<dd>Induction Machine Electro-Mechanical Power Calculator</dd>
<dt><code><a title="electricpy.indmachtem" href="#electricpy.indmachtem">indmachtem()</a></code></dt>
<dd>Induction Machine Electro-Mechanical Torque Calculator</dd>
<dt><code><a title="electricpy.indmachpkslip" href="#electricpy.indmachpkslip">indmachpkslip()</a></code></dt>
<dd>Induction Machine Peak Slip Calculator</dd>
<dt><code><a title="electricpy.indmachiar" href="#electricpy.indmachiar">indmachiar()</a></code></dt>
<dd>Induction Machine Phase-A Rotor Current Calculator</dd>
<dt><code><a title="electricpy.indmachstarttorq" href="#electricpy.indmachstarttorq">indmachstarttorq()</a></code></dt>
<dd>Induction Machine Starting Torque Calculator</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indmachpktorq(Rr,s_pk=None,Iar=None,Vth=None,Zth=None,Vas=0,Rs=0,
                  Lm=0,Lls=0,Llr=0,Ls=None,Lr=None,freq=60,calcX=True):
    &#34;&#34;&#34;
    Induction Machine Peak Torque Calculator
    
    Calculation function to find the peak torque for an
    induction machine given the thevenin voltage and impedance.
    
    This current is calculated using the following formulas:
    
    .. math:: 
       T_{em}=(|I_{a_{\\text{rotor}}}|)^2\\cdot\\frac{R_r}
       {\\text{slip}_{\\text{peak}}}
    
    where:
    
    .. math:: I_{a_{\\text{rotor}}} = \\frac{V_{th}}{|Z_{th}|+Z_{th}}
    
    .. math:: V_{th}=\\frac{j\\omega L_m}{R_s+j\\omega(L_{ls}+L_m)}V_{as}
    
    .. math::
       Z_{th} = \\frac{(R_s+j\\omega L_{ls})j\\omega L_m}
       {R_s+j\\omega(L_{ls}+L_m)}+j\\omega L_{lr}
    
    .. math:: \\omega = \\omega_{es} = 2\\pi\\cdot f_{\\text{electric}}
    
    Parameters
    ----------
    Rr:         float
                Rotor resistance in Ohms
    s_pk:       float, optional
                Peak induction machine slip, may be calculated
                internally if remaining machine characteristics are
                provided.
    Iar:        complex, optional
                Phase-A, Rotor Current in Amps, may be calculated
                internally if remaining machine characteristics are
                provided.
    Vth:        complex, optional
                Thevenin-equivalent stator voltage of the
                induction machine, may be calculated internally
                if given stator voltage and machine parameters.
    Zth:        complex, optional
                Thevenin-equivalent inductance (in ohms) of the
                induction machine, may be calculated internally
                if given machine parameters.
    Vas:        complex, optional
                Terminal Stator Voltage in Volts
    Rs:         float, optional
                Stator resistance in ohms
    Lm:         float, optional
                Magnetizing inductance in Henrys
    Lls:        float, optional
                Stator leakage inductance in Henrys, default=0
    Llr:        float, optional
                Rotor leakage inductance in Henrys, default=0
    Ls:         float, optional
                Stator inductance in Henrys
    Lr:         float, optional
                Rotor inductance in Henrys
    freq:       float, optional
                System (electrical) frequency in Hz, default=60
    calcX:      bool, optional
                Control argument to force system to calculate
                system reactances with system frequency, or to
                treat them as previously-calculated reactances.
                default=True
    
    Returns
    -------
    Tpk:        float
                Peak torque of specified induction machine in
                newton-meters.
    
    See Also
    --------
    indmachvth:         Induction Machine Thevenin Voltage Calculator
    indmachzth:         Induction Machine Thevenin Impedance Calculator
    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
    indmachpkslip:      Induction Machine Peak Slip Calculator
    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
    indmachstarttorq:   Induction Machine Starting Torque Calculator
    &#34;&#34;&#34;
    # Condition Inputs
    w = 2*_np.pi*freq
    if Ls != None: # Use Ls instead of Lls
        Lls = Ls - Lm
    if Lr != None: # Use Lr instead of Llr
        Llr = Lr - Lm
    if p != 0: # Calculate Sync. Speed from Num. Poles
        wsyn = w/(p/2)
    if calcX: # Convert Inductances to Reactances
        Lm *= w
        Lls *= w
        Llr *= w
    # Test for Valid Input Set
    if Vth == None:
        if not all((Vas,Rs,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Vth
        Vth = indmachvth(Vas,Rs,Lm,Lls,Ls,freq,calcX)
    if Zth == None:
        if not all((Rs,Llr,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Zth
        Zth = indmachzth(Rs,Lm,Lls,Ll,Ls,Lr,freq,calcX)
    if Iar == None:
        if not all((Vth,Zth)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Ias
        Iar = indmachiar(Vth=Vth,Zth=Zth)
    if s_pk == None:
        if not all((Rr,Zth)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Peak Slip
        s_pk = indmachpkslip(Rr=Rr,Zth=Zth)
    # Use Terms to Calculate Peak Torque
    Tpk = abs(Iar)**2 * Rr/s_pk
    return(Tpk)</code></pre>
</details>
</dd>
<dt id="electricpy.indmachstarttorq"><code class="name flex">
<span>def <span class="ident">indmachstarttorq</span></span>(<span>Rr, Iar=None, Vth=None, Zth=None, Vas=0, Rs=0, Lm=0, Lls=0, Llr=0, Ls=None, Lr=None, freq=60, calcX=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Induction Machine Starting Torque Calculator</p>
<p>Calculation function to find the starting torque for an
induction machine given the thevenin voltage and impedance.</p>
<p>This current is calculated using the following formulas:</p>
<p>[ T_{em}=(|I_{a_{\text{rotor}}}|)^2\cdot\frac{R_r}
{\text{slip}_{\text{peak}}} ]
where:</p>
<p>[
]
[ I_{a_{\text{rotor}}} = \frac{V_{th}}{\frac{R_r}{\text{slip}}+Z_{th}} ]
[
]
[ Z_{th} = \frac{(R_s+j\omega L_{ls})j\omega L_m}
{R_s+j\omega(L_{ls}+L_m)}+j\omega L_{lr} ]
[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Rr</code></strong> :&ensp;<code>
float</code></dt>
<dd>Rotor resistance in Ohms</dd>
<dt><strong><code>Iar</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Phase-A, Rotor Current in Amps, may be calculated
internally if remaining machine characteristics are
provided.</dd>
<dt><strong><code>Vth</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Thevenin-equivalent stator voltage of the
induction machine, may be calculated internally
if given stator voltage and machine parameters.</dd>
<dt><strong><code>Zth</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Thevenin-equivalent inductance (in ohms) of the
induction machine, may be calculated internally
if given machine parameters.</dd>
<dt><strong><code>Vas</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Terminal Stator Voltage in Volts</dd>
<dt><strong><code>Rs</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator resistance in ohms</dd>
<dt><strong><code>Lm</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Magnetizing inductance in Henrys</dd>
<dt><strong><code>Lls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator leakage inductance in Henrys, default=0</dd>
<dt><strong><code>Llr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor leakage inductance in Henrys, default=0</dd>
<dt><strong><code>Ls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator inductance in Henrys</dd>
<dt><strong><code>Lr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor inductance in Henrys</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System (electrical) frequency in Hz, default=60</dd>
<dt><strong><code>calcX</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force system to calculate
system reactances with system frequency, or to
treat them as previously-calculated reactances.
default=True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Tstart</code></strong> :&ensp;<code>
float</code></dt>
<dd>Peak torque of specified induction machine in
newton-meters.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.indmachvth" href="#electricpy.indmachvth">indmachvth()</a></code></dt>
<dd>Induction Machine Thevenin Voltage Calculator</dd>
<dt><code><a title="electricpy.indmachzth" href="#electricpy.indmachzth">indmachzth()</a></code></dt>
<dd>Induction Machine Thevenin Impedance Calculator</dd>
<dt><code><a title="electricpy.indmachpem" href="#electricpy.indmachpem">indmachpem()</a></code></dt>
<dd>Induction Machine Electro-Mechanical Power Calculator</dd>
<dt><code><a title="electricpy.indmachtem" href="#electricpy.indmachtem">indmachtem()</a></code></dt>
<dd>Induction Machine Electro-Mechanical Torque Calculator</dd>
<dt><code><a title="electricpy.indmachpkslip" href="#electricpy.indmachpkslip">indmachpkslip()</a></code></dt>
<dd>Induction Machine Peak Slip Calculator</dd>
<dt><code><a title="electricpy.indmachpktorq" href="#electricpy.indmachpktorq">indmachpktorq()</a></code></dt>
<dd>Induction Machine Peak Torque Calculator</dd>
<dt><code><a title="electricpy.indmachiar" href="#electricpy.indmachiar">indmachiar()</a></code></dt>
<dd>Induction Machine Phase-A Rotor Current Calculator</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indmachstarttorq(Rr,Iar=None,Vth=None,Zth=None,Vas=0,Rs=0,Lm=0,
                     Lls=0,Llr=0,Ls=None,Lr=None,freq=60,calcX=True):
    &#34;&#34;&#34;
    Induction Machine Starting Torque Calculator
    
    Calculation function to find the starting torque for an
    induction machine given the thevenin voltage and impedance.
    
    This current is calculated using the following formulas:
    
    .. math:: 
       T_{em}=(|I_{a_{\\text{rotor}}}|)^2\\cdot\\frac{R_r}
       {\\text{slip}_{\\text{peak}}}
    
    where:
    
    .. math:: \\text{slip} = 1
    
    .. math::
       I_{a_{\\text{rotor}}} = \\frac{V_{th}}{\\frac{R_r}{\\text{slip}}+Z_{th}}
    
    .. math:: V_{th}=\\frac{j\\omega L_m}{R_s+j\\omega(L_{ls}+L_m)}V_{as}
    
    .. math::
       Z_{th} = \\frac{(R_s+j\\omega L_{ls})j\\omega L_m}
       {R_s+j\\omega(L_{ls}+L_m)}+j\\omega L_{lr}
    
    .. math:: \\omega = \\omega_{es} = 2\\pi\\cdot f_{\\text{electric}}
    
    Parameters
    ----------
    Rr:         float
                Rotor resistance in Ohms
    Iar:        complex, optional
                Phase-A, Rotor Current in Amps, may be calculated
                internally if remaining machine characteristics are
                provided.
    Vth:        complex, optional
                Thevenin-equivalent stator voltage of the
                induction machine, may be calculated internally
                if given stator voltage and machine parameters.
    Zth:        complex, optional
                Thevenin-equivalent inductance (in ohms) of the
                induction machine, may be calculated internally
                if given machine parameters.
    Vas:        complex, optional
                Terminal Stator Voltage in Volts
    Rs:         float, optional
                Stator resistance in ohms
    Lm:         float, optional
                Magnetizing inductance in Henrys
    Lls:        float, optional
                Stator leakage inductance in Henrys, default=0
    Llr:        float, optional
                Rotor leakage inductance in Henrys, default=0
    Ls:         float, optional
                Stator inductance in Henrys
    Lr:         float, optional
                Rotor inductance in Henrys
    freq:       float, optional
                System (electrical) frequency in Hz, default=60
    calcX:      bool, optional
                Control argument to force system to calculate
                system reactances with system frequency, or to
                treat them as previously-calculated reactances.
                default=True
    
    Returns
    -------
    Tstart:     float
                Peak torque of specified induction machine in
                newton-meters.
    
    See Also
    --------
    indmachvth:         Induction Machine Thevenin Voltage Calculator
    indmachzth:         Induction Machine Thevenin Impedance Calculator
    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
    indmachpkslip:      Induction Machine Peak Slip Calculator
    indmachpktorq:      Induction Machine Peak Torque Calculator
    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
    &#34;&#34;&#34;
    # Condition Inputs
    w = 2*_np.pi*freq
    if Ls != None: # Use Ls instead of Lls
        Lls = Ls - Lm
    if Lr != None: # Use Lr instead of Llr
        Llr = Lr - Lm
    if p != 0: # Calculate Sync. Speed from Num. Poles
        wsyn = w/(p/2)
    if calcX: # Convert Inductances to Reactances
        Lm *= w
        Lls *= w
        Llr *= w
    # Slip is 1 (one) for starting
    slip = 1
    # Test for Valid Input Set
    if Vth == None:
        if not all((Vas,Rs,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Vth
        Vth = indmachvth(Vas,Rs,Lm,Lls,Ls,freq,calcX)
    if Zth == None:
        if not all((Rs,Llr,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Zth
        Zth = indmachzth(Rs,Lm,Lls,Ll,Ls,Lr,freq,calcX)
    if Iar == None:
        if not all((Vth,Zth)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Ias
        Iar = Vth / (Rr/slip + Zth)
    # Use Terms to Calculate Peak Torque
    Tstart = abs(Iar)**2 * Rr/s_pk
    return(Tstart)</code></pre>
</details>
</dd>
<dt id="electricpy.indmachtem"><code class="name flex">
<span>def <span class="ident">indmachtem</span></span>(<span>slip, Rr, p=0, Vth=None, Zth=None, Vas=0, Rs=0, Lm=0, Lls=0, Llr=0, Ls=None, Lr=None, wsyn=None, freq=60, calcX=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Induction Machine Torque Calculator</p>
<p>Calculate the torque generated or consumed by an induction
machine given the machine parameters of Vth and Zth by use
of the equation below.</p>
<p>[ T_{em}=\frac{3|V_{th_{\text{stator}}}|^2}
{\left[\left(\frac{R_r}{slip}+R_{th_{\text{stator}}}\right)^2
+X_{th_{\text{stator}}}\right]}\frac{R_r}{slip*\omega_{sync}} ]
where:</p>
<p>[ \omega_{sync}=\frac{\omega_{es}}{\left(\frac{poles}{2}\right)} ]
Parameters</p>
<hr>
<dl>
<dt><strong><code>slip</code></strong> :&ensp;<code>
float</code></dt>
<dd>The mechanical/electrical slip factor of the
induction machine.</dd>
<dt><strong><code>Rr</code></strong> :&ensp;<code>
float</code></dt>
<dd>Rotor resistance in ohms</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>
int</code>, optional</dt>
<dd>Number of poles in the induction machine</dd>
<dt><strong><code>Vth</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Thevenin-equivalent stator voltage of the
induction machine, may be calculated internally
if given stator voltage and machine parameters.</dd>
<dt><strong><code>Zth</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Thevenin-equivalent inductance (in ohms) of the
induction machine, may be calculated internally
if given machine parameters.</dd>
<dt><strong><code>Vas</code></strong> :&ensp;<code>
complex</code>, optional</dt>
<dd>Terminal Stator Voltage in Volts</dd>
<dt><strong><code>Rs</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator resistance in ohms</dd>
<dt><strong><code>Lm</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Magnetizing inductance in Henrys</dd>
<dt><strong><code>Lls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator leakage inductance in Henrys, default=0</dd>
<dt><strong><code>Llr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor leakage inductance in Henrys, default=0</dd>
<dt><strong><code>Ls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator inductance in Henrys</dd>
<dt><strong><code>Lr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor inductance in Henrys</dd>
<dt><strong><code>wsyn</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Synchronous speed in rad/sec, may be specified
directly as a replacement of p (number of poles).</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System (electrical) frequency in Hz, default=60</dd>
<dt><strong><code>calcX</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force system to calculate
system reactances with system frequency, or to
treat them as previously-calculated reactances.
default=True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Tem</code></strong> :&ensp;<code>
float</code></dt>
<dd>Torque (in Newton-meters) that is produced or consumed
by the mechanical portion of the induction machine.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.indmachvth" href="#electricpy.indmachvth">indmachvth()</a></code></dt>
<dd>Induction Machine Thevenin Voltage Calculator</dd>
<dt><code><a title="electricpy.indmachzth" href="#electricpy.indmachzth">indmachzth()</a></code></dt>
<dd>Induction Machine Thevenin Impedance Calculator</dd>
<dt><code><a title="electricpy.indmachpem" href="#electricpy.indmachpem">indmachpem()</a></code></dt>
<dd>Induction Machine Electro-Mechanical Power Calculator</dd>
<dt><code><a title="electricpy.indmachpkslip" href="#electricpy.indmachpkslip">indmachpkslip()</a></code></dt>
<dd>Induction Machine Peak Slip Calculator</dd>
<dt><code><a title="electricpy.indmachpktorq" href="#electricpy.indmachpktorq">indmachpktorq()</a></code></dt>
<dd>Induction Machine Peak Torque Calculator</dd>
<dt><code><a title="electricpy.indmachiar" href="#electricpy.indmachiar">indmachiar()</a></code></dt>
<dd>Induction Machine Phase-A Rotor Current Calculator</dd>
<dt><code><a title="electricpy.indmachstarttorq" href="#electricpy.indmachstarttorq">indmachstarttorq()</a></code></dt>
<dd>Induction Machine Starting Torque Calculator</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indmachtem(slip,Rr,p=0,Vth=None,Zth=None,Vas=0,Rs=0,Lm=0,Lls=0,
               Llr=0,Ls=None,Lr=None,wsyn=None,freq=60,calcX=True):
    &#34;&#34;&#34;
    Induction Machine Torque Calculator
    
    Calculate the torque generated or consumed by an induction
    machine given the machine parameters of Vth and Zth by use
    of the equation below.
    
    .. math:: 
       T_{em}=\\frac{3|V_{th_{\\text{stator}}}|^2}
       {\\left[\\left(\\frac{R_r}{slip}+R_{th_{\\text{stator}}}\\right)^2
       +X_{th_{\\text{stator}}}\\right]}\\frac{R_r}{slip*\\omega_{sync}}
    
    where:
    
    .. math:: 
       \\omega_{sync}=\\frac{\\omega_{es}}{\\left(\\frac{poles}{2}\\right)}
    
    Parameters
    ----------
    slip:       float
                The mechanical/electrical slip factor of the
                induction machine.
    Rr:         float
                Rotor resistance in ohms
    p:          int, optional
                Number of poles in the induction machine
    Vth:        complex, optional
                Thevenin-equivalent stator voltage of the
                induction machine, may be calculated internally
                if given stator voltage and machine parameters.
    Zth:        complex, optional
                Thevenin-equivalent inductance (in ohms) of the
                induction machine, may be calculated internally
                if given machine parameters.
    Vas:        complex, optional
                Terminal Stator Voltage in Volts
    Rs:         float, optional
                Stator resistance in ohms
    Lm:         float, optional
                Magnetizing inductance in Henrys
    Lls:        float, optional
                Stator leakage inductance in Henrys, default=0
    Llr:        float, optional
                Rotor leakage inductance in Henrys, default=0
    Ls:         float, optional
                Stator inductance in Henrys
    Lr:         float, optional
                Rotor inductance in Henrys
    wsyn:       float, optional
                Synchronous speed in rad/sec, may be specified
                directly as a replacement of p (number of poles).
    freq:       float, optional
                System (electrical) frequency in Hz, default=60
    calcX:      bool, optional
                Control argument to force system to calculate
                system reactances with system frequency, or to
                treat them as previously-calculated reactances.
                default=True
    
    Returns
    -------
    Tem:        float
                Torque (in Newton-meters) that is produced or consumed
                by the mechanical portion of the induction machine.
    
    See Also
    --------
    indmachvth:         Induction Machine Thevenin Voltage Calculator
    indmachzth:         Induction Machine Thevenin Impedance Calculator
    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
    indmachpkslip:      Induction Machine Peak Slip Calculator
    indmachpktorq:      Induction Machine Peak Torque Calculator
    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
    indmachstarttorq:   Induction Machine Starting Torque Calculator
    &#34;&#34;&#34;
    # Condition Inputs
    w = 2*_np.pi*freq
    if Ls != None: # Use Ls instead of Lls
        Lls = Ls - Lm
    if Lr != None: # Use Lr instead of Llr
        Llr = Lr - Lm
    if p != 0: # Calculate Sync. Speed from Num. Poles
        wsyn = w/(p/2)
    if calcX: # Convert Inductances to Reactances
        Lm *= w
        Lls *= w
        Llr *= w
    # Test for Valid Input Set
    if not any((p, wsync)):
        raise ValueError(&#34;Poles or Synchronous Speed must be specified.&#34;)
    if Vth == None:
        if not all((Vas,Rs,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Vth
        Vth = indmachvth(Vas,Rs,Lm,Lls,Ls,freq,calcX)
    if Zth == None:
        if not all((Rs,Llr,Lm,Lls)):
            raise ValueError(&#34;Invalid Argument Set, too few provided.&#34;)
        # Valid Argument Set, Calculate Zth
        Zth = indmachzth(Rs,Lm,Lls,Ll,Ls,Lr,freq,calcX)
    # Use Terms to Calculate Pem
    Rth = Zth.real
    Xth = Zth.imag
    Tem = 3*abs(Vth)**2/((Rr/slip+Rth)**2+Xth) * Rr/(slip*wsyn)
    return(Tem)</code></pre>
</details>
</dd>
<dt id="electricpy.indmachvth"><code class="name flex">
<span>def <span class="ident">indmachvth</span></span>(<span>Vas, Rs, Lm, Lls=0, Ls=None, freq=60, calcX=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Induction Machine Thevenin Voltage Calculator</p>
<p>Function to calculate the Thevenin equivalent voltage of an
induction machine given a specific set of parameters.</p>
<p>[
]
where:</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Vas</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Terminal Stator Voltage in Volts</dd>
<dt><strong><code>Rs</code></strong> :&ensp;<code>
float</code></dt>
<dd>Stator resistance in ohms</dd>
<dt><strong><code>Lm</code></strong> :&ensp;<code>
float</code></dt>
<dd>Magnetizing inductance in Henrys</dd>
<dt><strong><code>Lls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator leakage inductance in Henrys, default=0</dd>
<dt><strong><code>Ls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator inductance in Henrys</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System (electrical) frequency in Hz, default=60</dd>
<dt><strong><code>calcX</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force system to calculate
system reactances with system frequency, or to
treat them as previously-calculated reactances.
default=True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Vth</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Thevenin-Equivalent voltage (in volts) of induction
machine described.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.indmachzth" href="#electricpy.indmachzth">indmachzth()</a></code></dt>
<dd>Induction Machine Thevenin Impedance Calculator</dd>
<dt><code><a title="electricpy.indmachpem" href="#electricpy.indmachpem">indmachpem()</a></code></dt>
<dd>Induction Machine Electro-Mechanical Power Calculator</dd>
<dt><code><a title="electricpy.indmachtem" href="#electricpy.indmachtem">indmachtem()</a></code></dt>
<dd>Induction Machine Electro-Mechanical Torque Calculator</dd>
<dt><code><a title="electricpy.indmachpkslip" href="#electricpy.indmachpkslip">indmachpkslip()</a></code></dt>
<dd>Induction Machine Peak Slip Calculator</dd>
<dt><code><a title="electricpy.indmachpktorq" href="#electricpy.indmachpktorq">indmachpktorq()</a></code></dt>
<dd>Induction Machine Peak Torque Calculator</dd>
<dt><code><a title="electricpy.indmachiar" href="#electricpy.indmachiar">indmachiar()</a></code></dt>
<dd>Induction Machine Phase-A Rotor Current Calculator</dd>
<dt><code><a title="electricpy.indmachstarttorq" href="#electricpy.indmachstarttorq">indmachstarttorq()</a></code></dt>
<dd>Induction Machine Starting Torque Calculator</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indmachvth(Vas,Rs,Lm,Lls=0,Ls=None,freq=60,calcX=True):
    &#34;&#34;&#34;
    Induction Machine Thevenin Voltage Calculator
    
    Function to calculate the Thevenin equivalent voltage of an
    induction machine given a specific set of parameters.
    
    .. math:: V_{th}=\\frac{j\\omega L_m}{R_s+j\\omega(L_{ls}+L_m)}V_{as}
    
    where:
    
    .. math:: \\omega = \\omega_{es} = 2\\pi\\cdot f_{\\text{electric}}
    
    Parameters
    ----------
    Vas:        complex
                Terminal Stator Voltage in Volts
    Rs:         float
                Stator resistance in ohms
    Lm:         float
                Magnetizing inductance in Henrys
    Lls:        float, optional
                Stator leakage inductance in Henrys, default=0
    Ls:         float, optional
                Stator inductance in Henrys
    freq:       float, optional
                System (electrical) frequency in Hz, default=60
    calcX:      bool, optional
                Control argument to force system to calculate
                system reactances with system frequency, or to
                treat them as previously-calculated reactances.
                default=True
    
    Returns
    -------
    Vth:        complex
                Thevenin-Equivalent voltage (in volts) of induction
                machine described.
    
    See Also
    --------
    indmachzth:         Induction Machine Thevenin Impedance Calculator
    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
    indmachpkslip:      Induction Machine Peak Slip Calculator
    indmachpktorq:      Induction Machine Peak Torque Calculator
    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
    indmachstarttorq:   Induction Machine Starting Torque Calculator
    &#34;&#34;&#34;
    # Condition Inputs
    if Ls != None: # Use Ls instead of Lls
        Lls = Ls - Lm
    if calcX: # Convert Inductances to Reactances
        w = 2*_np.pi*freq
        Lm *= w
        Lls *= w
    # Calculate Thevenin Voltage, Return
    Vth = 1j*Lm / (Rs + 1j*(Lls+Lm)) * Vas
    return(Vth)</code></pre>
</details>
</dd>
<dt id="electricpy.indmachzth"><code class="name flex">
<span>def <span class="ident">indmachzth</span></span>(<span>Rs, Lm, Lls=0, Llr=0, Ls=None, Lr=None, freq=60, calcX=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Induction Machine Thevenin Impedance Calculator</p>
<p>Function to calculate the Thevenin equivalent impedance of an
induction machine given a specific set of parameters.</p>
<p>[ Z_{th} = \frac{(R_s+j\omega L_{ls})j\omega L_m}
{R_s+j\omega(L_{ls}+L_m)}+j\omega L_{lr} ]
where:</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Rs</code></strong> :&ensp;<code>
float</code></dt>
<dd>Stator resistance in ohms</dd>
<dt><strong><code>Lm</code></strong> :&ensp;<code>
float</code></dt>
<dd>Magnetizing inductance in Henrys</dd>
<dt><strong><code>Lls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator leakage inductance in Henrys, default=0</dd>
<dt><strong><code>Llr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor leakage inductance in Henrys, default=0</dd>
<dt><strong><code>Ls</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Stator inductance in Henrys</dd>
<dt><strong><code>Lr</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Rotor inductance in Henrys</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System (electrical) frequency in Hz, default=60</dd>
<dt><strong><code>calcX</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force system to calculate
system reactances with system frequency, or to
treat them as previously-calculated reactances.
default=True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Zth</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Thevenin-Equivalent impedance (in ohms) of induction
machine described.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.indmachvth" href="#electricpy.indmachvth">indmachvth()</a></code></dt>
<dd>Induction Machine Thevenin Voltage Calculator</dd>
<dt><code><a title="electricpy.indmachpem" href="#electricpy.indmachpem">indmachpem()</a></code></dt>
<dd>Induction Machine Electro-Mechanical Power Calculator</dd>
<dt><code><a title="electricpy.indmachtem" href="#electricpy.indmachtem">indmachtem()</a></code></dt>
<dd>Induction Machine Electro-Mechanical Torque Calculator</dd>
<dt><code><a title="electricpy.indmachpkslip" href="#electricpy.indmachpkslip">indmachpkslip()</a></code></dt>
<dd>Induction Machine Peak Slip Calculator</dd>
<dt><code><a title="electricpy.indmachpktorq" href="#electricpy.indmachpktorq">indmachpktorq()</a></code></dt>
<dd>Induction Machine Peak Torque Calculator</dd>
<dt><code><a title="electricpy.indmachiar" href="#electricpy.indmachiar">indmachiar()</a></code></dt>
<dd>Induction Machine Phase-A Rotor Current Calculator</dd>
<dt><code><a title="electricpy.indmachstarttorq" href="#electricpy.indmachstarttorq">indmachstarttorq()</a></code></dt>
<dd>Induction Machine Starting Torque Calculator</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indmachzth(Rs,Lm,Lls=0,Llr=0,Ls=None,Lr=None,freq=60,calcX=True):
    &#34;&#34;&#34;
    Induction Machine Thevenin Impedance Calculator
    
    Function to calculate the Thevenin equivalent impedance of an
    induction machine given a specific set of parameters.
    
    .. math::
       Z_{th} = \\frac{(R_s+j\\omega L_{ls})j\\omega L_m}
       {R_s+j\\omega(L_{ls}+L_m)}+j\\omega L_{lr}
    
    where:
    
    .. math:: \\omega = \\omega_{es} = 2\\pi\\cdot f_{\\text{electric}}
    
    Parameters
    ----------
    Rs:         float
                Stator resistance in ohms
    Lm:         float
                Magnetizing inductance in Henrys
    Lls:        float, optional
                Stator leakage inductance in Henrys, default=0
    Llr:        float, optional
                Rotor leakage inductance in Henrys, default=0
    Ls:         float, optional
                Stator inductance in Henrys
    Lr:         float, optional
                Rotor inductance in Henrys
    freq:       float, optional
                System (electrical) frequency in Hz, default=60
    calcX:      bool, optional
                Control argument to force system to calculate
                system reactances with system frequency, or to
                treat them as previously-calculated reactances.
                default=True
    
    Returns
    -------
    Zth:        complex
                Thevenin-Equivalent impedance (in ohms) of induction
                machine described.
    
    See Also
    --------
    indmachvth:         Induction Machine Thevenin Voltage Calculator
    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
    indmachpkslip:      Induction Machine Peak Slip Calculator
    indmachpktorq:      Induction Machine Peak Torque Calculator
    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
    indmachstarttorq:   Induction Machine Starting Torque Calculator
    &#34;&#34;&#34;
    # Condition Inputs
    if Ls != None: # Use Ls instead of Lls
        Lls = Ls - Lm
    if Lr != None: # Use Lr instead of Llr
        Llr = Lr - Lm
    if calcX: # Convert Inductances to Reactances
        w = 2*_np.pi*freq
        Lm *= w
        Lls *= w
        Llr *= w
    # Calculate Thevenin Impedance
    Zth = (Rs+1j*Lls)*(1j*Lm) / (Rs+1j*(Lls+Lm)) + 1j*Llr
    return(Zth)</code></pre>
</details>
</dd>
<dt id="electricpy.inductorcharge"><code class="name flex">
<span>def <span class="ident">inductorcharge</span></span>(<span>t, Vs, R, L)</span>
</code></dt>
<dd>
<div class="desc"><p>Charging Inductor Formula</p>
<p>Calculates the Voltage and Current of an inductor
that is charging/storing energy.</p>
<p>[ V_L = V_s<em>e^{\frac{-R</em>t}{L}}//
I_L = \frac{V_s}{R}<em>(1-e^{\frac{-R</em>t}{L}}) ]
Parameters</p>
<hr>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>
float</code></dt>
<dd>Time at which to calculate voltage and current.</dd>
<dt><strong><code>Vs</code></strong> :&ensp;<code>
float</code></dt>
<dd>Charging voltage across inductor and resistor.</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>
float</code></dt>
<dd>Resistance related to inductor.</dd>
<dt><strong><code>L</code></strong> :&ensp;<code>
float</code></dt>
<dd>Inductance value in Henries.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Vl</code></strong> :&ensp;<code>
float</code></dt>
<dd>Voltage across inductor at time t.</dd>
<dt><strong><code>Il</code></strong> :&ensp;<code>
float</code></dt>
<dd>Current through inductor at time t.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inductorcharge(t,Vs,R,L):
    &#34;&#34;&#34;
    Charging Inductor Formula
    
    Calculates the Voltage and Current of an inductor
    that is charging/storing energy.
    
    .. math::
       V_L = V_s*e^{\\frac{-R*t}{L}}//
       I_L = \\frac{V_s}{R}*(1-e^{\\frac{-R*t}{L}})
    
    Parameters
    ----------
    t:          float
                Time at which to calculate voltage and current.
    Vs:         float
                Charging voltage across inductor and resistor.
    R:          float
                Resistance related to inductor.
    L:          float
                Inductance value in Henries.
    
    Returns
    -------
    Vl:         float
                Voltage across inductor at time t.
    Il:         float
                Current through inductor at time t.
    &#34;&#34;&#34;
    Vl = Vs*_np.exp(-R*t/L)
    Il = Vs/R*(1-_np.exp(-R*t/L))
    return(Vl,Il)</code></pre>
</details>
</dd>
<dt id="electricpy.inductordischarge"><code class="name flex">
<span>def <span class="ident">inductordischarge</span></span>(<span>t, Io, R, L)</span>
</code></dt>
<dd>
<div class="desc"><p>Discharging Inductor Formula</p>
<p>Calculates the Voltage and Current of an inductor
that is discharging its stored energy.</p>
<p>[ I_L=I_0<em>e^{\frac{-R</em>t}{L}}//
V_L=I_0<em>R</em>(1-e^{\frac{-R*t}{L}}) ]
Parameters</p>
<hr>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>
float</code></dt>
<dd>Time at which to calculate voltage and current.</dd>
<dt><strong><code>Io</code></strong> :&ensp;<code>
float</code></dt>
<dd>Initial current traveling through inductor.</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>
float</code></dt>
<dd>Resistance being discharged to.</dd>
<dt><strong><code>L</code></strong> :&ensp;<code>
float</code></dt>
<dd>Inductance value in Henries.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Vl</code></strong> :&ensp;<code>
float</code></dt>
<dd>Voltage across inductor at time t.</dd>
<dt><strong><code>Il</code></strong> :&ensp;<code>
float</code></dt>
<dd>Current through inductor at time t.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inductordischarge(t,Io,R,L):
    &#34;&#34;&#34;
    Discharging Inductor Formula
    
    Calculates the Voltage and Current of an inductor
    that is discharging its stored energy.
    
    .. math::
       I_L=I_0*e^{\\frac{-R*t}{L}}//
       V_L=I_0*R*(1-e^{\\frac{-R*t}{L}})
    
    Parameters
    ----------
    t:          float
                Time at which to calculate voltage and current.
    Io:         float
                Initial current traveling through inductor.
    R:          float
                Resistance being discharged to.
    L:          float
                Inductance value in Henries.
    
    Returns
    -------
    Vl:         float
                Voltage across inductor at time t.
    Il:         float
                Current through inductor at time t.
    &#34;&#34;&#34;
    Il = Io*_np.exp(-R*t/L)
    Vl = Io*R*(1-_np.exp(-R*t/L))
    return(Vl,Il)</code></pre>
</details>
</dd>
<dt id="electricpy.inductorenergy"><code class="name flex">
<span>def <span class="ident">inductorenergy</span></span>(<span>L, I)</span>
</code></dt>
<dd>
<div class="desc"><p>Energy Stored in Inductor Formula</p>
<p>Function to calculate the energy stored in an inductor
given the inductance (in Henries) and the current.</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>L</code></strong> :&ensp;<code>
float</code></dt>
<dd>Inductance Value (in Henries)</dd>
<dt><strong><code>I</code></strong> :&ensp;<code>
float</code></dt>
<dd>Current traveling through inductor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>E</code></strong> :&ensp;<code>
float</code></dt>
<dd>The energy stored in the inductor (in Joules).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inductorenergy(L,I):
    &#34;&#34;&#34;
    Energy Stored in Inductor Formula
    
    Function to calculate the energy stored in an inductor
    given the inductance (in Henries) and the current.
    
    .. math:: E=\\frac{1}{2}*L*I^2
    
    Parameters
    ----------
    L:          float
                Inductance Value (in Henries)
    I:          float
                Current traveling through inductor.
    
    Returns
    -------
    E:          float
                The energy stored in the inductor (in Joules).
    &#34;&#34;&#34;
    return(1/2 * L * I**2)</code></pre>
</details>
</dd>
<dt id="electricpy.instpower"><code class="name flex">
<span>def <span class="ident">instpower</span></span>(<span>P, Q, t, freq=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Instantaneous Power Function</p>
<p>This function is designed to calculate the instantaneous power at a
specified time t given the magnitudes of P and Q.</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>
float</code></dt>
<dd>Magnitude of Real Power</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>
float</code></dt>
<dd>Magnitude of Reactive Power</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>
float</code></dt>
<dd>Time at which to evaluate</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System frequency (in Hz), default=60</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Pinst</code></strong> :&ensp;<code> float</code></dt>
<dd>Instantaneous Power at time t</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def instpower(P,Q,t,freq=60):
    &#34;&#34;&#34;
    Instantaneous Power Function
    
    This function is designed to calculate the instantaneous power at a
    specified time t given the magnitudes of P and Q.
    
    .. math:: P_{inst} = P+P*cos(2*\\omega*t)-Q*sin(2*\\omega*t)
    
    Parameters
    ----------
    P:      float
            Magnitude of Real Power
    Q:      float
            Magnitude of Reactive Power
    t:      float
            Time at which to evaluate
    freq:   float, optional
            System frequency (in Hz), default=60
    
    Returns
    -------
    Pinst:  float
            Instantaneous Power at time t
    &#34;&#34;&#34;
    # Evaluate omega
    w = 2*_np.pi*freq
    # Calculate
    Pinst = P + P*_np.cos(2*w*t) - Q*_np.sin(2*w*t)
    return(Pinst)</code></pre>
</details>
</dd>
<dt id="electricpy.ipu"><code class="name flex">
<span>def <span class="ident">ipu</span></span>(<span>S, VLL=None, VLN=None, V1phs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Per-Unit Current Evaluator</p>
<p>Evaluates the per-unit current value given the per-unit
power and voltage bases.</p>
<p>[
]
[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>
float</code></dt>
<dd>The per-unit power base.</dd>
<dt><strong><code>VLL</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Line-to-Line Voltage; default=None</dd>
<dt><strong><code>VLN</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Line-to-Neutral Voltage; default=None</dd>
<dt><strong><code>V1phs</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The voltage base of the single phase system.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Ibase</code></strong> :&ensp;<code>
float</code></dt>
<dd>The per-unit current base.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ipu(S,VLL=None,VLN=None,V1phs=None):
    &#34;&#34;&#34;
    Per-Unit Current Evaluator
    
    Evaluates the per-unit current value given the per-unit
    power and voltage bases.
    
    .. math:: I_{pu}=\\frac{S}{\\sqrt{3}*V_{LL}}
    
    .. math:: I_{pu}=\\frac{S}{3*V_{LN}}
    
    Parameters
    ----------
    S:          float
                The per-unit power base.
    VLL:        float, optional
                The Line-to-Line Voltage; default=None
    VLN:        float, optional
                The Line-to-Neutral Voltage; default=None
    V1phs:      float, optional
                The voltage base of the single phase system.
    
    Returns
    -------
    Ibase:      float
                The per-unit current base.
    &#34;&#34;&#34;
    if(VLL==None and VLN==None):
        raise ValueError(&#34;ERROR: One voltage must be provided.&#34;)
    if VLL!=None:
        return(S/(_np.sqrt(3)*VLL))
    elif VLN != None:
        return(S/(3*VLN))
    else:
        return(S/V1phs)</code></pre>
</details>
</dd>
<dt id="electricpy.iscrl"><code class="name flex">
<span>def <span class="ident">iscrl</span></span>(<span>V, Z, t=None, f=None, mxcurrent=True, alpha=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Short-Circuit-Current (ISC) Calculator</p>
<p>The Isc-RL function (Short Circuit Current for RL Circuit)
is designed to calculate the short-circuit current for an
RL circuit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>
float</code></dt>
<dd>The absolute magnitude of the voltage.</dd>
<dt><strong><code>Z</code></strong> :&ensp;<code>
float</code></dt>
<dd>The complex value of the impedance. (R + jX)</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The time at which the value should be calculated,
should be specified in seconds, default=None</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The system frequency, specified in Hz, default=None</dd>
<dt><strong><code>mxcurrent</code></strong> :&ensp;<code> bool</code>, optional</dt>
<dd>Control variable to enable calculating the value at
maximum current, default=True</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Angle specification, default=None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Opt 1 - (Irms, IAC, K):
The RMS current with maximum DC</code></dt>
<dd>offset, the AC current magnitude,
and the asymmetry factor.</dd>
<dt><code>Opt 2 - (i, iAC, iDC, T):
The Instantaneous current with</code></dt>
<dd>maximum DC offset, the instantaneous
AC current, the instantaneous DC
current, and the time-constant T.</dd>
</dl>
<p>Opt 3 - (Iac):
The RMS current without DC offset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iscrl(V,Z,t=None,f=None,mxcurrent=True,alpha=None):
    &#34;&#34;&#34;
    Short-Circuit-Current (ISC) Calculator
    
    The Isc-RL function (Short Circuit Current for RL Circuit)
    is designed to calculate the short-circuit current for an
    RL circuit.
    
    Parameters
    ----------
    V:          float
                The absolute magnitude of the voltage.
    Z:          float
                The complex value of the impedance. (R + jX)
    t:          float, optional
                The time at which the value should be calculated,
                should be specified in seconds, default=None
    f:          float, optional
                The system frequency, specified in Hz, default=None
    mxcurrent:  bool, optional
                Control variable to enable calculating the value at
                maximum current, default=True
    alpha:      float, optional
                Angle specification, default=None
    
    Returns
    -------
    Opt 1 - (Irms, IAC, K):     The RMS current with maximum DC
                                offset, the AC current magnitude,
                                and the asymmetry factor.
    Opt 2 - (i, iAC, iDC, T):   The Instantaneous current with
                                maximum DC offset, the instantaneous
                                AC current, the instantaneous DC
                                current, and the time-constant T.
    Opt 3 - (Iac):              The RMS current without DC offset.
    &#34;&#34;&#34;
    # Calculate omega, theta, R, and X
    if(f!=None): omega = 2*_np.pi*f
    else: omega = None
    R = abs(Z.real)
    X = abs(Z.imag)
    theta = _np.arctan( X/R )
    
    # If Maximum Current is Desired and No alpha provided
    if(mxcurrent and alpha==None):
        alpha = theta - _np.pi/2
    elif(mxcurrent and alpha!=None):
        raise ValueError(&#34;ERROR: Inappropriate Arguments Provided.\n&#34;+
                         &#34;Not both mxcurrent and alpha can be provided.&#34;)
    
    # Calculate Asymmetrical (total) Current if t != None
    if(t!=None and f!=None):
        # Calculate RMS if none of the angular values are provided
        if(alpha==None and omega==None):
            # Calculate tau
            tau = t/(1/60)
            K = _np.sqrt(1 + 2*_np.exp(-4*_np.pi*tau/(X/R)) )
            IAC = abs(V/Z)
            Irms = K*IAC
            # Return Values
            return(Irms,IAC,K)
        elif(alpha==None or omega==None):
            raise ValueError(&#34;ERROR: Inappropriate Arguments Provided.&#34;)
        # Calculate Instantaneous if all angular values provided
        else:
            # Convert Degrees to Radians
            omega = _np.radians(omega)
            alpha = _np.radians(alpha)
            theta = _np.radians(theta)
            # Calculate T
            T = X/(2*_np.pi*f*R) # seconds
            # Calculate iAC and iDC
            iAC = _np.sqrt(2)*V/Z*_np.sin(omega*t+alpha-theta)
            iDC = -_np.sqrt(2)*V/Z*_np.sin(alpha-theta)*_np.exp(-t/T)
            i = iAC + iDC
            # Return Values
            return(i,iAC,iDC,T)
    elif( (t!=None and f==None) or (t==None and f!=None) ):
        raise ValueError(&#34;ERROR: Inappropriate Arguments Provided.\n&#34;+
                         &#34;Must provide both t and f or neither.&#34;)
    else:
        IAC = abs(V/Z)
        return(Iac)</code></pre>
</details>
</dd>
<dt id="electricpy.kwh"><code class="name flex">
<span>def <span class="ident">kwh</span></span>(<span>BTU)</span>
</code></dt>
<dd>
<div class="desc"><p>BTU to Killo-Watt-Hours Function:</p>
<p>Converts BTU (British Thermal Units) to
kWh (killo-Watt-hours).</p>
<p>[
]
Same as <code><a title="electricpy.kwh" href="#electricpy.kwh">btu_to_kwh()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>BTU</code></strong> :&ensp;<code>
float</code></dt>
<dd>The number of British Thermal Units</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>kWh</code></strong> :&ensp;<code>
float</code></dt>
<dd>The number of killo-Watt-hours</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def btu_to_kwh(BTU):
    &#34;&#34;&#34;
    BTU to Killo-Watt-Hours Function:
    
    Converts BTU (British Thermal Units) to
    kWh (killo-Watt-hours).
    
    .. math:: \\text{kWh} = \\frac{\\text{BTU}}{3412.14}
    
    Same as `kwh`.
    
    Parameters
    ----------
    BTU:        float
                The number of British Thermal Units
    
    Returns
    -------
    kWh:        float
                The number of killo-Watt-hours
    &#34;&#34;&#34;
    return(BTU/3412.14)</code></pre>
</details>
</dd>
<dt id="electricpy.kwh_to_btu"><code class="name flex">
<span>def <span class="ident">kwh_to_btu</span></span>(<span>kWh)</span>
</code></dt>
<dd>
<div class="desc"><p>Killo-Watt-Hours to BTU Function:</p>
<p>Converts kWh (killo-Watt-hours) to BTU
(British Thermal Units).</p>
<p>[
]
Same as <code><a title="electricpy.btu" href="#electricpy.btu">kwh_to_btu()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kWh</code></strong> :&ensp;<code>
float</code></dt>
<dd>The number of killo-Watt-hours</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>BTU</code></strong> :&ensp;<code>
float</code></dt>
<dd>The number of British Thermal Units</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kwh_to_btu(kWh):
    &#34;&#34;&#34;
    Killo-Watt-Hours to BTU Function:
    
    Converts kWh (killo-Watt-hours) to BTU
    (British Thermal Units).
    
    .. math:: \\text{BTU} = \\text{kWh}\\cdot3412.14
    
    Same as `btu`.
    
    Parameters
    ----------
    kWh:        float
                The number of killo-Watt-hours
    
    Returns
    -------
    BTU:        float
                The number of British Thermal Units
    &#34;&#34;&#34;
    return(kWh*3412.14)</code></pre>
</details>
</dd>
<dt id="electricpy.loadedvcapdischarge"><code class="name flex">
<span>def <span class="ident">loadedvcapdischarge</span></span>(<span>t, vo, C, P)</span>
</code></dt>
<dd>
<div class="desc"><p>Loaded Capacitor Discharge Formula</p>
<p>Returns the voltage of a discharging capacitor after time (t -
seconds) given initial voltage (vo - volts), capacitor size
(cap - Farads), and load (P - Watts).</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>
float</code></dt>
<dd>Time at which to calculate voltage.</dd>
<dt><strong><code>vo</code></strong> :&ensp;<code>
float</code></dt>
<dd>Initial capacitor voltage.</dd>
<dt><strong><code>C</code></strong> :&ensp;<code>
float</code></dt>
<dd>Capacitance (in Farads)</dd>
<dt><strong><code>P</code></strong> :&ensp;<code>
float</code></dt>
<dd>Load power consumption (in Watts).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Vt</code></strong> :&ensp;<code>
float</code></dt>
<dd>Voltage of capacitor at time t.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadedvcapdischarge(t,vo,C,P):
    &#34;&#34;&#34;
    Loaded Capacitor Discharge Formula
    
    Returns the voltage of a discharging capacitor after time (t - 
    seconds) given initial voltage (vo - volts), capacitor size
    (cap - Farads), and load (P - Watts).
    
    .. math:: V_t=\\sqrt{v_0^2-2*P*\\frac{t}{C}}
    
    Parameters
    ----------
    t:          float
                Time at which to calculate voltage.
    vo:         float
                Initial capacitor voltage.
    C:          float
                Capacitance (in Farads)
    P:          float
                Load power consumption (in Watts).
    
    Returns
    -------
    Vt:         float
                Voltage of capacitor at time t.
    &#34;&#34;&#34;
    Vt = _np.sqrt(vo**2 - 2*P*t/C)
    return(Vt)</code></pre>
</details>
</dd>
<dt id="electricpy.machslip"><code class="name flex">
<span>def <span class="ident">machslip</span></span>(<span>mech, syn=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Machine Slip Calculator</p>
<p>Given the two parameters (mechanical and synchronous
speed, or frequency) this function will return the
unitless slip of the rotating machine.</p>
<p>[ {\text{syn}} ]
Parameters</p>
<hr>
<dl>
<dt><strong><code>mech</code></strong> :&ensp;<code>
float</code></dt>
<dd>The mechanical frequency (or speed),
of the rotating machine.</dd>
<dt><strong><code>syn</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The synchronous frequency (or speed),
defaults as a frequency set to 60Hz,
default=60</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>slip</code></strong> :&ensp;<code>
float</code></dt>
<dd>The rotating machine's slip constant.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def machslip(mech,syn=60):
    &#34;&#34;&#34;
    Machine Slip Calculator
    
    Given the two parameters (mechanical and synchronous
    speed, or frequency) this function will return the
    unitless slip of the rotating machine.
    
    .. math:: \\text{slip}=\\frac{\\text{syn}-\\text{mech}}
       {\\text{syn}}
    
    Parameters
    ----------
    mech:       float
                The mechanical frequency (or speed),
                of the rotating machine.
    syn:        float, optional
                The synchronous frequency (or speed),
                defaults as a frequency set to 60Hz,
                default=60
    
    Returns
    -------
    slip:       float
                The rotating machine&#39;s slip constant.
    &#34;&#34;&#34;
    slip = (syn-mech)/syn
    return(slip)</code></pre>
</details>
</dd>
<dt id="electricpy.motorstartcap"><code class="name flex">
<span>def <span class="ident">motorstartcap</span></span>(<span>V, I, freq=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Single Phase Motor Starting Capacitor Function</p>
<p>Function to evaluate a reccomended value for the
startup capacitor associated with a single phase
motor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>
float</code></dt>
<dd>Magnitude of motor terminal voltage in volts.</dd>
<dt><strong><code>I</code></strong> :&ensp;<code>
float</code></dt>
<dd>Magnitude of motor no-load current in amps.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Motor/System frequency, default=60.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>
float</code></dt>
<dd>Suggested capacitance in Farads.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def motorstartcap(V,I,freq=60):
    &#34;&#34;&#34;
    Single Phase Motor Starting Capacitor Function
    
    Function to evaluate a reccomended value for the
    startup capacitor associated with a single phase
    motor.
    
    Parameters
    ----------
    V:          float
                Magnitude of motor terminal voltage in volts.
    I:          float
                Magnitude of motor no-load current in amps.
    freq:       float, optional
                Motor/System frequency, default=60.
                
    Returns
    -------
    C:          float
                Suggested capacitance in Farads.
    &#34;&#34;&#34;
    # Condition Inputs
    I = abs(I)
    V = abs(V)
    # Calculate Capacitance
    C = I / (2*_np.pi*freq*V)
    return(C)</code></pre>
</details>
</dd>
<dt id="electricpy.natfreq"><code class="name flex">
<span>def <span class="ident">natfreq</span></span>(<span>C, L, Hz=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Natural Frequency Evaluator</p>
<p>Evaluates the natural frequency (resonant frequency)
of a circuit given the circuit's C and L values. Defaults
to returning values in Hz, but may also return in rad/sec.</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>
float</code></dt>
<dd>Capacitance Value in Farads.</dd>
<dt><strong><code>L</code></strong> :&ensp;<code>
float</code></dt>
<dd>Inductance in Henries.</dd>
<dt><strong><code>Hz</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to set return value in either
Hz or rad/sec; default=True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code></dt>
<dd>Natural (Resonant) frequency, will be in Hz if
argument <em>Hz</em> is set True (default), or rad/sec
if argument is set False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def natfreq(C,L,Hz=True):
    &#34;&#34;&#34;
    Natural Frequency Evaluator
    
    Evaluates the natural frequency (resonant frequency)
    of a circuit given the circuit&#39;s C and L values. Defaults
    to returning values in Hz, but may also return in rad/sec.
    
    .. math:: freq=\\frac{1}{\\sqrt{L*C}*(2*\\pi)}
    
    Parameters
    ----------
    C:          float
                Capacitance Value in Farads.
    L:          float
                Inductance in Henries.
    Hz:         bool, optional
                Control argument to set return value in either
                Hz or rad/sec; default=True.
    
    Returns
    -------
    freq:       float
                Natural (Resonant) frequency, will be in Hz if
                argument *Hz* is set True (default), or rad/sec
                if argument is set False.
    &#34;&#34;&#34;
    # Evaluate Natural Frequency in rad/sec
    freq = 1/_np.sqrt(L*C)
    # Convert to Hz as requested
    if Hz:
        freq = freq / (2*_np.pi)
    return(freq)</code></pre>
</details>
</dd>
<dt id="electricpy.nlinpf"><code class="name flex">
<span>def <span class="ident">nlinpf</span></span>(<span>PFtrue=False, PFdist=False, PFdisp=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Non-Linear Power Factor Evaluator</p>
<p>This function is designed to evaluate one of three unknowns
given the other two. These particular unknowns are the arguments
and as such, they are described in the representative sections
below.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>PFtrue</code></strong> :&ensp;<code>
float, exclusive</code></dt>
<dd>The "True" power-factor, default=None</dd>
<dt><strong><code>PFdist</code></strong> :&ensp;<code>
float, exclusive</code></dt>
<dd>The "Distorted" power-factor, default=None</dd>
<dt><strong><code>PFdisp</code></strong> :&ensp;<code>
float, exclusive</code></dt>
<dd>The "Displacement" power-factor, default=None</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>{unknown}:
This function will return the unknown variable from
the previously described set of variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nlinpf(PFtrue=False,PFdist=False,PFdisp=False):
    &#34;&#34;&#34;
    Non-Linear Power Factor Evaluator
    
    This function is designed to evaluate one of three unknowns
    given the other two. These particular unknowns are the arguments
    and as such, they are described in the representative sections
    below.
    
    Parameters
    ----------
    PFtrue:     float, exclusive
                The &#34;True&#34; power-factor, default=None
    PFdist:     float, exclusive
                The &#34;Distorted&#34; power-factor, default=None
    PFdisp:     float, exclusive
                The &#34;Displacement&#34; power-factor, default=None
    
    Returns
    -------
    {unknown}:  This function will return the unknown variable from
                the previously described set of variables.
    &#34;&#34;&#34;
    if(PFtrue!=None and PFdist!=None and PFdisp!=None):
        raise ValueError(&#34;ERROR: Too many constraints, no solution.&#34;) 
    elif ( PFdist!=None and PFdisp!=None ):
        return( PFdist * PFdisp )
    elif ( PFtrue!=None and PFdisp!=None ):
        return( PFtrue / PFdisp )
    elif ( PFtrue!=None and PFdist!=None ):
        return( PFtrue / PFdist )
    else:
        raise ValueError(&#34;ERROR: Function requires at least two arguments.&#34;)</code></pre>
</details>
</dd>
<dt id="electricpy.parallelz"><code class="name flex">
<span>def <span class="ident">parallelz</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Parallel Impedance Calculator</p>
<p>This function is designed to generate the total parallel
impedance of a set (tuple) of impedances specified as real
or complex values.</p>
<p>[ Z_{eq}=(\frac{1}{Z_1}+\frac{1}{Z_2}+\dots+\frac{1}{Z_n})^{-1} ]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>
tuple</code> of <code>complex</code></dt>
<dd>The tupled input set of impedances, may be a tuple
of any size greater than 2. May be real, complex, or
a combination of the two.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Zp</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The calculated parallel impedance of the input tuple.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parallelz(*args):
    &#34;&#34;&#34;
    Parallel Impedance Calculator
    
    This function is designed to generate the total parallel
    impedance of a set (tuple) of impedances specified as real
    or complex values.
    
    .. math::
       Z_{eq}=(\\frac{1}{Z_1}+\\frac{1}{Z_2}+\\dots+\\frac{1}{Z_n})^{-1}
    
    Parameters
    ----------
    Z:      tuple of complex
            The tupled input set of impedances, may be a tuple
            of any size greater than 2. May be real, complex, or
            a combination of the two.
    
    Returns
    -------
    Zp:     complex
            The calculated parallel impedance of the input tuple.
    &#34;&#34;&#34;
    # Gather length (number of elements in tuple)
    L = len(args)
    if L==1:
        Z = args[0] # Only One Tuple Provided
        try:
            L = len(Z)
            if(L==1):
                Zp = Z[0] # Only one impedance, burried in tuple
            else:
                # Inversely add the first two elements in tuple
                Zp = (1/Z[0]+1/Z[1])**(-1)
                # If there are more than two elements, add them all inversely
                if(L &gt; 2):
                    for i in range(2,L):
                        Zp = (1/Zp+1/Z[i])**(-1)
        except:
            Zp = Z # Only one impedance
    else:
        Z = args # Set of Args acts as Tuple
        # Inversely add the first two elements in tuple
        Zp = (1/Z[0]+1/Z[1])**(-1)
        # If there are more than two elements, add them all inversely
        if(L &gt; 2):
            for i in range(2,L):
                Zp = (1/Zp+1/Z[i])**(-1)
    return(Zp)</code></pre>
</details>
</dd>
<dt id="electricpy.peak"><code class="name flex">
<span>def <span class="ident">peak</span></span>(<span>val)</span>
</code></dt>
<dd>
<div class="desc"><p>Sinusoid RMS to Peak Converter</p>
<p>Provides a readable format to convert an
RMS (Root-Mean-Square) value to its peak
representation. Performs a simple multiplication
with the square-root of two.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak(val):
    &#34;&#34;&#34;
    Sinusoid RMS to Peak Converter
    
    Provides a readable format to convert an
    RMS (Root-Mean-Square) value to its peak
    representation. Performs a simple multiplication
    with the square-root of two.
    &#34;&#34;&#34;
    return(_np.sqrt(2) * val)</code></pre>
</details>
</dd>
<dt id="electricpy.pfcorrection"><code class="name flex">
<span>def <span class="ident">pfcorrection</span></span>(<span>S, PFold, PFnew, VLL=None, VLN=None, V=None, freq=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Power Factor Correction Function</p>
<p>Function to evaluate the additional reactive power and
capacitance required to achieve the desired power factor
given the old power factor and new power factor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>
float</code></dt>
<dd>Apparent power consumed by the load.</dd>
<dt><strong><code>PFold</code></strong> :&ensp;<code>
float</code></dt>
<dd>The current (old) power factor, should be a decimal
value.</dd>
<dt><strong><code>PFnew</code></strong> :&ensp;<code>
float</code></dt>
<dd>The desired (new) power factor, should be a decimal
value.</dd>
<dt><strong><code>VLL</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Line-to-Line Voltage; default=None</dd>
<dt><strong><code>VLN</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Line-to-Neutral Voltage; default=None</dd>
<dt><strong><code>V</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Voltage across the capacitor, ignores line-to-line
or line-to-neutral constraints. default=None</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System frequency, default=60</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>
float</code></dt>
<dd>Required capacitance in Farads.</dd>
<dt><strong><code>Qc</code></strong> :&ensp;<code>
float</code></dt>
<dd>Difference of reactive power, (Qc = Qnew - Qold)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pfcorrection(S,PFold,PFnew,VLL=None,VLN=None,V=None,freq=60):
    &#34;&#34;&#34;
    Power Factor Correction Function
    
    Function to evaluate the additional reactive power and
    capacitance required to achieve the desired power factor
    given the old power factor and new power factor.
    
    Parameters
    ----------
    S:          float
                Apparent power consumed by the load.
    PFold:      float
                The current (old) power factor, should be a decimal
                value.
    PFnew:      float
                The desired (new) power factor, should be a decimal
                value.
    VLL:        float, optional
                The Line-to-Line Voltage; default=None
    VLN:        float, optional
                The Line-to-Neutral Voltage; default=None
    V:          float, optional
                Voltage across the capacitor, ignores line-to-line
                or line-to-neutral constraints. default=None
    freq:       float, optional
                System frequency, default=60
    
    Returns
    -------
    C:          float
                Required capacitance in Farads.
    Qc:         float
                Difference of reactive power, (Qc = Qnew - Qold)
    &#34;&#34;&#34;
    # Condition Inputs
    S = abs(S)
    # Calculate Initial Terms
    Pold = S*PFold
    Qold = _np.sqrt(S**2 - Pold**2)
    # Evaluate Reactive Power Requirements
    Scorrected = Pold/PFnew
    Qcorrected = _np.sqrt(Scorrected**2 - Pold**2)
    Qc = Qold - Qcorrected
    # Evaluate Capacitance Based on Voltage Input
    if VLL == VLN == V == None:
        raise ValueError(&#34;One voltage must be specified.&#34;)
    elif VLN != None:
        C = Qc / (2*_np.pi*freq*3*VLN**2)
    else:
        if VLL != None:
            V = VLL
        C = Qc / (2*_np.pi*freq*V**2)
    # Return Value
    return(C,Qc)</code></pre>
</details>
</dd>
<dt id="electricpy.phase"><code class="name flex">
<span>def <span class="ident">phase</span></span>(<span>ang)</span>
</code></dt>
<dd>
<div class="desc"><p>Complex Phase Angle Generator</p>
<p>Generate a complex value given the phase angle
for the complex value.</p>
<p>Same as <code><a title="electricpy.phase" href="#electricpy.phase">phs()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ang</code></strong> :&ensp;<code>
float</code></dt>
<dd>The angle (in degrees) for which
the value should be calculated.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.phasorlist" href="#electricpy.phasorlist">phasorlist()</a></code></dt>
<dd>Phasor Generator for List or Array</dd>
<dt><code><a title="electricpy.cprint" href="#electricpy.cprint">cprint()</a></code></dt>
<dd>Complex Variable Printing Function</dd>
<dt><code><a title="electricpy.phasorz" href="#electricpy.phasorz">phasorz()</a></code></dt>
<dd>Impedance Phasor Generator</dd>
<dt><code><a title="electricpy.phasor" href="#electricpy.phasor">phasor()</a></code></dt>
<dd>Phasor Generating Function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phs( ang ):
    &#34;&#34;&#34;
    Complex Phase Angle Generator
    
    Generate a complex value given the phase angle
    for the complex value.
    
    Same as `phase`.
    
    Parameters
    ----------
    ang:        float
                The angle (in degrees) for which
                the value should be calculated.
    
    See Also
    --------
    phasorlist: Phasor Generator for List or Array
    cprint:     Complex Variable Printing Function
    phasorz:    Impedance Phasor Generator
    phasor:     Phasor Generating Function
    &#34;&#34;&#34;
    # Return the Complex Angle Modulator
    return(_np.exp(1j*_np.radians( ang )))</code></pre>
</details>
</dd>
<dt id="electricpy.phaseline"><code class="name flex">
<span>def <span class="ident">phaseline</span></span>(<span>VLL=None, VLN=None, Iline=None, Iphase=None, complex=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Line-Line to Line-Neutral Converter</p>
<p>This function is designed to return the phase- or line-equivalent
of the voltage/current provided. It is designed to be used when
converting delta- to wye-connections and vice-versa.
Given a voltage of one type, this function will return the
voltage of the opposite type. The same is true for current.</p>
<p>[ :label: voltages ]
Typical American (United States) standard is to note voltages in
Line-to-Line values (VLL), and often, the Line-to-Neutral voltage
is of value, this function uses the voltage :eq:<code>voltages</code> relation
to evaluate either voltage given the other.</p>
<p>[ :label: currents ]
Often, the phase current in a delta-connected device is of
particular interest, and the line-current is provided. This
function uses the current :eq:<code>currents</code> formula to evaluate
phase- and line-current given the opposing term.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>VLL</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Line-to-Line Voltage; default=None</dd>
<dt><strong><code>VLN</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Line-to-Neutral Voltage; default=None</dd>
<dt><strong><code>Iline</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Line-Current; default=None</dd>
<dt><strong><code>Iphase</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Phase-Current; default=None</dd>
<dt><strong><code>complex</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control to return value in complex form; default=False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phaseline(VLL=None,VLN=None,Iline=None,Iphase=None,complex=False):
    &#34;&#34;&#34;
    Line-Line to Line-Neutral Converter
    
    This function is designed to return the phase- or line-equivalent
    of the voltage/current provided. It is designed to be used when
    converting delta- to wye-connections and vice-versa.
    Given a voltage of one type, this function will return the
    voltage of the opposite type. The same is true for current.
    
    .. math:: V_{LL} = \\sqrt{3}∠30° * V_{LN}
       :label: voltages
    
    Typical American (United States) standard is to note voltages in
    Line-to-Line values (VLL), and often, the Line-to-Neutral voltage
    is of value, this function uses the voltage :eq:`voltages` relation
    to evaluate either voltage given the other.
    
    .. math:: I_{Φ} = \\frac{I_{line}}{\\sqrt{3}∠-30°}
       :label: currents
    
    Often, the phase current in a delta-connected device is of
    particular interest, and the line-current is provided. This
    function uses the current :eq:`currents` formula to evaluate
    phase- and line-current given the opposing term.
    
    Parameters
    ----------
    VLL:        float, optional
                The Line-to-Line Voltage; default=None
    VLN:        float, optional
                The Line-to-Neutral Voltage; default=None
    Iline:      float, optional
                The Line-Current; default=None
    Iphase:     float, optional
                The Phase-Current; default=None
    complex:    bool, optional
                Control to return value in complex form; default=False
    &#34;&#34;&#34;
    output = 0
    #Given VLL, convert to VLN
    if VLL is not None:
        VLN = VLL/(VLLcVLN)
        output = VLN
    #Given VLN, convert to VLL
    elif VLN is not None:
        VLL = VLN*VLLcVLN
        output = VLL
    #Given Iphase, convert to Iline
    elif Iphase is not None:
        Iline = Iphase*ILcIP
        output = Iline
    #Given Iline, convert to Iphase
    elif Iline is not None:
        Iphase = Iline/ILcIP
        output = Iphase
    #None given, error encountered
    else:
        print(&#34;ERROR: No value given&#34;+
                &#34;or innapropriate value&#34;+
                &#34;given.&#34;)
        return(0)
    #Return as complex only when requested
    if complex:
        return( output )
    return(abs( output ))</code></pre>
</details>
</dd>
<dt id="electricpy.phasor"><code class="name flex">
<span>def <span class="ident">phasor</span></span>(<span>mag, ang=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Complex Phasor Generator</p>
<p>Generates the standard Pythonic complex representation
of a phasor voltage or current when given the magnitude
and angle of the specific voltage or current.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mag</code></strong> :&ensp;<code>
float</code></dt>
<dd>The Magnitude of the Voltage/Current</dd>
<dt><strong><code>ang</code></strong> :&ensp;<code>
float</code></dt>
<dd>The Angle (in degrees) of the Voltage/Current</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>phasor</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Standard Pythonic Complex Representation of
the specified voltage or current.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; import electricpy as ep
&gt;&gt;&gt; ep.phasor(67, 120) # 67 volts at angle 120 degrees
(-33.499999999999986+58.02370205355739j)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.phasorlist" href="#electricpy.phasorlist">phasorlist()</a></code></dt>
<dd>Phasor Generator for List or Array</dd>
<dt><code><a title="electricpy.cprint" href="#electricpy.cprint">cprint()</a></code></dt>
<dd>Complex Variable Printing Function</dd>
<dt><code><a title="electricpy.phasorz" href="#electricpy.phasorz">phasorz()</a></code></dt>
<dd>Impedance Phasor Generator</dd>
<dt><code><a title="electricpy.phs" href="#electricpy.phs">phs()</a></code></dt>
<dd>Complex Phase Angle Generator</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phasor( mag, ang=0 ):
    &#34;&#34;&#34;
    Complex Phasor Generator
    
    Generates the standard Pythonic complex representation
    of a phasor voltage or current when given the magnitude
    and angle of the specific voltage or current.
    
    Parameters
    ----------
    mag:        float
                The Magnitude of the Voltage/Current
    ang:        float
                The Angle (in degrees) of the Voltage/Current
    
    Returns
    -------
    phasor:     complex
                Standard Pythonic Complex Representation of
                the specified voltage or current.
    
    Examples
    --------
    &gt;&gt;&gt; import electricpy as ep
    &gt;&gt;&gt; ep.phasor(67, 120) # 67 volts at angle 120 degrees
    (-33.499999999999986+58.02370205355739j)
    
    See Also
    --------
    phasorlist: Phasor Generator for List or Array
    cprint:     Complex Variable Printing Function
    phasorz:    Impedance Phasor Generator
    phs:        Complex Phase Angle Generator
    &#34;&#34;&#34;
    # Test for Tuple/List Arg
    if isinstance(mag, (tuple,list,_np.ndarray)):
        ang = mag[1]
        mag = mag[0]
    return( _c.rect( mag, _np.radians( ang ) ) )</code></pre>
</details>
</dd>
<dt id="electricpy.phasordata"><code class="name flex">
<span>def <span class="ident">phasordata</span></span>(<span>mn, mx=None, npts=1000, mag=1, ang=0, freq=60, retstep=False, rettime=False, sine=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Complex Phasor Data Generator</p>
<p>Generates a sinusoidal data set with minimum, maximum,
frequency, magnitude, and phase angle arguments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mn</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Minimum time (in seconds) to generate data for.
default=0</dd>
<dt><strong><code>mx</code></strong> :&ensp;<code>
float</code></dt>
<dd>Maximum time (in seconds) to generate data for.</dd>
<dt><strong><code>npts</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Number of data samples. default=1000</dd>
<dt><strong><code>mag</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Sinusoid magnitude, default=1</dd>
<dt><strong><code>ang</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Sinusoid angle in degrees, default=0</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Sinusoid frequency in Hz</dd>
<dt><strong><code>retstep</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to request return of time
step size (dt) in seconds.</dd>
<dt><strong><code>sine</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to require data be generated
with a sinusoidal function instead of cosine.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>The resultant data array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phasordata(mn,mx=None,npts=1000,mag=1,ang=0,freq=60,
               retstep=False,rettime=False,sine=False):
    &#34;&#34;&#34;
    Complex Phasor Data Generator
    
    Generates a sinusoidal data set with minimum, maximum,
    frequency, magnitude, and phase angle arguments.
    
    Parameters
    ----------
    mn:         float, optional
                Minimum time (in seconds) to generate data for.
                default=0
    mx:         float
                Maximum time (in seconds) to generate data for.
    npts:       float, optional
                Number of data samples. default=1000
    mag:        float, optional
                Sinusoid magnitude, default=1
    ang:        float, optional
                Sinusoid angle in degrees, default=0
    freq:       float, optional
                Sinusoid frequency in Hz
    retstep:    bool, optional
                Control argument to request return of time
                step size (dt) in seconds.
    sine:       bool, optional
                Control argument to require data be generated
                with a sinusoidal function instead of cosine.
                
    Returns
    -------
    data:       numpy.ndarray
                The resultant data array.
    &#34;&#34;&#34;
    # Test Inputs for Min/Max
    if mx == None:
        # No Minimum provided, use Value as Maximum
        mx = mn
        mn = 0
    # Generate Omega
    w = 2*_np.pi*freq
    # Generate Time Array
    t,dt = _np.linspace(mn,mx,npts,retstep=True)
    # Generate Data Array
    if not sine:
        data = mag * _np.cos(w*t + _np.radians(ang))
    else:
        data = mag * _np.sin(w*t + _np.radians(ang))
    # Generate Return Data Set
    dataset = [data]
    if retstep:
        dataset.append(dt)
    if rettime:
        dataset.append(t)
    # Return Dataset
    if len(dataset) == 1:
        return(dataset[0])
    return(dataset)</code></pre>
</details>
</dd>
<dt id="electricpy.phasorlist"><code class="name flex">
<span>def <span class="ident">phasorlist</span></span>(<span>arr)</span>
</code></dt>
<dd>
<div class="desc"><p>Complex Phasor Generator for 2-D Array or 2-D List</p>
<p>Generates the standard Pythonic complex representation
of a phasor voltage or current when given the magnitude
and angle of the specific voltage or current for a list
or array of values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>2-D array or list of magnitudes and angles.
Each item must be set of magnitude and angle
in form of: [mag, ang].</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>phasor</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Standard Pythonic Complex Representation of
the specified voltage or current.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import electricpy as ep
&gt;&gt;&gt; voltages = _np.array([[67,0],
                         [67,-120],
                         [67,120]])
&gt;&gt;&gt; Vset = ep.phasorlist( voltages )
&gt;&gt;&gt; print(Vset)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.phasor" href="#electricpy.phasor">phasor()</a></code></dt>
<dd>Phasor Generating Function</dd>
<dt><code><a title="electricpy.cprint" href="#electricpy.cprint">cprint()</a></code></dt>
<dd>Complex Variable Printing Function</dd>
<dt><code><a title="electricpy.phasorz" href="#electricpy.phasorz">phasorz()</a></code></dt>
<dd>Impedance Phasor Generator</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phasorlist( arr ):
    &#34;&#34;&#34;
    Complex Phasor Generator for 2-D Array or 2-D List
    
    Generates the standard Pythonic complex representation
    of a phasor voltage or current when given the magnitude
    and angle of the specific voltage or current for a list
    or array of values.
    
    Parameters
    ----------
    arr:        numpy.ndarray
                2-D array or list of magnitudes and angles.
                Each item must be set of magnitude and angle
                in form of: [mag, ang].
    
    Returns
    -------
    phasor:     complex
                Standard Pythonic Complex Representation of
                the specified voltage or current.
    
    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; import electricpy as ep
    &gt;&gt;&gt; voltages = _np.array([[67,0],
                             [67,-120],
                             [67,120]])
    &gt;&gt;&gt; Vset = ep.phasorlist( voltages )
    &gt;&gt;&gt; print(Vset)
    
    See Also
    --------
    phasor:     Phasor Generating Function
    cprint:     Complex Variable Printing Function
    phasorz:    Impedance Phasor Generator
    &#34;&#34;&#34;
    # Iteratively Process
    outarr = _np.array([])
    for i in arr:
        outarr = _np.append(outarr, phasor( i ))
    # Return Array
    return(outarr)</code></pre>
</details>
</dd>
<dt id="electricpy.phasorplot"><code class="name flex">
<span>def <span class="ident">phasorplot</span></span>(<span>phasor, title='Phasor Diagram', legend=False, bg=None, colors=None, radius=None, linewidth=None, size=None, filename=None, plot=True, label=False, labels=False, tolerance=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Phasor Plotting Function</p>
<p>This function is designed to plot a phasor-diagram with angles in degrees
for up to 12 phasor sets. Phasors must be passed as a complex number set,
(e.g. [ m+ja, m+ja, m+ja, &hellip; , m+ja ] ).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>phasor</code></strong> :&ensp;<code>
list</code> of <code>complex</code></dt>
<dd>The set of phasors to be plotted.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>
string</code>, optional</dt>
<dd>The Plot Title, default="Phasor Diagram"</dd>
<dt><strong><code>legend</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to enable displaying the legend, must be passed
as an array or list of strings. <code>label</code> and <code>labels</code> are mimic-
arguments and will perform similar operation, default=False</dd>
<dt><strong><code>bg</code></strong> :&ensp;<code>
string</code>, optional</dt>
<dd>Background-Color control, default="#d5de9c"</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The diagram radius, unless specified, automatically scales</dd>
<dt><strong><code>colors</code></strong> :&ensp;<code>
list</code> of <code>str</code>, optional</dt>
<dd>List of hexidecimal color strings denoting the line colors to use.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>
string</code>, optional</dt>
<dd>String of filename, if set, will force function to save image.</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to disable plotting. default=True</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Control argument for figure size. default=None</dd>
<dt><strong><code>linewidth</code></strong> :&ensp;<code> float</code>, optional</dt>
<dd>Control argument to declare the line thickness. default=None</dd>
<dt><strong><code>tolerance</code></strong> :&ensp;<code> float</code>, optional</dt>
<dd>Minimum magnitude to plot, anything less than tolerance will be
plotted as a single point at the origin, by default, the tolerance
is scaled to be 1/25-th the maximum radius. To disable the tolerance,
simply provide either False or -1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phasorplot(phasor,title=&#34;Phasor Diagram&#34;,legend=False,bg=None,
               colors=None,radius=None,linewidth=None,size=None,
               filename=None,plot=True,label=False,labels=False,
               tolerance=None):
    &#34;&#34;&#34;
    Phasor Plotting Function
    
    This function is designed to plot a phasor-diagram with angles in degrees
    for up to 12 phasor sets. Phasors must be passed as a complex number set,
    (e.g. [ m+ja, m+ja, m+ja, ... , m+ja ] ).
    
    Parameters
    ----------
    phasor:     list of complex
                The set of phasors to be plotted.
    title:      string, optional
                The Plot Title, default=&#34;Phasor Diagram&#34;
    legend:     bool, optional
                Control argument to enable displaying the legend, must be passed
                as an array or list of strings. `label` and `labels` are mimic-
                arguments and will perform similar operation, default=False
    bg:         string, optional
                Background-Color control, default=&#34;#d5de9c&#34;
    radius:     float, optional
                The diagram radius, unless specified, automatically scales
    colors:     list of str, optional
                List of hexidecimal color strings denoting the line colors to use.
    filename:   string, optional
                String of filename, if set, will force function to save image.
    plot:       bool, optional
                Control argument to disable plotting. default=True
    size:       float, optional
                Control argument for figure size. default=None
    linewidth:  float, optional
                Control argument to declare the line thickness. default=None
    tolerance:  float, optional
                Minimum magnitude to plot, anything less than tolerance will be
                plotted as a single point at the origin, by default, the tolerance
                is scaled to be 1/25-th the maximum radius. To disable the tolerance,
                simply provide either False or -1.
    &#34;&#34;&#34;
    # Load Complex Values if Necessary
    try:
        len(phasor)
    except TypeError:
        phasor = [phasor]
    # Manage Colors
    if colors==None:
        colors = [&#34;#FF0000&#34;,&#34;#800000&#34;,&#34;#FFFF00&#34;,&#34;#808000&#34;,&#34;#00ff00&#34;,&#34;#008000&#34;,
                  &#34;#00ffff&#34;,&#34;#008080&#34;,&#34;#0000ff&#34;,&#34;#000080&#34;,&#34;#ff00ff&#34;,&#34;#800080&#34;]
    # Scale Radius
    if radius==None:
        radius = _np.abs(phasor).max()
    # Set Tolerance
    if tolerance==None:
        tolerance = radius/25
    elif tolerance==False:
        tolerance = -1
    # Set Background Color
    if bg==None:
        bg = &#34;#FFFFFF&#34;
    # Load labels if handled in other argument
    if label!=False:
        legend = label
    if labels!=False:
        legend = labels
    # Check for more phasors than colors
    numphs = len(phasor)
    numclr = len(colors)
    if numphs &gt; numclr:
        raise ValueError(&#34;ERROR: Too many phasors provided. Specify more line colors.&#34;)
    
    if size==None:
        # Force square figure and square axes
        width, height = _matplotlib.rcParams[&#39;figure.figsize&#39;]
        size = min(width, height)
    # Make a square figure
    fig = _plt.figure(figsize=(size, size))
    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True, facecolor=bg)
    _plt.grid(True)
    
    # Plot the diagram
    _plt.title(title+&#34;\n&#34;)
    handles=_np.array([]) # Empty array for plot handles
    for i in range(numphs):
        mag, ang_r = _c.polar(phasor[i])
        # Plot with labels
        if legend!=False:
            if mag &gt; tolerance:
                hand = _plt.arrow(0,0,ang_r,mag,color=colors[i],
                                  label=legend[i],linewidth=linewidth)
            else:
                hand = _plt.plot(0,0,&#39;o&#39;,markersize=linewidth*3,
                                 label=legend[i],color=colors[i])
            handles = _np.append(handles,[hand])
        # Plot without labels
        else: _plt.arrow(0,0,ang_r,mag,color=colors[i],linewidth=linewidth)
    if legend!=False: _plt.legend((handles),legend)
    # Set Minimum and Maximum Radius Terms
    ax.set_rmax(radius)
    ax.set_rmin(0)
    if filename!=None:
        if not any(sub in filename for sub in [&#39;.png&#39;,&#39;.jpg&#39;]):
            filename += &#39;.png&#39; # Add File Extension
        _plt.savefig( filename )
    if plot:
        _plt.show()
    else:
        _plt.close()</code></pre>
</details>
</dd>
<dt id="electricpy.phasorz"><code class="name flex">
<span>def <span class="ident">phasorz</span></span>(<span>C=None, L=None, freq=60, complex=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Phasor Impedance Generator</p>
<p>This function's purpose is to generate the phasor-based
impedance of the specified input given as either the
capacitance (in Farads) or the inductance (in Henreys).
The function will return the phasor value (in Ohms).</p>
<p>[
]
[
]
where:</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The capacitance value (specified in Farads),
default=None</dd>
<dt><strong><code>L</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The inductance value (specified in Henreys),
default=None</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The system frequency to be calculated upon, default=60</dd>
<dt><strong><code>complex</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to specify whether the returned
value should be returned as a complex value.
default=True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The ohmic impedance of either C or L (respectively).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phasorz(C=None,L=None,freq=60,complex=True):
    &#34;&#34;&#34;
    Phasor Impedance Generator
    
    This function&#39;s purpose is to generate the phasor-based
    impedance of the specified input given as either the
    capacitance (in Farads) or the inductance (in Henreys).
    The function will return the phasor value (in Ohms).
    
    .. math:: Z = \\frac{-j}{\\omega*C}
    
    .. math:: Z = j*\\omega*L
    
    where:
    
    .. math:: \\omega = 2*\\pi*freq
    
    Parameters
    ----------
    C:          float, optional
                The capacitance value (specified in Farads),
                default=None
    L:          float, optional
                The inductance value (specified in Henreys),
                default=None
    freq:       float, optional
                The system frequency to be calculated upon, default=60
    complex:    bool, optional
                Control argument to specify whether the returned
                value should be returned as a complex value.
                default=True
    
    Returns
    -------
    Z:      complex
            The ohmic impedance of either C or L (respectively).
    &#34;&#34;&#34;
    w = 2*_np.pi*freq
    #C Given in ohms, return as Z
    if (C!=None):
        Z = -1/(w*C)
    #L Given in ohms, return as Z
    if (L!=None):
        Z = w*L
    #If asked for imaginary number
    if (complex):
        Z *= 1j
    return(Z)</code></pre>
</details>
</dd>
<dt id="electricpy.phs"><code class="name flex">
<span>def <span class="ident">phs</span></span>(<span>ang)</span>
</code></dt>
<dd>
<div class="desc"><p>Complex Phase Angle Generator</p>
<p>Generate a complex value given the phase angle
for the complex value.</p>
<p>Same as <code><a title="electricpy.phase" href="#electricpy.phase">phs()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ang</code></strong> :&ensp;<code>
float</code></dt>
<dd>The angle (in degrees) for which
the value should be calculated.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.phasorlist" href="#electricpy.phasorlist">phasorlist()</a></code></dt>
<dd>Phasor Generator for List or Array</dd>
<dt><code><a title="electricpy.cprint" href="#electricpy.cprint">cprint()</a></code></dt>
<dd>Complex Variable Printing Function</dd>
<dt><code><a title="electricpy.phasorz" href="#electricpy.phasorz">phasorz()</a></code></dt>
<dd>Impedance Phasor Generator</dd>
<dt><code><a title="electricpy.phasor" href="#electricpy.phasor">phasor()</a></code></dt>
<dd>Phasor Generating Function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phs( ang ):
    &#34;&#34;&#34;
    Complex Phase Angle Generator
    
    Generate a complex value given the phase angle
    for the complex value.
    
    Same as `phase`.
    
    Parameters
    ----------
    ang:        float
                The angle (in degrees) for which
                the value should be calculated.
    
    See Also
    --------
    phasorlist: Phasor Generator for List or Array
    cprint:     Complex Variable Printing Function
    phasorz:    Impedance Phasor Generator
    phasor:     Phasor Generating Function
    &#34;&#34;&#34;
    # Return the Complex Angle Modulator
    return(_np.exp(1j*_np.radians( ang )))</code></pre>
</details>
</dd>
<dt id="electricpy.phs3valpha"><code class="name flex">
<span>def <span class="ident">phs3valpha</span></span>(<span>VA, VB=0, VC=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Three-Phase V-Alpha Calculator</p>
<p>Accepts the three-phase voltages for which the
accumulated Alpha voltage should be calculated.</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>VA</code></strong> :&ensp;<code>
[float, complex]</code></dt>
<dd>A-phase voltage, (or tuple/list of
voltages), unitless.</dd>
<dt><strong><code>VB</code></strong> :&ensp;<code>
[float, complex]</code>, optional</dt>
<dd>B-phase voltage, unitless.</dd>
<dt><strong><code>VC</code></strong> :&ensp;<code>
[float, complex]</code>, optional</dt>
<dd>C-phase voltage, unitless.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Valpha</code></strong> :&ensp;<code>
[float, complex]</code></dt>
<dd>Alpha-voltage as calculated from
input three-phase voltages. Matches
type of inputs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phs3valpha( VA, VB=0, VC=0 ):
    &#34;&#34;&#34;
    Three-Phase V-Alpha Calculator
    
    Accepts the three-phase voltages for which the
    accumulated Alpha voltage should be calculated.
    
    .. math:: V_{\\alpha}=V_A-\\frac{V_B}{2}-\\frac{V_C}{2}
    
    Parameters
    ----------
    VA:         [float, complex]
                A-phase voltage, (or tuple/list of
                voltages), unitless.
    VB:         [float, complex], optional
                B-phase voltage, unitless.
    VC:         [float, complex], optional
                C-phase voltage, unitless.
    
    Returns
    -------
    Valpha:     [float, complex]
                Alpha-voltage as calculated from
                input three-phase voltages. Matches
                type of inputs.
    &#34;&#34;&#34;
    # Handle Combined (list/tuple) Input
    if (isinstance(VA, (tuple,list)) and
        VB==0 and VC==C):
        if len(VA) != 3:
            raise ValueError(&#34;Invalid input set, must &#34;
                +&#34;be list of three elements, three inputs,&#34;
                +&#34; or three array-like objects of equal &#34;
                +&#34;length.&#34;)
        Valpha = VA[0] - VA[1]/2 - VA[2]/2
    # Handle Separated Inputs
    else:
        Valpha = VA - VB/2 - VC/2
    # Return the Alpha-Voltage
    return( Valpha )</code></pre>
</details>
</dd>
<dt id="electricpy.phs_to_seq"><code class="name flex">
<span>def <span class="ident">phs_to_seq</span></span>(<span>Mabc, reference='A')</span>
</code></dt>
<dd>
<div class="desc"><p>Phase-System to Sequence-System Conversion</p>
<p>Converts phase-based values to sequence
components.</p>
<p>[
]
Same as phs_to_seq.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Mabc</code></strong> :&ensp;<code>
list</code> of <code>complex</code></dt>
<dd>Phase-based values to be converted.</dd>
<dt><strong><code>reference</code></strong> :&ensp;<code>{'A', 'B', 'C'}</code></dt>
<dd>Single character denoting the reference,
default='A'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>M012</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>Sequence-based values in order of 0-1-2</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.seq_to_abc" href="#electricpy.seq_to_abc">seq_to_abc()</a></code></dt>
<dd>Sequence to Phase Conversion</dd>
<dt><code><a title="electricpy.sequencez" href="#electricpy.sequencez">sequencez()</a></code></dt>
<dd>Phase Impedance to Sequence Converter</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abc_to_seq(Mabc,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Phase-System to Sequence-System Conversion
    
    Converts phase-based values to sequence
    components.
    
    .. math:: M_{\\text{012}}=A_{\\text{012}}\\cdot M_{\\text{ABC}}
    
    Same as phs_to_seq.
    
    Parameters
    ----------
    Mabc:       list of complex
                Phase-based values to be converted.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    
    Returns
    -------
    M012:       numpy.ndarray
                Sequence-based values in order of 0-1-2
    
    See Also
    --------
    seq_to_abc: Sequence to Phase Conversion
    sequencez:  Phase Impedance to Sequence Converter
    &#34;&#34;&#34;
    # Condition Reference:
    reference = reference.upper()
    if reference == &#39;A&#39;:
        M = Aabc
    elif reference == &#39;B&#39;:
        M = _np.roll(Aabc, 1, 0)
    elif reference == &#39;C&#39;:
        M = _np.roll(Aabc, 2, 0)
    else:
        raise ValueError(&#34;Invalid Phase Reference.&#34;)
    return(M.dot(Mabc))</code></pre>
</details>
</dd>
<dt id="electricpy.powerflow"><code class="name flex">
<span>def <span class="ident">powerflow</span></span>(<span>Vsend, Vrec, Zline)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple Power-Flow Calculator</p>
<p>This function is designed to calculate the ammount of real
power transferred from the sending end to the recieving end
of an electrical line given the sending voltage (complex),
the receiving voltage (complex) and the line impedance.</p>
<p>[ P_{flow}=\frac{|V_{send}|<em>|V_{rec}|}{Z_{line}}</em>sin(\theta_{send}
-\theta_{rec}) ]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Vsend</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The sending-end voltage, should be complex</dd>
<dt><strong><code>Vrec</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The receiving-end voltage, should be complex</dd>
<dt><strong><code>Zline</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The line impedance, should be complex</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pflow</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The power transferred from sending-end to
receiving-end, positive values denote power
flow from send to receive, negative values
denote vice-versa.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def powerflow( Vsend, Vrec, Zline ):
    &#34;&#34;&#34;
    Simple Power-Flow Calculator
    
    This function is designed to calculate the ammount of real
    power transferred from the sending end to the recieving end
    of an electrical line given the sending voltage (complex),
    the receiving voltage (complex) and the line impedance.
    
    .. math::
       P_{flow}=\\frac{|V_{send}|*|V_{rec}|}{Z_{line}}*sin(\\theta_{send}
       -\\theta_{rec})
    
    Parameters
    ----------
    Vsend:      complex
                The sending-end voltage, should be complex
    Vrec:       complex
                The receiving-end voltage, should be complex
    Zline:      complex
                The line impedance, should be complex
    
    Returns
    -------
    pflow:      complex
                The power transferred from sending-end to
                receiving-end, positive values denote power
                flow from send to receive, negative values
                denote vice-versa.
    &#34;&#34;&#34;
    # Evaluate the Input Terms
    Vs = abs( Vsend )
    ds = _c.phase( Vsend )
    Vr = abs( Vrec )
    dr = _c.phase( Vrec )
    # Calculate Power Flow
    pflow = (Vs * Vr)/(Zline) * _np.sin( ds-dr )
    return( pflow )</code></pre>
</details>
</dd>
<dt id="electricpy.powerimpedance"><code class="name flex">
<span>def <span class="ident">powerimpedance</span></span>(<span>S, V, PF=None, parallel=False, terms=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Impedance from Apparent Power Formula</p>
<p>Function to determine the ohmic resistance/reactance
(impedance) represented by the apparent power (S).</p>
<p>[ :label: series ]
[ :label: parallel ]
This function can evaluate the component values for
both series :eq:<code>series</code> and parallel :eq:<code>parallel</code>
connected circuits.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>
complex, float</code></dt>
<dd>The apparent power of the passive element,
may be purely resistive or purely reactive.</dd>
<dt><strong><code>V</code></strong> :&ensp;<code>
float</code></dt>
<dd>The operating voltage of the passive element.
Note that this is specifically not Line-Line or
Line-Neutral voltage, rather the voltage of the
element.</dd>
<dt><strong><code>PF</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The operating Power-Factor, should be specified
if S is given as a float (not complex). Positive
PF correlates to lagging, negative to leading.
default=None</dd>
<dt><strong><code>parallel</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control point to specify whether the ohmic
impedance should be returned as series components
(False opt.) or parallel components (True opt.).</dd>
<dt><strong><code>terms</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control point to specify whether return should
be made as resistance and reactance, or simply
the complex impedance. Setting of False will
return complex impedance, setting of True will
return individual components (R, X).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>
float</code></dt>
<dd>The ohmic resistance required to consume the
specified apparent power (S) at the rated
voltage (V).</dd>
<dt><strong><code>X</code></strong> :&ensp;<code>
float</code></dt>
<dd>The ohmic reactance required to consume the
specified apparent power (S) at the rated
voltage (V).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def powerimpedance(S,V,PF=None,parallel=False,terms=False):
    &#34;&#34;&#34;
    Impedance from Apparent Power Formula
    
    Function to determine the ohmic resistance/reactance
    (impedance) represented by the apparent power (S).
    
    .. math:: Z = \\frac{V^2}{S}
       :label: series
    
    .. math:: Z = \\frac{V^2}{(3*S)}
       :label: parallel
    
    This function can evaluate the component values for
    both series :eq:`series` and parallel :eq:`parallel`
    connected circuits.
    
    Parameters
    ----------
    S:          complex, float
                The apparent power of the passive element,
                may be purely resistive or purely reactive.
    V:          float
                The operating voltage of the passive element.
                Note that this is specifically not Line-Line or
                Line-Neutral voltage, rather the voltage of the
                element.
    PF:         float, optional
                The operating Power-Factor, should be specified
                if S is given as a float (not complex). Positive
                PF correlates to lagging, negative to leading.
                default=None
    parallel:   bool, optional
                Control point to specify whether the ohmic
                impedance should be returned as series components
                (False opt.) or parallel components (True opt.).
    terms:      bool, optional
                Control point to specify whether return should
                be made as resistance and reactance, or simply
                the complex impedance. Setting of False will
                return complex impedance, setting of True will
                return individual components (R, X).
    
    Returns
    -------
    R:          float
                The ohmic resistance required to consume the
                specified apparent power (S) at the rated
                voltage (V).
    X:          float
                The ohmic reactance required to consume the
                specified apparent power (S) at the rated
                voltage (V).
    &#34;&#34;&#34;
    # Condition Inputs
    V = abs(V)
    # Test for Parallel Component Option and Evaluate
    if isinstance(S,complex) or PF != None:
        if PF != None:
            # Evaluate Elements
            P,Q,S,PF = powerset(S=S,PF=PF)
        else:
            P = S.real
            Q = S.imag
        # Compute Elements
        if parallel:
            R = V**2 / (3*P)
            X = V**2 / (3*Q)
        else:
            R = V**2 / (P)
            X = V**2 / (Q)
        # Conditionally Return as Impedance
        if terms:
            return( R, X )
        return( R + 1j*X )
    # Not Complex (just R)
    R = V**2 / S
    return( R )</code></pre>
</details>
</dd>
<dt id="electricpy.powerset"><code class="name flex">
<span>def <span class="ident">powerset</span></span>(<span>P=None, Q=None, S=None, PF=None, find='')</span>
</code></dt>
<dd>
<div class="desc"><p>Power Triangle Conversion Function</p>
<p>This function is designed to calculate all values
in the set { P, Q, S, PF } when two (2) of the
values are provided. The equations in this
function are prepared for AC values, that is:
real and reactive power, apparent power, and power
factor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Real Power, unitless; default=None</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Reactive Power, unitless; default=None</dd>
<dt><strong><code>S</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Apparent Power, unitless; default=None</dd>
<dt><strong><code>PF</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Power Factor, unitless, provided as a
decimal value, lagging is positive,
leading is negative; default=None</dd>
<dt><strong><code>find</code></strong> :&ensp;<code>
str</code>, optional</dt>
<dd>Control argument to specify which value
should be returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>
float</code></dt>
<dd>Calculated Real Power Magnitude</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>
float</code></dt>
<dd>Calculated Reactive Power Magnitude</dd>
<dt><strong><code>S</code></strong> :&ensp;<code>
float</code></dt>
<dd>Calculated Apparent Power Magnitude</dd>
<dt><strong><code>PF</code></strong> :&ensp;<code>
float</code></dt>
<dd>Calculated Power Factor</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def powerset(P=None,Q=None,S=None,PF=None,find=&#39;&#39;):
    &#34;&#34;&#34;
    Power Triangle Conversion Function
    
    This function is designed to calculate all values
    in the set { P, Q, S, PF } when two (2) of the
    values are provided. The equations in this
    function are prepared for AC values, that is:
    real and reactive power, apparent power, and power
    factor.
    
    Parameters
    ----------
    P:      float, optional
            Real Power, unitless; default=None
    Q:      float, optional
            Reactive Power, unitless; default=None
    S:      float, optional
            Apparent Power, unitless; default=None
    PF:     float, optional
            Power Factor, unitless, provided as a
            decimal value, lagging is positive,
            leading is negative; default=None
    find:   str, optional
            Control argument to specify which value
            should be returned.
    
    Returns
    -------
    P:      float
            Calculated Real Power Magnitude
    Q:      float
            Calculated Reactive Power Magnitude
    S:      float
            Calculated Apparent Power Magnitude
    PF:     float
            Calculated Power Factor
    &#34;&#34;&#34;
    #Given P and Q
    if (P!=None) and (Q!=None):
        S = _np.sqrt(P**2+Q**2)
        PF = P/S
        if Q&lt;0:
            PF=-PF
    #Given S and PF
    elif (S!=None) and (PF!=None):
        P = abs(S*PF)
        Q = _np.sqrt(S**2-P**2)
        if PF&lt;0:
            Q=-Q
    #Given P and PF
    elif (P!=None) and (PF!=None):
        S = P/PF
        Q = _np.sqrt(S**2-P**2)
        if PF&lt;0:
            Q=-Q
    # Given P and S
    elif (P!=None) and (S!=None):
        Q = _np.sqrt(S**2 - P**2)
        PF = P/S
    # Given Q and S
    elif (Q!=None) and (S!=None):
        P = _np.sqrt(S**2 - Q**2)
        PF = P/S
    else:
        raise ValueError(&#34;ERROR: Invalid Parameters or too few&#34;+
                        &#34; parameters given to calculate.&#34;)
    # Return
    find = find.upper()
    if find == &#39;P&#39;:
        return(P)
    elif find == &#39;Q&#39;:
        return(Q)
    elif find == &#39;S&#39;:
        return(S)
    elif find == &#39;PF&#39;:
        return(PF)
    else:
        return(P,Q,S,PF)</code></pre>
</details>
</dd>
<dt id="electricpy.powertriangle"><code class="name flex">
<span>def <span class="ident">powertriangle</span></span>(<span>P=None, Q=None, S=None, PF=None, color='red', text='Power Triangle', printval=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Power Triangle Plotting Function</p>
<p>This function is designed to draw a power triangle given
values for the complex power system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>P</code></strong> :&ensp;<code>
float</code></dt>
<dd>Real Power, unitless; default=None</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>
float</code></dt>
<dd>Reactive Power, unitless; default=None</dd>
<dt><strong><code>S</code></strong> :&ensp;<code>
float</code></dt>
<dd>Apparent Power, unitless; default=None</dd>
<dt><strong><code>PF</code></strong> :&ensp;<code>
float</code></dt>
<dd>Power Factor, unitless, provided as a
decimal value, lagging is positive,
leading is negative; default=None</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>
string</code>, optional</dt>
<dd>The color of the power triangle lines;
default="red"</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>
string</code>, optional</dt>
<dd>The title of the power triangle plot,
default="Power Triangle"</dd>
<dt><strong><code>printval</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to allow the numeric
values to be printed on the plot,
default="False"</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def powertriangle(P=None,Q=None,S=None,PF=None,color=&#34;red&#34;,
                  text=&#34;Power Triangle&#34;,printval=False):
    &#34;&#34;&#34;
    Power Triangle Plotting Function
    
    This function is designed to draw a power triangle given
    values for the complex power system.
    
    Parameters
    ----------
    P:          float
                Real Power, unitless; default=None
    Q:          float
                Reactive Power, unitless; default=None
    S:          float
                Apparent Power, unitless; default=None
    PF:         float
                Power Factor, unitless, provided as a
                decimal value, lagging is positive,
                leading is negative; default=None
    color:      string, optional
                The color of the power triangle lines;
                default=&#34;red&#34;
    text:       string, optional
                The title of the power triangle plot,
                default=&#34;Power Triangle&#34;
    printval:   bool, optional
                Control argument to allow the numeric
                values to be printed on the plot,
                default=&#34;False&#34;
    &#34;&#34;&#34;
    # Calculate all values if not all are provided
    if( P==None or Q==None or S==None or PF==None):
        P,Q,S,PF = powerset(P,Q,S,PF)

    #Generate Lines
    Plnx = [0,P]
    Plny = [0,0]
    Qlnx = [P,P]
    Qlny = [0,Q]
    Slnx = [0,P]
    Slny = [0,Q]

    # Plot Power Triangle
    _plt.figure(1)
    _plt.title(text)
    _plt.plot(Plnx,Plny,color=color)
    _plt.plot(Qlnx,Qlny,color=color)
    _plt.plot(Slnx,Slny,color=color)
    _plt.xlabel(&#34;Real Power (W)&#34;)
    _plt.ylabel(&#34;Reactive Power (VAR)&#34;)
    mx = max(abs(P),abs(Q))

    if P&gt;0:
        _plt.xlim(0,mx*1.1)
        x=mx
    else:
        _plt.xlim(-mx*1.1,0)
        x=-mx
    if Q&gt;0:
        _plt.ylim(0,mx*1.1)
        y=mx
    else:
        _plt.ylim(-mx*1.1,0)
        y=-mx
    if PF &gt; 0:
        PFtext = &#34; Lagging&#34;
    else:
        PFtext = &#34; Leading&#34;
    text = &#34;P:   &#34;+str(P)+&#34; W\n&#34;
    text = text+&#34;Q:   &#34;+str(Q)+&#34; VAR\n&#34;
    text = text+&#34;S:   &#34;+str(S)+&#34; VA\n&#34;
    text = text+&#34;PF:  &#34;+str(abs(PF))+PFtext+&#34;\n&#34;
    text = text+&#34;ΘPF: &#34;+str(_np.degrees(_np.arccos(PF)))+&#34;°&#34;+PFtext
    # Print all values if asked to
    if printval:
         _plt.text(x/20,y*4/5,text,color=color)
    _plt.show()</code></pre>
</details>
</dd>
<dt id="electricpy.primary"><code class="name flex">
<span>def <span class="ident">primary</span></span>(<span>val, Np, Ns=1, invert=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Transformer Primary Evaluator</p>
<p>Returns a current or voltage value reflected across
a transformer with a specified turns ratio Np/Ns.
Converts to the primary side.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>val</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Value to be reflected across transformer.</dd>
<dt><strong><code>Np</code></strong> :&ensp;<code>
float</code></dt>
<dd>Number of turns on primary side.</dd>
<dt><strong><code>Ns</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Number of turns on secondary side.</dd>
<dt><strong><code>invert</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to invert the turns ratio,
used when reflecting current across a
voltage transformer, or voltage across a
current transformer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>reflection</code></strong> :&ensp;<code>complex</code></dt>
<dd>The reflected value referred to the primary
side according to Np and Ns.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def primary(val, Np, Ns=1, invert=False):
    &#34;&#34;&#34;
    Transformer Primary Evaluator
    
    Returns a current or voltage value reflected across
    a transformer with a specified turns ratio Np/Ns.
    Converts to the primary side.
    
    Parameters
    ----------
    val:        complex
                Value to be reflected across transformer.
    Np:         float
                Number of turns on primary side.
    Ns:         float, optional
                Number of turns on secondary side.
    invert:     bool, optional
                Control argument to invert the turns ratio,
                used when reflecting current across a
                voltage transformer, or voltage across a
                current transformer.
    
    Returns
    -------
    reflection: complex
                The reflected value referred to the primary
                side according to Np and Ns.
    &#34;&#34;&#34;
    if invert:
        return( val * Ns/Np )
    return( val * Np/Ns )</code></pre>
</details>
</dd>
<dt id="electricpy.probdensity"><code class="name flex">
<span>def <span class="ident">probdensity</span></span>(<span>func, x, x0=0, scale=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Probability Density Function:</p>
<p>This function uses an integral to compute the probability
density of a given function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>
function</code></dt>
<dd>The function for which to calculate the PDF</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>The (array of) value(s) at which to calculate
the PDF</dd>
<dt><strong><code>x0</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The lower-bound of the integral, starting point
for the PDF to be calculated over, default=0</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code> bool</code>, optional</dt>
<dd>The scaling to be applied to the output,
default=True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>sumx</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>The (array of) value(s) computed as the PDF at
point(s) x</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def probdensity(func,x,x0=0,scale=True):
    &#34;&#34;&#34;
    Probability Density Function:
    
    This function uses an integral to compute the probability
    density of a given function.
    
    Parameters
    ----------
    func:   function
            The function for which to calculate the PDF
    x:      numpy.ndarray
            The (array of) value(s) at which to calculate
            the PDF
    x0:     float, optional
            The lower-bound of the integral, starting point
            for the PDF to be calculated over, default=0
    scale:  bool, optional
            The scaling to be applied to the output,
            default=True
    
    Returns
    -------
    sumx:   numpy.ndarray
            The (array of) value(s) computed as the PDF at
            point(s) x
    &#34;&#34;&#34;
    sumx = _np.array([])
    try:
        lx = len(x) # Find length of Input
    except:
        lx = 1 # Length 1
        x = [x] # Pack into list
    # Recursively Find Probability Density
    for i in range(lx):
        sumx = _np.append(sumx,integrate(func,x0,x[i])[0])
    # Return only the 0-th value if there&#39;s only 1 value available
    if(len(sumx)==1):
        sumx = sumx[0]
    else:
        if(scale==True):
            mx = sumx.max()
            sumx /= mx
        elif(scale!=False):
            sumx /= scale
    return(sumx)</code></pre>
</details>
</dd>
<dt id="electricpy.protor"><code class="name flex">
<span>def <span class="ident">protor</span></span>(<span>Pem, slip)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotor Power Calculator for Induction Machine</p>
<p>Given the electromechanical power and the slip,
this function will calculate the power related to the
rotor (provided or consumed).</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Pem</code></strong> :&ensp;<code>
float</code></dt>
<dd>Electromechanical power in watts.</dd>
<dt><strong><code>slip</code></strong> :&ensp;<code>
float</code></dt>
<dd>Slip factor in rad/sec.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Pr</code></strong> :&ensp;<code>
float</code></dt>
<dd>Power related to the rotor in watts.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.pstator" href="#electricpy.pstator">pstator()</a></code></dt>
<dd>Stator Power Calculator for Induction Machines</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def protor(Pem, slip):
    &#34;&#34;&#34;
    Rotor Power Calculator for Induction Machine
    
    Given the electromechanical power and the slip,
    this function will calculate the power related to the
    rotor (provided or consumed).
    
    .. math:: P_r=-\\text{slip}\\cdot\\frac{P_{em}}{1-\\text{slip}}
    
    Parameters
    ----------
    Pem:        float
                Electromechanical power in watts.
    slip:       float
                Slip factor in rad/sec.
    
    Returns
    -------
    Pr:         float
                Power related to the rotor in watts.
    
    See Also
    --------
    pstator:         Stator Power Calculator for Induction Machines
    &#34;&#34;&#34;
    # Calculate and Return
    Pr = -slip * (Pem / (1-slip))
    return(Pr)</code></pre>
</details>
</dd>
<dt id="electricpy.pstator"><code class="name flex">
<span>def <span class="ident">pstator</span></span>(<span>Pem, slip)</span>
</code></dt>
<dd>
<div class="desc"><p>Stator Power Calculator for Induction Machine</p>
<p>Given the electromechanical power and the slip,
this function will calculate the power related to the
stator (provided or consumed).</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Pem</code></strong> :&ensp;<code>
float</code></dt>
<dd>Electromechanical power in watts.</dd>
<dt><strong><code>slip</code></strong> :&ensp;<code>
float</code></dt>
<dd>Slip factor in rad/sec.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Ps</code></strong> :&ensp;<code>
float</code></dt>
<dd>Power related to the stator in watts.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.protor" href="#electricpy.protor">protor()</a></code></dt>
<dd>Rotor Power Calculator for Induction Machines</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pstator(Pem, slip):
    &#34;&#34;&#34;
    Stator Power Calculator for Induction Machine
    
    Given the electromechanical power and the slip,
    this function will calculate the power related to the
    stator (provided or consumed).
    
    .. math:: P_s=\\frac{P_{em}}{1-\\text{slip}}
    
    Parameters
    ----------
    Pem:        float
                Electromechanical power in watts.
    slip:       float
                Slip factor in rad/sec.
    
    Returns
    -------
    Ps:         float
                Power related to the stator in watts.
    
    See Also
    --------
    protor:         Rotor Power Calculator for Induction Machines
    &#34;&#34;&#34;
    # Calculate and Return
    Ps = Pem / (1-slip)
    return(Ps)</code></pre>
</details>
</dd>
<dt id="electricpy.puchgbase"><code class="name flex">
<span>def <span class="ident">puchgbase</span></span>(<span>quantity, puB_old, puB_new)</span>
</code></dt>
<dd>
<div class="desc"><p>Per-Unit Change of Base Function</p>
<p>Performs a per-unit change of base operation for the given
value constrained by the old base and new base.</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>quantity</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Current per-unit value in old base.</dd>
<dt><strong><code>puB_old</code></strong> :&ensp;<code>
float</code></dt>
<dd>Old per-unit base.</dd>
<dt><strong><code>puB_new</code></strong> :&ensp;<code>
float</code></dt>
<dd>New per-unit base.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pu_new</code></strong> :&ensp;<code>
complex</code></dt>
<dd>New per-unit value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def puchgbase(quantity, puB_old, puB_new):
    &#34;&#34;&#34;
    Per-Unit Change of Base Function
    
    Performs a per-unit change of base operation for the given
    value constrained by the old base and new base.
    
    .. math:: Z_{pu-new}=Z_{pu-old}*\\frac{BASE_{OLD}}{BASE_{NEW}}
    
    Parameters
    ----------
    quantity:   complex
                Current per-unit value in old base.
    puB_old:    float
                Old per-unit base.
    puB_new:    float
                New per-unit base.
    
    Returns
    -------
    pu_new:     complex
                New per-unit value.
    &#34;&#34;&#34;
    pu_new = quantity*puB_old/puB_new
    return(pu_new)</code></pre>
</details>
</dd>
<dt id="electricpy.rad_to_hz"><code class="name flex">
<span>def <span class="ident">rad_to_hz</span></span>(<span>radians)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple Radians to Hertz Converter</p>
<p>Accepts a frequency in radians/sec and calculates
the hertzian frequency (in Hz).</p>
<p>[
]
Same as <code><a title="electricpy.hertz" href="#electricpy.hertz">rad_to_hz()</a></code>.</p>
<h2 id="paramters">Paramters</h2>
<p>radians:
float
The frequency (represented in radians/sec)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hertz</code></strong> :&ensp;<code>
float</code></dt>
<dd>The frequency (represented in Hertz)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rad_to_hz( radians ):
    &#34;&#34;&#34;
    Simple Radians to Hertz Converter
    
    Accepts a frequency in radians/sec and calculates
    the hertzian frequency (in Hz).
    
    .. math:: f_{\\text{Hz}} = \\frac{f_{\\text{rad/sec}}}{2\\cdot\\pi}
    
    Same as `hertz`.
    
    Paramters
    ---------
    radians:    float
                The frequency (represented in radians/sec)
    
    Returns
    -------
    hertz:      float
                The frequency (represented in Hertz)
    &#34;&#34;&#34;
    return( radians / (2*_np.pi) ) # Evaluate and Return</code></pre>
</details>
</dd>
<dt id="electricpy.rad_to_rpm"><code class="name flex">
<span>def <span class="ident">rad_to_rpm</span></span>(<span>rad)</span>
</code></dt>
<dd>
<div class="desc"><p>Radians-per-Second to RPM Converter</p>
<p>Given the angular velocity in rad/sec, this
function will evaluate the velocity in RPM
(Revolutions-Per-Minute).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rad</code></strong> :&ensp;<code>
float</code></dt>
<dd>The angular velocity in radians-
per-second</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rpm</code></strong> :&ensp;<code>
float</code></dt>
<dd>The angular velocity in revolutions-
per-minute (RPM)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rad_to_rpm(rad):
    &#34;&#34;&#34;
    Radians-per-Second to RPM Converter
    
    Given the angular velocity in rad/sec, this
    function will evaluate the velocity in RPM
    (Revolutions-Per-Minute).
    
    Parameters
    ----------
    rad:        float
                The angular velocity in radians-
                per-second
    
    Returns
    -------
    rpm:        float
                The angular velocity in revolutions-
                per-minute (RPM)
    &#34;&#34;&#34;
    rpm = 60/(2*_np.pi)*rad
    return(rpm)</code></pre>
</details>
</dd>
<dt id="electricpy.radsec"><code class="name flex">
<span>def <span class="ident">radsec</span></span>(<span>hertz)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple Hertz to Radians Converter</p>
<p>Accepts a frequency in Hertz and calculates
the frequency in radians/sec.</p>
<p>[
]
Same as <code><a title="electricpy.radsec" href="#electricpy.radsec">hz_to_rad()</a></code>.</p>
<h2 id="paramters">Paramters</h2>
<p>hertz:
float
The frequency (represented in Hertz)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>radians</code></strong> :&ensp;<code>
float</code></dt>
<dd>The frequency (represented in radians/sec)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hz_to_rad( hertz ):
    &#34;&#34;&#34;
    Simple Hertz to Radians Converter
    
    Accepts a frequency in Hertz and calculates
    the frequency in radians/sec.
    
    .. math:: f_{\\text{rad/sec}} = f_{\\text{Hz}}\\cdot2\\cdot\\pi
    
    Same as `radsec`.
    
    Paramters
    ---------
    hertz:      float
                The frequency (represented in Hertz)
    
    Returns
    -------
    radians:    float
                The frequency (represented in radians/sec)
    &#34;&#34;&#34;
    return( hertz * (2*_np.pi) ) # Evaluate and Return</code></pre>
</details>
</dd>
<dt id="electricpy.reactance"><code class="name flex">
<span>def <span class="ident">reactance</span></span>(<span>z, freq=60, sensetivity=1e-12)</span>
</code></dt>
<dd>
<div class="desc"><p>Capacitance/Inductance from Impedance</p>
<p>Calculates the Capacitance or Inductance in Farads or Henreys
(respectively) provided the impedance of an element.
Will return capacitance (in Farads) if ohmic impedance is
negative :eq:<code>cap</code>, or inductance (in Henrys) if ohmic impedance is
positive :eq:<code>ind</code>. If imaginary: calculate with j factor
(imaginary number).</p>
<p>[ :label: cap ]
[ :label: ind ]
This requires that the radian frequency is found as follows:</p>
<p>[
]
where <code>freq</code> is the frequency in Hertz.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It's worth noting here, that the resistance will be found by
extracting the real part of a complex value. That is:</p>
<p>[
]</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>z</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The Impedance Provided, may be complex (R+jI)</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Frequency Base for Provided Impedance, default=60</dd>
<dt><strong><code>sensetivity</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The sensetivity used to check if a resistance was
provided, default=1e-12</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>
float</code></dt>
<dd>Capacitance or Inductance of Impedance</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reactance(z,freq=60,sensetivity=1e-12):
    &#34;&#34;&#34;
    Capacitance/Inductance from Impedance
    
    Calculates the Capacitance or Inductance in Farads or Henreys
    (respectively) provided the impedance of an element.
    Will return capacitance (in Farads) if ohmic impedance is
    negative :eq:`cap`, or inductance (in Henrys) if ohmic impedance is
    positive :eq:`ind`. If imaginary: calculate with j factor
    (imaginary number).
    
    .. math:: C = \\frac{1}{\\omega*Z}
       :label: cap
    
    .. math:: L = \\frac{Z}{\\omega}
       :label: ind
    
    This requires that the radian frequency is found as follows:
    
    .. math:: \\omega = 2*\\pi*freq
    
    where `freq` is the frequency in Hertz.
    
    .. note::
       It&#39;s worth noting here, that the resistance will be found by
       extracting the real part of a complex value. That is:
       
       .. math:: R = Real( R + jX )
       
    
    Parameters
    ----------
    z:              complex
                    The Impedance Provided, may be complex (R+jI)
    freq:           float, optional
                    The Frequency Base for Provided Impedance, default=60
    sensetivity:    float, optional
                    The sensetivity used to check if a resistance was
                    provided, default=1e-12
    
    Returns
    -------
    out:            float
                    Capacitance or Inductance of Impedance
    &#34;&#34;&#34;
    # Evaluate Omega
    w = 2*_np.pi*freq
    # Input is Complex
    if isinstance(z, complex):
        # Test for Resistance
        if(abs(z.real) &gt; sensetivity):
            R = z.real
        else:
            R = 0
        if (z.imag &gt; 0):
            out = z/(w*1j)
        else:
            out = 1/(w*1j*z)
        out = abs(out)
        # Combine with resistance if present
        if(R!=0): out = (R, out)
    else:
        if (z &gt; 0):
            out = z/(w)
        else:
            out = 1/(w*z)
        out = abs(out)
    # Return Output
    return(out)</code></pre>
</details>
</dd>
<dt id="electricpy.rectifiercap"><code class="name flex">
<span>def <span class="ident">rectifiercap</span></span>(<span>Iload, fswitch, dVout)</span>
</code></dt>
<dd>
<div class="desc"><p>Rectifier Capacitor Formula</p>
<p>Returns the capacitance (in Farads) for a needed capacitor in
a rectifier configuration given the system frequency (in Hz),
the load (in amps) and the desired voltage ripple.</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Iload</code></strong> :&ensp;<code>
float</code></dt>
<dd>The load current that must be met.</dd>
<dt><strong><code>fswitch</code></strong> :&ensp;<code>
float</code></dt>
<dd>The switching frequency of the system.</dd>
<dt><strong><code>dVout</code></strong> :&ensp;<code>
float</code></dt>
<dd>Desired delta-V on the output.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>
float</code></dt>
<dd>Required capacitance (in Farads) to meet arguments.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rectifiercap(Iload, fswitch, dVout):
    &#34;&#34;&#34;
    Rectifier Capacitor Formula
    
    Returns the capacitance (in Farads) for a needed capacitor in
    a rectifier configuration given the system frequency (in Hz),
    the load (in amps) and the desired voltage ripple.
    
    .. math:: C=\\frac{I_{load}}{f_{switch}*\\Delta V_{out}}
    
    Parameters
    ----------
    Iload:      float
                The load current that must be met.
    fswitch:    float
                The switching frequency of the system.
    dVout:      float
                Desired delta-V on the output.
    
    Returns
    -------
    C:          float
                Required capacitance (in Farads) to meet arguments.
    &#34;&#34;&#34;
    C = Iload / (fswitch * dVout)
    return(C)</code></pre>
</details>
</dd>
<dt id="electricpy.rfft"><code class="name flex">
<span>def <span class="ident">rfft</span></span>(<span>arr, dt=0.01, absolute=True, resample=True)</span>
</code></dt>
<dd>
<div class="desc"><p>RFFT Function</p>
<p>This function is designed to evaluat the real FFT
of a input signal in the form of an array or list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>The input array representing the signal</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The time-step used for the array,
default=0.01</dd>
<dt><strong><code>absolute</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force absolute
values, default=True</dd>
<dt><strong><code>resample</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument specifying whether
the FFT output should be resampled,
or if it should have a specific
resampling rate, default=True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>FFT Array</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rfft(arr,dt=0.01,absolute=True,resample=True):
    &#34;&#34;&#34;
    RFFT Function
    
    This function is designed to evaluat the real FFT
    of a input signal in the form of an array or list.
    
    Parameters
    ----------
    arr:        numpy.ndarray
                The input array representing the signal
    dt:         float, optional
                The time-step used for the array,
                default=0.01
    absolute:   bool, optional
                Control argument to force absolute
                values, default=True
    resample:   bool, optional
                Control argument specifying whether
                the FFT output should be resampled,
                or if it should have a specific
                resampling rate, default=True
    
    Returns
    -------
    FFT Array
    &#34;&#34;&#34;
    # Calculate with Absolute Values
    if absolute:
        fourier = abs(_np.fft.rfft(arr))
    else:
        foruier = _np.fft.rfft(arr)
    if resample==True:
        # Evaluate the Downsampling Ratio
        dn = int(dt*len(arr))
        # Downsample to remove unnecessary points
        fixedfft = filter.dnsample(fourier,dn)
        return(fixedfft)
    elif resample==False:
        return(fourier)
    else:
        # Condition Resample Value
        resample = int(resample)
        # Downsample to remove unnecessary points
        fixedfft = filter.dnsample(fourier,resample)
        return(fixedfft)</code></pre>
</details>
</dd>
<dt id="electricpy.rms"><code class="name flex">
<span>def <span class="ident">rms</span></span>(<span>val)</span>
</code></dt>
<dd>
<div class="desc"><p>Sinusoid Peak to RMS Converter</p>
<p>Provides a readable format to convert a peak
value to its RMS (Root-Mean-Square) representation.
Performs a simple division by the square-root of
two.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rms(val):
    &#34;&#34;&#34;
    Sinusoid Peak to RMS Converter
    
    Provides a readable format to convert a peak
    value to its RMS (Root-Mean-Square) representation.
    Performs a simple division by the square-root of
    two.
    &#34;&#34;&#34;
    return(val * _np.sqrt(0.5))</code></pre>
</details>
</dd>
<dt id="electricpy.rpm_to_hz"><code class="name flex">
<span>def <span class="ident">rpm_to_hz</span></span>(<span>rpm)</span>
</code></dt>
<dd>
<div class="desc"><p>RPM to Hertz Converter</p>
<p>Given the angular velocity in RPM (Revolutions-
Per-Minute), this function will evaluate the
velocity in Hertz.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rpm</code></strong> :&ensp;<code>
float</code></dt>
<dd>The angular velocity in revolutions-
per-minute (RPM)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hz</code></strong> :&ensp;<code>
float</code></dt>
<dd>The angular velocity in Hertz</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rpm_to_hz(rpm):
    &#34;&#34;&#34;
    RPM to Hertz Converter
    
    Given the angular velocity in RPM (Revolutions-
    Per-Minute), this function will evaluate the
    velocity in Hertz.
    
    Parameters
    ----------
    rpm:        float
                The angular velocity in revolutions-
                per-minute (RPM)
    
    Returns
    -------
    hz:         float
                The angular velocity in Hertz
    &#34;&#34;&#34;
    hz = rpm/60
    return(hz)</code></pre>
</details>
</dd>
<dt id="electricpy.rpm_to_rad"><code class="name flex">
<span>def <span class="ident">rpm_to_rad</span></span>(<span>rpm)</span>
</code></dt>
<dd>
<div class="desc"><p>RPM to Radians-per-Second Converter</p>
<p>Given the angular velocity in RPM (Revolutions-
Per-Minute), this function will evaluate the
velocity in rad/sec.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rpm</code></strong> :&ensp;<code>
float</code></dt>
<dd>The angular velocity in revolutions-
per-minute (RPM)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rad</code></strong> :&ensp;<code>
float</code></dt>
<dd>The angular velocity in radians-
per-second</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rpm_to_rad(rpm):
    &#34;&#34;&#34;
    RPM to Radians-per-Second Converter
    
    Given the angular velocity in RPM (Revolutions-
    Per-Minute), this function will evaluate the
    velocity in rad/sec.
    
    Parameters
    ----------
    rpm:        float
                The angular velocity in revolutions-
                per-minute (RPM)
    
    Returns
    -------
    rad:        float
                The angular velocity in radians-
                per-second
    &#34;&#34;&#34;
    rad = 2*_np.pi/60*rpm
    return(rad)</code></pre>
</details>
</dd>
<dt id="electricpy.rtdtemp"><code class="name flex">
<span>def <span class="ident">rtdtemp</span></span>(<span>RT, rtdtype='PT100', fahrenheit=False, Rref=None, Tref=None, a=None, round=1)</span>
</code></dt>
<dd>
<div class="desc"><p>RTD Temperature Calculator</p>
<p>Evaluates the measured temperature based on the measured resistance
and the RTD type.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>RT</code></strong> :&ensp;<code>
float</code></dt>
<dd>The measured resistance (in ohms).</dd>
<dt><strong><code>rtdtype</code></strong> :&ensp;<code>
string</code></dt>
<dd>RTD Type string, may be one of: (PT100, PT1000,
CU100, NI100, NI120, NIFE), default=PT100</dd>
<dt><strong><code>fahrenheit</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Control parameter to force return into degrees
fahrenheit, default=False</dd>
<dt><strong><code>Rref</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Resistance reference, commonly used if non-standard
RTD type being used. Specified in ohms.</dd>
<dt><strong><code>Tref</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Temperature reference, commonly used if non-standard
RTD type being used. Specified in degrees Celsius.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Scaling value, commonly used if non-standard
RTD type being used.</dd>
<dt><strong><code>round</code></strong> :&ensp;<code>
int</code>, optional</dt>
<dd>Control argument to specify number of decimal points
in returned value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>temp</code></strong> :&ensp;<code>
float</code></dt>
<dd>Calculated temperature, defaults to degrees Celsius.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rtdtemp(RT,rtdtype=&#34;PT100&#34;,fahrenheit=False,Rref=None,Tref=None,
            a=None,round=1):
    &#34;&#34;&#34;
    RTD Temperature Calculator
    
    Evaluates the measured temperature based on the measured resistance
    and the RTD type.
    
    Parameters
    ----------
    RT:         float
                The measured resistance (in ohms).
    rtdtype:    string
                RTD Type string, may be one of: (PT100, PT1000,
                CU100, NI100, NI120, NIFE), default=PT100
    fahrenheit: bool, optional
                Control parameter to force return into degrees
                fahrenheit, default=False
    Rref:       float, optional
                Resistance reference, commonly used if non-standard
                RTD type being used. Specified in ohms.
    Tref:       float, optional
                Temperature reference, commonly used if non-standard
                RTD type being used. Specified in degrees Celsius.
    a:          float, optional
                Scaling value, commonly used if non-standard
                RTD type being used.
    round:      int, optional
                Control argument to specify number of decimal points
                in returned value.
    
    Returns
    -------
    temp:       float
                Calculated temperature, defaults to degrees Celsius.
    &#34;&#34;&#34;
    # Define list of available builtin RTD Types
    types = {   &#34;PT100&#34; : [100,0.00385],
                &#34;PT1000&#34;: [1000,0.00385],
                &#34;CU100&#34; : [100,0.00427],
                &#34;NI100&#34; : [100,0.00618],
                &#34;NI120&#34; : [120,0.00672],
                &#34;NIFE&#34;  : [604,0.00518]
            }
    # Load Variables
    if Rref==None:
        Rref = types[rtdtype][0]
    if Tref==None:
        Tref = 0
    if a==None:
        a = types[rtdtype][1]
    # Define Terms
    num = RT - Rref + Rref*a*Tref
    den = Rref*a
    temp = num/den
    # Return Temperature
    if fahrenheit:
        temp = (temp*9/5)+32
    temp = _np.around(temp,round)
    return(temp)</code></pre>
</details>
</dd>
<dt id="electricpy.rxrecompose"><code class="name flex">
<span>def <span class="ident">rxrecompose</span></span>(<span>x_pu, XoR, S3phs=None, VLL=None, VLN=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Resistance/Reactance from Per-Unit System Evaluator</p>
<p>Function to reverse per-unit conversion and return the ohmic value
of an impedance given its per-unit parameters of X.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x_pu</code></strong> :&ensp;<code>
float</code></dt>
<dd>The per-unit, complex value corresponding to the
impedance</dd>
<dt><strong><code>XoR</code></strong> :&ensp;<code>
float</code></dt>
<dd>The X/R ratio (reactance over impedance).</dd>
<dt><strong><code>S3phs</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The total three-phase power rating of the system.
If left as None, the per-unit values will be set
to 1, resulting in an unscaled impedance</dd>
<dt><strong><code>VLL</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Line-to-Line Voltage; default=None</dd>
<dt><strong><code>VLN</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Line-to-Neutral Voltage; default=None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>z</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The ohmic impedance evaluated from the per-unit base.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rxrecompose(x_pu,XoR,S3phs=None,VLL=None,VLN=None):
    &#34;&#34;&#34;
    Resistance/Reactance from Per-Unit System Evaluator
    
    Function to reverse per-unit conversion and return the ohmic value
    of an impedance given its per-unit parameters of X.
    
    Parameters
    ----------
    x_pu:       float
                The per-unit, complex value corresponding to the
                impedance
    XoR:        float
                The X/R ratio (reactance over impedance).
    S3phs:      float, optional
                The total three-phase power rating of the system.
                If left as None, the per-unit values will be set
                to 1, resulting in an unscaled impedance
    VLL:        float, optional
                The Line-to-Line Voltage; default=None
    VLN:        float, optional
                The Line-to-Neutral Voltage; default=None
    
    Returns
    -------
    z:          complex
                The ohmic impedance evaluated from the per-unit base.
    &#34;&#34;&#34;
    # Ensure Absolute Value
    x_pu = abs(x_pu)
    # Find R from X/R
    r_pu = x_pu/XoR
    # Compose into z
    z_pu = r_pu + 1j*x_pu
    # Recompose
    if S3phs == None:
        return(z_pu)
    else:
        z = zrecompose(z_pu,S3phs,VLL,VLN)
        return(z)</code></pre>
</details>
</dd>
<dt id="electricpy.sampfft"><code class="name flex">
<span>def <span class="ident">sampfft</span></span>(<span>data, dt, minfreq=60.0, complex=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sampled Dataset FFT Evaluator</p>
<p>Given a data array and the delta-t for the data array, evaluates
the harmonic composition of the data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>Numpy data array containing 1-D values.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>
float</code></dt>
<dd>Time-difference (delta-t) between data samples.</dd>
<dt><strong><code>minfreq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Minimum frequency (in Hz) at which to evaluate FFT.
default=60</dd>
<dt><strong><code>complex</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force returned values into
complex format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>DC</code></strong> :&ensp;<code>
float</code></dt>
<dd>The DC offset of the FFT result.</dd>
<dt><strong><code>A</code></strong> :&ensp;<code>
list</code> of <code>float</code></dt>
<dd>The real components from the FFT.</dd>
<dt><strong><code>B</code></strong> :&ensp;<code>
list</code> of <code>float</code></dt>
<dd>The imaginary components from the FFT.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sampfft(data,dt,minfreq=60.0,complex=False):
    &#34;&#34;&#34;
    Sampled Dataset FFT Evaluator
    
    Given a data array and the delta-t for the data array, evaluates
    the harmonic composition of the data.
    
    Parameters
    ----------
    data:       numpy.ndarray
                Numpy data array containing 1-D values.
    dt:         float
                Time-difference (delta-t) between data samples.
    minfreq:    float, optional
                Minimum frequency (in Hz) at which to evaluate FFT.
                default=60
    complex:    bool, optional
                Control argument to force returned values into
                complex format.
    
    Returns
    -------
    DC:         float
                The DC offset of the FFT result.
    A:          list of float
                The real components from the FFT.
    B:          list of float
                The imaginary components from the FFT.
    &#34;&#34;&#34;
    # Calculate Terms
    FR = 1/(dt*len(data))
    NN = 1//(dt*minfreq)
    # Test for Invalid System
    if FR &gt; minfreq:
        raise ValueError(&#34;Too few data samples to evaluate FFT at specified minimum frequency.&#34;)
    elif FR == minfreq:
        # Evaluate FFT
        y = _np.fft.rfft(data) / len(data)
    else:
        # Slice data array to appropriate fundamental frequency
        cut_data = data[:int(NN)]
        # Evaluate FFT
        y = _np.fft.rfft(cut_data) / len(cut_data)
    # Return Complex Values
    if complex:
       return(y)
    # Split out useful values
    else:
       y *= 2
       return(y[0].real, y[1:-1].real, -y[1:-1].imag)</code></pre>
</details>
</dd>
<dt id="electricpy.secondary"><code class="name flex">
<span>def <span class="ident">secondary</span></span>(<span>val, Np, Ns=1, invert=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Transformer Secondary Evaluator</p>
<p>Returns a current or voltage value reflected across
a transformer with a specified turns ratio Np/Ns.
Converts to the secondary side.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>val</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Value to be reflected across transformer.</dd>
<dt><strong><code>Np</code></strong> :&ensp;<code>
float</code></dt>
<dd>Number of turns on primary side.</dd>
<dt><strong><code>Ns</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Number of turns on secondary side.</dd>
<dt><strong><code>invert</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to invert the turns ratio,
used when reflecting current across a
voltage transformer, or voltage across a
current transformer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>reflection</code></strong> :&ensp;<code>complex</code></dt>
<dd>The reflected value referred to the secondary
side according to Np and Ns.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def secondary(val, Np, Ns=1,invert=False):
    &#34;&#34;&#34;
    Transformer Secondary Evaluator
    
    Returns a current or voltage value reflected across
    a transformer with a specified turns ratio Np/Ns.
    Converts to the secondary side.
    
    Parameters
    ----------
    val:        complex
                Value to be reflected across transformer.
    Np:         float
                Number of turns on primary side.
    Ns:         float, optional
                Number of turns on secondary side.
    invert:     bool, optional
                Control argument to invert the turns ratio,
                used when reflecting current across a
                voltage transformer, or voltage across a
                current transformer.
    
    Returns
    -------
    reflection: complex
                The reflected value referred to the secondary
                side according to Np and Ns.
    &#34;&#34;&#34;
    if invert:
        return( val * Np/Ns )
    return( val * Ns/Np )</code></pre>
</details>
</dd>
<dt id="electricpy.seq_to_abc"><code class="name flex">
<span>def <span class="ident">seq_to_abc</span></span>(<span>M012, reference='A')</span>
</code></dt>
<dd>
<div class="desc"><p>Sequence-System to Phase-System Conversion</p>
<p>Converts sequence-based values to phase
components.</p>
<p>[
]
Same as seq_to_phs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>M012</code></strong> :&ensp;<code>
list</code> of <code>complex</code></dt>
<dd>Sequence-based values to convert.</dd>
<dt><strong><code>reference</code></strong> :&ensp;<code>{'A', 'B', 'C'}</code></dt>
<dd>Single character denoting the reference,
default='A'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Mabc</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>Phase-based values in order of A-B-C</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.abc_to_seq" href="#electricpy.abc_to_seq">abc_to_seq()</a></code></dt>
<dd>Phase to Sequence Conversion</dd>
<dt><code><a title="electricpy.sequencez" href="#electricpy.sequencez">sequencez()</a></code></dt>
<dd>Phase Impedance to Sequence Converter</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seq_to_abc(M012,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Sequence-System to Phase-System Conversion
    
    Converts sequence-based values to phase
    components.
    
    .. math:: M_{\\text{ABC}}=A_{\\text{012}}^{-1}\\cdot M_{\\text{012}}
    
    Same as seq_to_phs.
    
    Parameters
    ----------
    M012:       list of complex
                Sequence-based values to convert.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    
    Returns
    -------
    Mabc:       numpy.ndarray
                Phase-based values in order of A-B-C
    
    See Also
    --------
    abc_to_seq: Phase to Sequence Conversion
    sequencez:  Phase Impedance to Sequence Converter
    &#34;&#34;&#34;
    # Compute Dot Product
    M = A012.dot(M012)
    # Condition Reference:
    reference = reference.upper()
    if reference == &#39;A&#39;:
        pass
    elif reference == &#39;B&#39;:
        M = _np.roll(M, 1, 0)
    elif reference == &#39;C&#39;:
        M = _np.roll(M, 2, 0)
    else:
        raise ValueError(&#34;Invalid Phase Reference.&#34;)
    return(M)</code></pre>
</details>
</dd>
<dt id="electricpy.seq_to_phs"><code class="name flex">
<span>def <span class="ident">seq_to_phs</span></span>(<span>M012, reference='A')</span>
</code></dt>
<dd>
<div class="desc"><p>Sequence-System to Phase-System Conversion</p>
<p>Converts sequence-based values to phase
components.</p>
<p>[
]
Same as seq_to_phs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>M012</code></strong> :&ensp;<code>
list</code> of <code>complex</code></dt>
<dd>Sequence-based values to convert.</dd>
<dt><strong><code>reference</code></strong> :&ensp;<code>{'A', 'B', 'C'}</code></dt>
<dd>Single character denoting the reference,
default='A'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Mabc</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>Phase-based values in order of A-B-C</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.abc_to_seq" href="#electricpy.abc_to_seq">abc_to_seq()</a></code></dt>
<dd>Phase to Sequence Conversion</dd>
<dt><code><a title="electricpy.sequencez" href="#electricpy.sequencez">sequencez()</a></code></dt>
<dd>Phase Impedance to Sequence Converter</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seq_to_abc(M012,reference=&#39;A&#39;):
    &#34;&#34;&#34;
    Sequence-System to Phase-System Conversion
    
    Converts sequence-based values to phase
    components.
    
    .. math:: M_{\\text{ABC}}=A_{\\text{012}}^{-1}\\cdot M_{\\text{012}}
    
    Same as seq_to_phs.
    
    Parameters
    ----------
    M012:       list of complex
                Sequence-based values to convert.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    
    Returns
    -------
    Mabc:       numpy.ndarray
                Phase-based values in order of A-B-C
    
    See Also
    --------
    abc_to_seq: Phase to Sequence Conversion
    sequencez:  Phase Impedance to Sequence Converter
    &#34;&#34;&#34;
    # Compute Dot Product
    M = A012.dot(M012)
    # Condition Reference:
    reference = reference.upper()
    if reference == &#39;A&#39;:
        pass
    elif reference == &#39;B&#39;:
        M = _np.roll(M, 1, 0)
    elif reference == &#39;C&#39;:
        M = _np.roll(M, 2, 0)
    else:
        raise ValueError(&#34;Invalid Phase Reference.&#34;)
    return(M)</code></pre>
</details>
</dd>
<dt id="electricpy.sequencez"><code class="name flex">
<span>def <span class="ident">sequencez</span></span>(<span>Zabc, reference='A', resolve=False, diag=False, round=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Sequence Impedance Calculator</p>
<p>Accepts the phase (ABC-domain) impedances for a
system and calculates the sequence (012-domain)
impedances for the same system. If the argument
<code>resolve</code> is set to true, the function will
combine terms into the set of [Z0, Z1, Z2].</p>
<p>When resolve is False:</p>
<p>[
]
When resolve is True:</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Zabc</code></strong> :&ensp;<code>
numpy.ndarray</code> of <code>complex</code></dt>
<dd>2-D (3x3) matrix of complex values
representing the phasor impedances
in the ABC-domain.</dd>
<dt><strong><code>reference</code></strong> :&ensp;<code>{'A', 'B', 'C'}</code></dt>
<dd>Single character denoting the reference,
default='A'</dd>
<dt><strong><code>resolve</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force the function to
evaluate the individual sequence impedances
[Z0, Z1, Z2], default=False</dd>
<dt><strong><code>diag</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force the function to
reduce the matrix to its diagonal terms.</dd>
<dt><strong><code>round</code></strong> :&ensp;<code>
int</code>, optional</dt>
<dd>Integer denoting number of decimal places
resulting matrix should be rounded to.
default=3</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Z012</code></strong> :&ensp;<code>
numpy.ndarray</code> of <code>complex</code></dt>
<dd>2-D (3x3) matrix of complex values
representing the sequence impedances
in the 012-domain</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="electricpy.seq_to_abc" href="#electricpy.seq_to_abc">seq_to_abc()</a></code></dt>
<dd>Sequence to Phase Conversion</dd>
<dt><code><a title="electricpy.abc_to_seq" href="#electricpy.abc_to_seq">abc_to_seq()</a></code></dt>
<dd>Phase to Sequence Conversion</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sequencez(Zabc,reference=&#39;A&#39;,resolve=False,diag=False,round=3):
    &#34;&#34;&#34;
    Sequence Impedance Calculator
    
    Accepts the phase (ABC-domain) impedances for a
    system and calculates the sequence (012-domain)
    impedances for the same system. If the argument
    `resolve` is set to true, the function will
    combine terms into the set of [Z0, Z1, Z2].
    
    When resolve is False:
    
    .. math:: Z_{\\text{012-M}}=A_{\\text{012}}^{-1}Z_{\\text{ABC}}A_{\\text{012}}
    
    When resolve is True:
    
    .. math:: Z_{\\text{012}}=A_{\\text{012}}Z_{\\text{ABC}}A_{\\text{012}}^{-1}
    
    Parameters
    ----------
    Zabc:       numpy.ndarray of complex
                2-D (3x3) matrix of complex values
                representing the phasor impedances
                in the ABC-domain.
    reference:  {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;}
                Single character denoting the reference,
                default=&#39;A&#39;
    resolve:    bool, optional
                Control argument to force the function to
                evaluate the individual sequence impedances
                [Z0, Z1, Z2], default=False
    diag:       bool, optional
                Control argument to force the function to
                reduce the matrix to its diagonal terms.
    round:      int, optional
                Integer denoting number of decimal places
                resulting matrix should be rounded to.
                default=3
    
    Returns
    -------
    Z012:       numpy.ndarray of complex
                2-D (3x3) matrix of complex values
                representing the sequence impedances
                in the 012-domain
    
    See Also
    --------
    seq_to_abc: Sequence to Phase Conversion
    abc_to_seq: Phase to Sequence Conversion
    &#34;&#34;&#34;
    # Condition Reference
    reference = reference.upper()
    rollrate = {&#39;A&#39;:0,&#39;B&#39;:1,&#39;C&#39;:2}
    # Test Validity
    if reference not in rollrate:
        raise ValueError(&#34;Invalad Phase Reference&#34;)
    # Determine Roll Factor
    roll = rollrate[ reference ]
    # Evaluate Matricies
    M012 = _np.roll(A012,roll,0)
    Minv = _np.linalg.inv(M012)
    # Compute Sequence Impedances
    if resolve:
        Z012 = M012.dot( Zabc.dot(Minv) )
    else:
        Z012 = Minv.dot( Zabc.dot(M012) )
    # Reduce to Diagonal Terms if Needed
    if diag:
        Z012 = [Z012[0][0],Z012[1][1],Z012[2][2]]
    return(_np.around(Z012,round))</code></pre>
</details>
</dd>
<dt id="electricpy.shannondata"><code class="name flex">
<span>def <span class="ident">shannondata</span></span>(<span>BW, S, N)</span>
</code></dt>
<dd>
<div class="desc"><p>Shannon Data Function</p>
<p>Function to calculate the maximum data
rate that may be achieved given a data
channel and signal/noise characteristics
using Shannon's equation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>BW</code></strong> :&ensp;<code>
float</code></dt>
<dd>Bandwidth of the data channel.</dd>
<dt><strong><code>S</code></strong> :&ensp;<code>
float</code></dt>
<dd>Signal strength (in Watts).</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>
float</code></dt>
<dd>Noise strength (in Watts).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>C</code></strong> :&ensp;<code>
float</code></dt>
<dd>Capacity of channel (in bits per second)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shannondata(BW,S,N):
    &#34;&#34;&#34;
    Shannon Data Function
    
    Function to calculate the maximum data
    rate that may be achieved given a data
    channel and signal/noise characteristics
    using Shannon&#39;s equation.
    
    Parameters
    ----------
    BW:         float
                Bandwidth of the data channel.
    S:          float
                Signal strength (in Watts).
    N:          float
                Noise strength (in Watts).
    
    Returns
    -------
    C:          float
                Capacity of channel (in bits per second)
    &#34;&#34;&#34;
    C = BW*_np.log2(1+S/N)
    return(C)</code></pre>
</details>
</dd>
<dt id="electricpy.sinfilt"><code class="name flex">
<span>def <span class="ident">sinfilt</span></span>(<span>arr, Srate, domain=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sine Filter Function</p>
<p>Sine Filter function for filtering a dataset
representing a sinusoidal function with or without
harmonics to evaluate the fundamental value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>The input data array.</dd>
<dt><strong><code>Srate</code></strong> :&ensp;<code>
int</code></dt>
<dd>Sampling rate for dataset, specified in
number of values per fundamental cycle.</dd>
<dt><strong><code>domain</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to force return of
x-axis array for the filtered data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>sinf</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>Sine-filtered data</dd>
<dt><strong><code>xarray</code></strong> :&ensp;<code>
numpy.ndarray</code></dt>
<dd>X-axis array for the filtered data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sinfilt(arr,Srate,domain=False):
    &#34;&#34;&#34;
    Sine Filter Function
    
    Sine Filter function for filtering a dataset
    representing a sinusoidal function with or without
    harmonics to evaluate the fundamental value.
    
    Parameters
    ----------
    arr:        numpy.ndarray
                The input data array.
    Srate:      int
                Sampling rate for dataset, specified in
                number of values per fundamental cycle.
    domain:     bool, optional
                Control argument to force return of
                x-axis array for the filtered data.
    
    Returns
    -------
    sinf:       numpy.ndarray
                Sine-filtered data
    xarray:     numpy.ndarray
                X-axis array for the filtered data.
    &#34;&#34;&#34;
    # Evaluate index set
    ind = _np.arange(Srate-1, len(arr)-1)
    # Define Cosine Coefficient Function
    def sin(k,Srate):
        return(_np.sin(2*_np.pi*k/Srate))
    # Calculate Constant
    const = 2/Srate
    # Iteratively Calculate
    sinf = 0
    for k in range(0,Srate-1):
        slc = (ind-(Srate-1))+k
        sinf += sin(k,Srate) * arr[slc]
    # Scale
    sinf = const * sinf
    # Return Cosine-Filtered Array
    if domain:
        xarray = _np.linspace(Srate+Srate/4-1,len(arr)-1,len(sinf))
        xarray = xarray / Srate
        return(sinf,xarray)
    return(sinf)</code></pre>
</details>
</dd>
<dt id="electricpy.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>t)</span>
</code></dt>
<dd>
<div class="desc"><p>Step Function [ u(t) ]</p>
<p>Simple implimentation of numpy.heaviside function
to provide standard step-function as specified to
be zero at x&lt;0, and one at x&gt;=0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(t):
    &#34;&#34;&#34;
    Step Function [ u(t) ]
    
    Simple implimentation of numpy.heaviside function
    to provide standard step-function as specified to
    be zero at x&lt;0, and one at x&gt;=0.
    &#34;&#34;&#34;
    return( _np.heaviside( t, 1) )</code></pre>
</details>
</dd>
<dt id="electricpy.string_to_bits"><code class="name flex">
<span>def <span class="ident">string_to_bits</span></span>(<span>str)</span>
</code></dt>
<dd>
<div class="desc"><p>String to Bits Converter</p>
<p>Converts a Pythonic string to the string's
binary representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>str</code></strong> :&ensp;<code>
string</code></dt>
<dd>The string to be converted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>
string</code></dt>
<dd>The binary representation of the
input string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def string_to_bits(str):
    &#34;&#34;&#34;
    String to Bits Converter
    
    Converts a Pythonic string to the string&#39;s
    binary representation.
    
    Parameters
    ----------
    str:        string
                The string to be converted.
    
    Returns
    -------
    data:       string
                The binary representation of the
                input string.
    &#34;&#34;&#34;
    data = (&#39;&#39;.join(format(ord(x), &#39;b&#39;) for x in str))
    return(data)</code></pre>
</details>
</dd>
<dt id="electricpy.syncspeed"><code class="name flex">
<span>def <span class="ident">syncspeed</span></span>(<span>Npol, freq=60, Hz=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Synchronous Speed Calculator Function</p>
<p>Simple method of calculating the synchronous
speed of an induction machine given the number
of poles in the machine's construction, and
the machine's operating electrical frequency.</p>
<p>[ \cdot\text{freq}}{\frac{N_{\text{pol}}}{2}} ]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Npol</code></strong> :&ensp;<code>
int</code></dt>
<dd>Number of electrical poles in
machine's construction.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Frequency of electrical system in
Hertz, default=60</dd>
<dt><strong><code>Hz</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Boolean control to enable return
in Hertz. default=False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>wsyn</code></strong> :&ensp;<code>
float</code></dt>
<dd>Synchronous Speed of Induction Machine,
defaults to units of rad/sec, but may
be set to Hertz if <code>Hz</code> set to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def syncspeed(Npol,freq=60,Hz=False):
    &#34;&#34;&#34;
    Synchronous Speed Calculator Function
    
    Simple method of calculating the synchronous
    speed of an induction machine given the number
    of poles in the machine&#39;s construction, and
    the machine&#39;s operating electrical frequency.
    
    .. math:: \\omega_{\\text{syn}}=\\frac{2\\pi
       \\cdot\\text{freq}}{\\frac{N_{\\text{pol}}}{2}}
    
    Parameters
    ----------
    Npol:       int
                Number of electrical poles in
                machine&#39;s construction.
    freq:       float, optional
                Frequency of electrical system in
                Hertz, default=60
    Hz:         bool, optional
                Boolean control to enable return
                in Hertz. default=False
    
    Returns
    -------
    wsyn:       float
                Synchronous Speed of Induction Machine,
                defaults to units of rad/sec, but may
                be set to Hertz if `Hz` set to True.
    &#34;&#34;&#34;
    wsyn = 2*_np.pi*freq / (Npol/2)
    if Hz:
        return(wsyn / (2*_np.pi))
    return(wsyn)</code></pre>
</details>
</dd>
<dt id="electricpy.synmach_Eq"><code class="name flex">
<span>def <span class="ident">synmach_Eq</span></span>(<span>Vt_pu, Itmag, PF, Ra, Xd, Xq)</span>
</code></dt>
<dd>
<div class="desc"><p>Synchronous Machine Eq Calculator</p>
<p>Given specified parameter set, will calculate
the internal voltage on the q-axis (Eq).</p>
<p>[ j\cdot X_q\cdot I_{t_{pu}}+j(X_d-X_q)\cdot I_{ad}\right] ]
where:</p>
<p>[ \angle{V_{t_{pu}}}-\cos^{-1}(PF))} ]
[ I_{t_{pu}}+j\cdot X_qI_{t_{pu}}\right) ]
[ -\cos^{-1}(PF)+\theta_q)\right|e^{j(\theta_q
-90°)} ]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Vt_pu</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Terminal voltage in per-unit-volts</dd>
<dt><strong><code>Itmag</code></strong> :&ensp;<code>
float</code></dt>
<dd>Terminal current magnitude in per-
unit-amps</dd>
<dt><strong><code>PF</code></strong> :&ensp;<code>
float</code></dt>
<dd>Machine Power Factor, (+)ive values denote
leading power factor, (-)ive values denote
lagging power factor</dd>
<dt><strong><code>Ra</code></strong> :&ensp;<code>
float</code></dt>
<dd>AC resistance in per-unit-ohms</dd>
<dt><strong><code>Xd</code></strong> :&ensp;<code>
float</code></dt>
<dd>D-axis reactance in per-unit-ohms</dd>
<dt><strong><code>Xq</code></strong> :&ensp;<code>
float</code></dt>
<dd>Q-axis reactance in per-unit-ohms</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Eq</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Internal Synchronous Machine Voltage
in per-unit-volts</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def synmach_Eq(Vt_pu,Itmag,PF,Ra,Xd,Xq):
    &#34;&#34;&#34;
    Synchronous Machine Eq Calculator
    
    Given specified parameter set, will calculate
    the internal voltage on the q-axis (Eq).
    
    .. math:: E_q=V_{t_{pu}}-\\left[R_a\\cdot I_{t_{pu}}+
       j\\cdot X_q\\cdot I_{t_{pu}}+j(X_d-X_q)\\cdot I_{ad}\\right]
    
    where:
    
    .. math:: I_{t_{pu}}=I_{t_{mag}}\\cdot e^{-j(
       \\angle{V_{t_{pu}}}-\\cos^{-1}(PF))}
    
    .. math:: \\theta_q=\\angle{V_{t_{pu}}-\\left(R_a
       I_{t_{pu}}+j\\cdot X_qI_{t_{pu}}\\right)
    
    .. math:: I_{ad}=\\left|I_{t_{pu}}\\cdot\\sin(
       -\\cos^{-1}(PF)+\\theta_q)\\right|e^{j(\\theta_q
       -90°)}
    
    Parameters
    ----------
    Vt_pu:      complex
                Terminal voltage in per-unit-volts
    Itmag:      float
                Terminal current magnitude in per-
                unit-amps
    PF:         float
                Machine Power Factor, (+)ive values denote
                leading power factor, (-)ive values denote
                lagging power factor
    Ra:         float
                AC resistance in per-unit-ohms
    Xd:         float
                D-axis reactance in per-unit-ohms
    Xq:         float
                Q-axis reactance in per-unit-ohms
    
    Returns
    -------
    Eq:         complex
                Internal Synchronous Machine Voltage
                in per-unit-volts
    &#34;&#34;&#34;
    # Calculate Required Terms
    phi = _np.arccos(PF)
    Itmag = abs(Itmag)
    It_pu = Itmag*_np.exp(-1j*(_np.angle(Vt_pu)+phi))
    th_q = _np.angle(Vt_pu - (Ra*It_pu+1j*Xq*It_pu))
    Iad = (abs(It_pu)*_np.sin(phi+th_q))*_np.exp(1j*(th_q-_np.pi/2))
    # Calculate Eq
    Eq = Vt_pu - (Ra*It_pu+1j*Xq*It_pu+1j*(Xd-Xq)*Iad)
    return(Eq)</code></pre>
</details>
</dd>
<dt id="electricpy.tcycle"><code class="name flex">
<span>def <span class="ident">tcycle</span></span>(<span>ncycles=1, freq=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Time of Electrical Cycles</p>
<p>Evaluates the time for a number of n
cycles given the system frequency.</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>ncycles</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Number (n) of cycles to evaluate, default=1</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System frequency in Hz, default=60</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>
float</code></dt>
<dd>Total time for <em>ncycles</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tcycle(ncycles=1,freq=60):
    &#34;&#34;&#34;
    Time of Electrical Cycles
    
    Evaluates the time for a number of n
    cycles given the system frequency.
    
    .. math:: t = \\frac{n_{cycles}}{freq}
    
    Parameters
    ----------
    ncycles:    float, optional    
                Number (n) of cycles to evaluate, default=1
    freq:       float, optional
                System frequency in Hz, default=60
    
    Returns
    -------
    t:          float
                Total time for *ncycles*
    &#34;&#34;&#34;
    # Condition Inputs
    ncycles = _np.asarray(ncycles)
    freq = _np.asarray(freq)
    # Evaluate the time for ncycles
    time = ncycles/freq
    # Return
    if len(time) == 1:
        return(time[0])
    else:
        return(time)</code></pre>
</details>
</dd>
<dt id="electricpy.tflatex"><code class="name flex">
<span>def <span class="ident">tflatex</span></span>(<span>sys, sysp=None, var='s', predollar=True, postdollar=True, double=False, tolerance=1e-08)</span>
</code></dt>
<dd>
<div class="desc"><p>Transfer Function LaTeX String Generator</p>
<p>LaTeX string generating function to create a transfer
function string in LaTeX. Particularly useful for
demonstrating systems in Interactive Python Notebooks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sys</code></strong> :&ensp;<code>
list</code></dt>
<dd>If provided in conjunction with optional
parameter <code>sysp</code>, the parameter <code>sys</code> will
act as the numerator set. Otherwise, can be
passed as a list containing two sublists,
the first being the numerator set, and the
second being the denominator set.</dd>
<dt><strong><code>sysp</code></strong> :&ensp;<code>
list</code>, optional</dt>
<dd>If provided, this input will act as the
denominator of the transfer function.</dd>
<dt><strong><code>var</code></strong> :&ensp;<code>
str</code>, optional</dt>
<dd>The variable that should be printed for each
term (i.e. 's' or 'j\omega'). default='s'</dd>
<dt><strong><code>predollar</code></strong> :&ensp;<code> bool</code>, optional</dt>
<dd>Control argument to enable/disable the dollar
sign before the string. default=True</dd>
<dt><strong><code>postdollar</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Control argument to enable/disable the dollar
sign after the string. default=True</dd>
<dt><strong><code>double</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to specify whether or not
LaTeX dollar signs should be double or single,
default=False</dd>
<dt><strong><code>tolerance</code></strong> :&ensp;<code> float</code>, optional</dt>
<dd>The floating point tolerance cutoff to evaluate
each term against. If the absolute value of the
particular term is greater than the tolerance,
the value will be printed, if not, it will not
be printed. default=1e-8</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>latex</code></strong> :&ensp;<code>
str</code></dt>
<dd>LaTeX string for the transfer function.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tflatex(sys,sysp=None,var=&#39;s&#39;,predollar=True,
            postdollar=True,double=False,tolerance=1e-8):
    &#34;&#34;&#34;
    Transfer Function LaTeX String Generator
    
    LaTeX string generating function to create a transfer
    function string in LaTeX. Particularly useful for
    demonstrating systems in Interactive Python Notebooks.
    
    Parameters
    ----------
    sys:        list
                If provided in conjunction with optional
                parameter `sysp`, the parameter `sys` will
                act as the numerator set. Otherwise, can be
                passed as a list containing two sublists,
                the first being the numerator set, and the
                second being the denominator set.
    sysp:       list, optional
                If provided, this input will act as the
                denominator of the transfer function.
    var:        str, optional
                The variable that should be printed for each
                term (i.e. &#39;s&#39; or &#39;j\\omega&#39;). default=&#39;s&#39;
    predollar:  bool, optional
                Control argument to enable/disable the dollar
                sign before the string. default=True
    postdollar: bool, optional
                Control argument to enable/disable the dollar
                sign after the string. default=True
    double:     bool, optional
                Control argument to specify whether or not
                LaTeX dollar signs should be double or single,
                default=False
    tolerance:  float, optional
                The floating point tolerance cutoff to evaluate
                each term against. If the absolute value of the
                particular term is greater than the tolerance,
                the value will be printed, if not, it will not
                be printed. default=1e-8
    
    Returns
    -------
    latex:      str
                LaTeX string for the transfer function.
    &#34;&#34;&#34;
    # Collect Numerator and Denominator Terms
    if isinstance(sysp, (list,tuple,_np.ndarray)):
        num = sys
        den = sysp
    else:
        num, den = sys
    # Generate String Function
    def genstring( val ):
        length = len(val)
        strg = &#39;&#39;
        for i,v in enumerate(val):
            # Add Each Term to String
            if abs(v) &gt; tolerance:
                # Add &#39;+&#39; Symbol After Each Term
                if i != 0:
                    strg += r&#39;+&#39;
                strg += str(v)
                # Determine Exponent
                xpnt = length-i-1
                if xpnt == 1:
                    strg += var
                elif xpnt == 0:
                    pass # Don&#39;t Do Anything
                else:
                    strg += var+r&#39;^{&#39;+str(xpnt)+r&#39;}&#39;
        return( strg )
    # Generate Total TF String
    latex = r&#39;\frac{&#39; + genstring( num ) + r&#39;}{&#39;
    latex += genstring( den ) + r&#39;}&#39;
    # Add Dollar Sign pre-post
    if double:
        dollar = r&#39;$$&#39;
    else:
        dollar = r&#39;$&#39;
    if predollar:
        latex = dollar + latex
    if postdollar:
        latex = latex + dollar
    return( latex )</code></pre>
</details>
</dd>
<dt id="electricpy.thermocouple"><code class="name flex">
<span>def <span class="ident">thermocouple</span></span>(<span>V, coupletype='K', fahrenheit=False, cjt=None, To=None, Vo=None, P1=None, P2=None, P3=None, P4=None, Q1=None, Q2=None, Q3=None, round=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Thermocouple Temperature Calculator</p>
<p>Utilizes polynomial formula to calculate the temperature being monitored
by a thermocouple. Allows for various thermocouple types (B,E,J,K,N,R,S,T)
and various cold-junction-temperatures.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>
float</code></dt>
<dd>Measured voltage (in Volts)</dd>
<dt><strong><code>coupletype</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Thermocouple Type, may be one of (B,E,J,K,N,R,S,T), default="K"</dd>
<dt><strong><code>fahrenheit</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Control to enable return value as Fahrenheit instead of Celsius,
default=False</dd>
<dt><strong><code>cjt</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Cold-Junction-Temperature</dd>
<dt><strong><code>To</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Temperature Constant used in Polynomial.</dd>
<dt><strong><code>Vo</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Voltage Constant used in Polynomial.</dd>
<dt><strong><code>P1</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Polynomial constant.</dd>
<dt><strong><code>P2</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Polynomial constant.</dd>
<dt><strong><code>P3</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Polynomial constant.</dd>
<dt><strong><code>P4</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Polynomial constant.</dd>
<dt><strong><code>Q1</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Polynomial constant.</dd>
<dt><strong><code>Q2</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Polynomial constant.</dd>
<dt><strong><code>Q3</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Polynomial constant.</dd>
<dt><strong><code>round</code></strong> :&ensp;<code>
int</code>, optional</dt>
<dd>Control input to specify how many decimal places the result
should be rounded to, default=1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code>
float</code></dt>
<dd>The temperature (by default in degrees C, but optionally in
degrees F) as computed by the function.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thermocouple(V,coupletype=&#34;K&#34;,fahrenheit=False,cjt=None,To=None,Vo=None,P1=None,
                 P2=None,P3=None,P4=None,Q1=None,Q2=None,Q3=None,round=1):
    &#34;&#34;&#34;
    Thermocouple Temperature Calculator
    
    Utilizes polynomial formula to calculate the temperature being monitored
    by a thermocouple. Allows for various thermocouple types (B,E,J,K,N,R,S,T)
    and various cold-junction-temperatures.
    
    Parameters
    ----------
    V:          float
                Measured voltage (in Volts)
    coupletype: string, optional
                Thermocouple Type, may be one of (B,E,J,K,N,R,S,T), default=&#34;K&#34;
    fahrenheit: bool, optional
                Control to enable return value as Fahrenheit instead of Celsius,
                default=False
    cjt:        float, optional
                Cold-Junction-Temperature
    To:         float, optional
                Temperature Constant used in Polynomial.
    Vo:         float, optional
                Voltage Constant used in Polynomial.
    P1:         float, optional
                Polynomial constant.
    P2:         float, optional
                Polynomial constant.
    P3:         float, optional
                Polynomial constant.
    P4:         float, optional
                Polynomial constant.
    Q1:         float, optional
                Polynomial constant.
    Q2:         float, optional
                Polynomial constant.
    Q3:         float, optional
                Polynomial constant.
    round:      int, optional
                Control input to specify how many decimal places the result
                should be rounded to, default=1.
    
    Returns
    -------
    T:          float
                The temperature (by default in degrees C, but optionally in
                degrees F) as computed by the function.
    &#34;&#34;&#34;
    # Condition Inputs
    coupletype = coupletype.upper()
    V = V/m # Scale volts to milivolts
    # Determine Cold-Junction-Voltage
    if cjt != None:
        Vcj = coldjunction(cjt,coupletype,To,Vo,P1,P2,P3,P4,Q1,Q2,round)
        V += Vcj/m
    # Define Constant Lookup System
    lookup = [&#34;B&#34;,&#34;E&#34;,&#34;J&#34;,&#34;K&#34;,&#34;N&#34;,&#34;R&#34;,&#34;S&#34;,&#34;T&#34;]
    if not (coupletype in lookup):
        raise ValueError(&#34;Invalid Thermocouple Type&#34;)
    # Define Voltage Ranges
    voltages = {&#34;J&#34; : [-8.095, 0,      21.840, 45.494, 57.953, 69.553],
                &#34;K&#34; : [-6.404, -3.554, 4.096,  16.397, 33.275, 69.553],
                &#34;B&#34; : [0.291,  2.431,  13.820, None,   None,   None],
                &#34;E&#34; : [-9.835, -5.237, 0.591,  24.964, 53.112, 76.373],
                &#34;N&#34; : [-4.313, 0,      20.613, 47.513, None,   None],
                &#34;R&#34; : [-0.226, 1.469,  7.461,  14.277, 21.101, None],
                &#34;S&#34; : [-0.236, 1.441,  6.913,  12.856, 18.693, None],
                &#34;T&#34; : [-6.18,  -4.648, 0,      9.288,  20.872, None]}
    # Determine Array Selection
    vset = voltages[coupletype]
    if V &lt; vset[0]*m:
        raise ValueError(&#34;Voltage Below Lower Bound&#34;)
    elif vset[0] &lt;= V &lt; vset[1]:
        select = 0
    elif vset[1] &lt;= V &lt; vset[2]:
        select = 1
    elif vset[2] &lt;= V &lt; vset[3]:
        select = 2
    elif vset[3] &lt;= V &lt; vset[4]:
        select = 3
    elif vset[4] &lt;= V &lt;= vset[5]:
        select = 4
    elif vset[5] &lt; V:
        raise ValueError(&#34;Voltage Above Upper Bound&#34;)
    else:
        raise ValueError(&#34;Internal Error!&#34;)
    # Define Dictionary of Arrays
    data = {&#34;J&#34; : [[-6.4936529E+01,2.5066947E+02,6.4950262E+02,9.2510550E+02,1.0511294E+03],
                   [-3.1169773E+00,1.3592329E+01,3.6040848E+01,5.3433832E+01,6.0956091E+01],
                   [2.2133797E+01,1.8014787E+01,1.6593395E+01,1.6243326E+01,1.7156001E+01],
                   [2.0476437E+00,-6.5218881E-02,7.3009590E-01,9.2793267E-01,-2.5931041E+00],
                   [-4.6867532E-01,-1.2179108E-02,2.4157343E-02,6.4644193E-03,-5.8339803E-02],
                   [-3.6673992E-02,2.0061707E-04,1.2787077E-03,2.0464414E-03,1.9954137E-02],
                   [1.1746348E-01,-3.9494552E-03,4.9172861E-02,5.2541788E-02,-1.5305581E-01],
                   [-2.0903413E-02,-7.3728206E-04,1.6813810E-03,1.3682959E-04,-2.9523967E-03],
                   [-2.1823704E-03,1.6679731E-05,7.6067922E-05,1.3454746E-04,1.1340164E-03]],
            &#34;K&#34; : [[-1.2147164E+02,-8.7935962E+00,3.1018976E+02,6.0572562E+02,1.0184705E+03],
                   [-4.1790858E+00,-3.4489914E-01,1.2631386E+01,2.5148718E+01,4.1993851E+01],
                   [3.6069513E+01,2.5678719E+01,2.4061949E+01,2.3539401E+01,2.5783239E+01],
                   [3.0722076E+01,-4.9887904E-01,4.0158622E+00,4.6547228E-02,-1.8363403E+00],
                   [7.7913860E+00,-4.4705222E-01,2.6853917E-01,1.3444400E-02,5.6176662E-02],
                   [5.2593991E-01,-4.4869203E-02,-9.7188544E-03,5.9236853E-04,1.8532400E-04],
                   [9.3939547E-01,2.3893439E-04,1.6995872E-01,8.3445513E-04,-7.4803355E-02],
                   [2.7791285E-01,-2.0397750E-02,1.1413069E-02,4.6121445E-04,2.3841860E-03],
                   [2.5163349E-02,-1.8424107E-03,-3.9275155E-04,2.5488122E-05,0.0]],
            &#34;B&#34; : [[5.0000000E+02,1.2461474E+03],
                   [1.2417900E+00,7.2701221E+00],
                   [1.9858097E+02,9.4321033E+01],
                   [2.4284248E+01,7.3899296E+00],
                   [-9.7271640E+01,-1.5880987E-01],
                   [-1.5701178E+01,1.2681877E-02],
                   [3.1009445E-01,1.0113834E-01],
                   [-5.0880251E-01,-1.6145962E-03],
                   [-1.6163342E-01,-4.1086314E-06]],
            &#34;E&#34; : [[-1.1721668E+02,-5.0000000E+01,2.5014600E+02,6.0139890E+02,8.0435911E+02],
                   [-5.9901698E+00,-2.7871777E+00,1.7191713E+01,4.5206167E+01,6.1359178E+01],
                   [2.3647275E+01,1.9022736E+01,1.3115522E+01,1.2399357E+01,1.2759508E+01],
                   [1.2807377E+01,-1.7042725E+00,1.1780364E+00,4.3399963E-01,-1.1116072E+00],
                   [2.0665069E+00,-3.5195189E-01,3.6422433E-02,9.1967085E-03,3.5332536E-02],
                   [8.6513472E-02,4.7766102E-03,3.9584261E-04,1.6901585E-04,3.3080380E-05],
                   [5.8995860E-01,-6.5379760E-02,9.3112756E-02,3.4424680E-02,-8.8196889E-02],
                   [1.0960713E-01,-2.1732833E-02,2.9804232E-03,6.9741215E-04,2.8497415E-03],
                   [6.1769588E-03,0.0,3.3263032E-05,1.2946992E-05,0.0]],
            &#34;N&#34; : [[-5.9610511E+01,3.1534505E+02,1.0340172E+03],
                   [-1.5000000E+00,9.8870997E+00,3.7565475E+01],
                   [4.2021322E+01,2.7988676E+01,2.6029492E+01],
                   [4.7244037E+00,1.5417343E+00,-6.0783095E-01],
                   [-6.1153213E+00,-1.4689457E-01,-9.7742562E-03],
                   [-9.9980337E-01,-6.8322712E-03,-3.3148813E-06],
                   [1.6385664E-01,6.2600036E-02,-2.5351881E-02],
                   [-1.4994026E-01,-5.1489572E-03,-3.8746827E-04],
                   [-3.0810372E-02,-2.8835863E-04,1.7088177E-06]],
            &#34;R&#34; : [[1.3054315E+02,5.4188181E+02,1.0382132E+03,1.5676133E+03],
                   [8.8333090E-01,4.9312886E+00,1.1014763E+01,1.8397910E+01],
                   [1.2557377E+02,9.0208190E+01,7.4669343E+01,7.1646299E+01],
                   [1.3900275E+02,6.1762254E+00,3.4090711E+00,-1.0866763E+00],
                   [3.3035469E+01,-1.2279323E+00,-1.4511205E-01,-2.0968371E+00],
                   [-8.5195924E-01,1.4873153E-02,6.3077387E-03,-7.6741168E-01],
                   [1.2232896E+00,8.7670455E-02,5.6880253E-02,-1.9712341E-02],
                   [3.5603023E-01,-1.2906694E-02,-2.0512736E-03,-2.9903595E-02],
                   [0.0,0.0,0.0,-1.0766878E-02]],
            &#34;S&#34; : [[1.3792630E+02,4.7673468E+02,9.7946589E+02,1.6010461E+03],
                   [9.3395024E-01,4.0037367E+00,9.3508283E+00,1.6789315E+01],
                   [1.2761836E+02,1.0174512E+02,8.7126730E+01,8.4315871E+01],
                   [1.1089050E+02,-8.9306371E+00,-2.3139202E+00,-1.0185043E+01],
                   [1.9898457E+01,-4.2942435E+00,-3.2682118E-02,-4.6283954E+00],
                   [9.6152996E-02,2.0453847E-01,4.6090022E-03,-1.0158749E+00],
                   [9.6545918E-01,-7.1227776E-02,-1.4299790E-02,-1.2877783E-01],
                   [2.0813850E-01,-4.4618306E-02,-1.2289882E-03,-5.5802216E-02],
                   [0.0,1.6822887E-03,0.0,-1.2146518E-02]],
            &#34;T&#34; : [[-1.9243000E+02,-6.0000000E+01,1.3500000E+02,3.0000000E+02],
                   [-5.4798963E+00,-2.1528350E+00,5.9588600E+00,1.4861780E+01],
                   [5.9572141E+01,3.0449332E+01,2.0325591E+01,1.7214707E+01],
                   [1.9675733E+00,-1.2946560E+00,3.3013079E+00,-9.3862713E-01],
                   [-7.8176011E+01,-3.0500735E+00,1.2638462E-01,-7.3509066E-02],
                   [-1.0963280E+01,-1.9226856E-01,-8.2883695E-04,2.9576140E-04],
                   [2.7498092E-01,6.9877863E-03,1.7595577E-01,-4.8095795E-02],
                   [-1.3768944E+00,-1.0596207E-01,7.9740521E-03,-4.7352054E-03],
                   [-4.5209805E-01,-1.0774995E-02,0.0,0.0]]}
    # Load Data Into Terms
    if To == None:
        To = data[coupletype][0][select]
    if Vo == None:
        Vo = data[coupletype][1][select]
    if P1 == None:
        P1 = data[coupletype][2][select]
    if P2 == None:
        P2 = data[coupletype][3][select]
    if P3 == None:
        P3 = data[coupletype][4][select]
    if P4 == None:
        P4 = data[coupletype][5][select]
    if Q1 == None:
        Q1 = data[coupletype][6][select]
    if Q2 == None:
        Q2 = data[coupletype][7][select]
    if Q3 == None:
        Q3 = data[coupletype][8][select]
    # Calculate Temperature in Degrees C
    num = (V-Vo)*(P1+(V-Vo)*(P2+(V-Vo)*(P3+P4*(V-Vo))))
    den = 1 + (V-Vo)*(Q1+(V-Vo)*(Q2+Q3*(V-Vo)))
    temp = To + num/den
    # Return Temperature
    if fahrenheit:
        temp = (temp*9/5)+32
    temp = _np.around(temp,round)
    return(temp)</code></pre>
</details>
</dd>
<dt id="electricpy.timedischarge"><code class="name flex">
<span>def <span class="ident">timedischarge</span></span>(<span>Vinit, Vmin, C, P, dt=0.001, RMS=True, Eremain=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Capacitor Discharge Time Formula</p>
<p>Returns the time to discharge a capacitor to a specified
voltage given set of inputs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Vinit</code></strong> :&ensp;<code>
float</code></dt>
<dd>Initial Voltage (in volts)</dd>
<dt><strong><code>Vmin</code></strong> :&ensp;<code>
float</code></dt>
<dd>Final Voltage (the minimum allowable voltage) (in volts)</dd>
<dt><strong><code>C</code></strong> :&ensp;<code>
float</code></dt>
<dd>Capacitance (in Farads)</dd>
<dt><strong><code>P</code></strong> :&ensp;<code>
float</code></dt>
<dd>Load Power being consumed (in Watts)</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Time step-size (in seconds) (defaults to 1e-3 | 1ms)</dd>
<dt><strong><code>RMS</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>if true converts RMS Vin to peak</dd>
<dt><strong><code>Eremain</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>if true: also returns the energy remaining in cap</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt>Returns time to discharge from Vinit to Vmin in seconds.</dt>
<dt><code>May also return remaining energy in capacitor if Eremain=True</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timedischarge(Vinit,Vmin,C,P,dt=1e-3,RMS=True,Eremain=False):
    &#34;&#34;&#34;
    Capacitor Discharge Time Formula
    
    Returns the time to discharge a capacitor to a specified
    voltage given set of inputs.
    
    Parameters
    ----------
    Vinit:      float
                Initial Voltage (in volts)
    Vmin:       float
                Final Voltage (the minimum allowable voltage) (in volts)
    C:          float
                Capacitance (in Farads)
    P:          float
                Load Power being consumed (in Watts)
    dt:         float, optional
                Time step-size (in seconds) (defaults to 1e-3 | 1ms)
    RMS:        bool, optional
                if true converts RMS Vin to peak
    Eremain:    bool, optional
                if true: also returns the energy remaining in cap
    
    Returns
    -------
    Returns time to discharge from Vinit to Vmin in seconds.
    May also return remaining energy in capacitor if Eremain=True
    &#34;&#34;&#34;
    t = 0 # start at time t=0
    if RMS:
        vo = Vinit*_np.sqrt(2) # convert RMS to peak
    else:
        vo = Vinit
    vc = loadedvcapdischarge(t,vo,C,P) # set initial cap voltage
    while(vc &gt;= Vmin):
        t = t+dt # increment the time
        vcp = vc # save previous voltage
        vc = loadedvcapdischarge(t,vo,C,P) # calc. new voltage
    if(Eremain):
        E = energy(C,vcp) # calc. energy
        return(t-dt,E)
    else:
        return(t-dt)</code></pre>
</details>
</dd>
<dt id="electricpy.transformertest"><code class="name flex">
<span>def <span class="ident">transformertest</span></span>(<span>Poc=False, Voc=False, Ioc=False, Psc=False, Vsc=False, Isc=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Transformer Rated Test Evaluator</p>
<p>This function will determine the non-ideal circuit components of
a transformer (Req and Xeq, or Rc and Xm) given the test-case
parameters for the open-circuit test and/or the closed-circuit
test. Requires one or both of two sets: { Poc, Voc, Ioc }, or
{ Psc, Vsc, Isc }.
All values given must be given as absolute value, not complex.
All values returned are given with respect to primary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Poc</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The open-circuit measured power (real power), default=None</dd>
<dt><strong><code>Voc</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The open-circuit measured voltage (measured on X),
default=None</dd>
<dt><strong><code>Ioc</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The open-circuit measured current (measured on primary),
default=None</dd>
<dt><strong><code>Psc</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The short-circuit measured power (real power), default=None</dd>
<dt><strong><code>Vsc</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The short-circuit measured voltage (measured on X),
default=None</dd>
<dt><strong><code>Isc</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The short-circuit measured current (measured on X),
default=None</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>{Req,Xeq,Rc,Xm}:
Given all optional args
{Rc, Xm}:
Given open-circuit parameters
{Req, Xeq}:
Given short-circuit parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transformertest(Poc=False,Voc=False,Ioc=False,Psc=False,Vsc=False,
               Isc=False):
    &#34;&#34;&#34;
    Transformer Rated Test Evaluator
    
    This function will determine the non-ideal circuit components of
    a transformer (Req and Xeq, or Rc and Xm) given the test-case
    parameters for the open-circuit test and/or the closed-circuit
    test. Requires one or both of two sets: { Poc, Voc, Ioc }, or
    { Psc, Vsc, Isc }.
    All values given must be given as absolute value, not complex.
    All values returned are given with respect to primary.
    
    Parameters
    ----------
    Poc:    float, optional
            The open-circuit measured power (real power), default=None
    Voc:    float, optional
            The open-circuit measured voltage (measured on X),
            default=None
    Ioc:    float, optional
            The open-circuit measured current (measured on primary),
            default=None
    Psc:    float, optional
            The short-circuit measured power (real power), default=None
    Vsc:    float, optional
            The short-circuit measured voltage (measured on X),
            default=None
    Isc:    float, optional
            The short-circuit measured current (measured on X),
            default=None
    
    Returns
    -------
    {Req,Xeq,Rc,Xm}:    Given all optional args
    {Rc, Xm}:           Given open-circuit parameters
    {Req, Xeq}:         Given short-circuit parameters
    &#34;&#34;&#34;
    SC = False
    OC = False
    # Given Open-Circuit Values
    if (Poc!=None) and (Voc!=None) and (Ioc!=None):
        PF = Poc/(Voc*Ioc)
        Y = _c.rect(Ioc/Voc,-_np.arccos(PF))
        Rc = 1/Y.real
        Xm = -1/Y.imag
        OC = True
    # Given Short-Circuit Values
    if (Psc!=None) and (Vsc!=None) and (Isc!=None):
        PF = Psc/(Vsc*Isc)
        Zeq = _c.rect(Vsc/Isc,_np.arccos(PF))
        Req = Zeq.real
        Xeq = Zeq.imag
        SC = True
    # Return All if Found
    if OC and SC:
        return(Req,Xeq,Rc,Xm)
    elif OC:
        return(Rc,Xm)
    elif SC:
        return(Req,Xeq)
    else:
        print(&#34;An Error Was Encountered.\n&#34;+
                &#34;Not enough arguments were provided.&#34;)</code></pre>
</details>
</dd>
<dt id="electricpy.transposez"><code class="name flex">
<span>def <span class="ident">transposez</span></span>(<span>Zeq, fabc=0.3333333333333333, fcab=0.3333333333333333, fbca=0.3333333333333333, linelen=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Transmission Matrix Equivalent Transposition Calculator</p>
<p>Given the impedance matrix and the percent of the line spent
in each transposition relation (ABC, CAB, and BCA).</p>
<p>[ f_{abc}Z_{eq}+f_{cab}R_p^{-1}\cdot Z_{eq}\cdot R_p+
f_{bca}Z_{eq}R_p\cdot Z_{eq}\cdot R_p^{-1} ]
where:</p>
<p>.. math:
R_p=\begin{bmatrix}\
0 &amp; 0 &amp; 1 \
1 &amp; 0 &amp; 0 \
0 &amp; 1 &amp; 0 \
\end{bmatrix}</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Zeq</code></strong> :&ensp;<code>
array_like</code></dt>
<dd>Per-Length (or total length) line impedance in ohms.</dd>
<dt><strong><code>fabc</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Percentage of line set with phase relation ABC,
default=1/3</dd>
<dt><strong><code>fcab</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Percentage of line set with phase relation CAB,
default=1/3</dd>
<dt><strong><code>fbca</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Percentage of line set with phase relation BCA,
default=1/3</dd>
<dt><strong><code>linelen</code></strong> :&ensp;<code>
Length</code> of <code>line (unitless)</code>, default=<code>1</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transposez(Zeq,fabc=1/3,fcab=1/3,fbca=1/3,linelen=1):
    &#34;&#34;&#34;
    Transmission Matrix Equivalent Transposition Calculator
    
    Given the impedance matrix and the percent of the line spent
    in each transposition relation (ABC, CAB, and BCA).
    
    .. math::
       f_{abc}Z_{eq}+f_{cab}R_p^{-1}\\cdot Z_{eq}\\cdot R_p+
       f_{bca}Z_{eq}R_p\\cdot Z_{eq}\\cdot R_p^{-1}
    
    where:
    
    .. math:
       R_p=\\begin{bmatrix}\\\\
       0 &amp; 0 &amp; 1 \\\\
       1 &amp; 0 &amp; 0 \\\\
       0 &amp; 1 &amp; 0 \\\\
       \\end{bmatrix}
    
    Parameters
    ----------
    Zeq:        array_like
                Per-Length (or total length) line impedance in ohms.
    fabc:       float, optional
                Percentage of line set with phase relation ABC,
                default=1/3
    fcab:       float, optional
                Percentage of line set with phase relation CAB,
                default=1/3
    fbca:       float, optional
                Percentage of line set with phase relation BCA,
                default=1/3
    linelen:    Length of line (unitless), default=1
    &#34;&#34;&#34;
    # Condition Input
    Zeq = _np.asarray(Zeq)
    # Define Rp Array
    Rp = _np.array([
        [0,0,1],
        [1,0,0],
        [0,1,0]
    ])
    # Define Inverse Rp Array
    _Rp = np.linalg.inv(Rp)
    Zeq = fabc*Zeq + fcab*(_Rp.dot(Zeq.dot(Rp))) + fbca*(Rp.dot(Zeq.dot(_Rp)))
    Zeq = Zeq * linelen
    return(Zeq)</code></pre>
</details>
</dd>
<dt id="electricpy.unbalance"><code class="name flex">
<span>def <span class="ident">unbalance</span></span>(<span>A, B, C, all=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Voltage/Current Unbalance Function</p>
<p>Performs a voltage/current unbalance calculation
to determine the maximum current/voltage
unbalance. Returns result as a decimal percentage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>A</code></strong> :&ensp;<code>
float</code></dt>
<dd>Phase-A value</dd>
<dt><strong><code>B</code></strong> :&ensp;<code>
float</code></dt>
<dd>Phase-B value</dd>
<dt><strong><code>C</code></strong> :&ensp;<code>
float</code></dt>
<dd>Phase-C value</dd>
<dt><strong><code>all</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to require function
to return all voltage/current unbalances.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>unbalance</code></strong> :&ensp;<code> float</code></dt>
<dd>The unbalance as a percentage of the
average. (i.e. 80% = 0.8)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unbalance(A,B,C,all=False):
    &#34;&#34;&#34;
    Voltage/Current Unbalance Function
    
    Performs a voltage/current unbalance calculation
    to determine the maximum current/voltage
    unbalance. Returns result as a decimal percentage.
    
    Parameters
    ----------
    A:          float
                Phase-A value
    B:          float
                Phase-B value
    C:          float
                Phase-C value
    all:        bool, optional
                Control argument to require function
                to return all voltage/current unbalances.
    
    Returns
    -------
    unbalance:  float
                The unbalance as a percentage of the
                average. (i.e. 80% = 0.8)
    &#34;&#34;&#34;
    # Condition Inputs
    A = abs(A)
    B = abs(B)
    C = abs(C)
    # Gather Average
    avg = (A + B + C)/3
    # Determine Variance
    dA = abs(A-avg)
    dB = abs(B-avg)
    dC = abs(C-avg)
    # Gather Maximum Variation
    mx = max(dA,dB,dC)
    # Calculate Maximum Variation
    unbalance = mx/avg
    # Return Results
    if all:
        return(dA/avg,dB/avg,dC/avg)
    else:
        return(unbalance)</code></pre>
</details>
</dd>
<dt id="electricpy.vcapcharge"><code class="name flex">
<span>def <span class="ident">vcapcharge</span></span>(<span>t, Vs, R, C)</span>
</code></dt>
<dd>
<div class="desc"><p>Charging Capacitor Voltage</p>
<p>Function to calculate the voltage of a
capacitor that is charging given the time.</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>
float</code></dt>
<dd>The time at which to calculate the voltage.</dd>
<dt><strong><code>Vs</code></strong> :&ensp;<code>
float</code></dt>
<dd>The charging voltage for the capacitor.</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>
float</code></dt>
<dd>The ohmic value of the resistor being used
to discharge.</dd>
<dt><strong><code>C</code></strong> :&ensp;<code>
float</code></dt>
<dd>Capacitive value (in Farads).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Vc</code></strong> :&ensp;<code>
float</code></dt>
<dd>The calculated voltage of the capacitor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vcapcharge(t,Vs,R,C):
    &#34;&#34;&#34;
    Charging Capacitor Voltage
    
    Function to calculate the voltage of a
    capacitor that is charging given the time.
    
    .. math:: V_c=V_s*(1-e^{\\frac{-t}{R*C}})
    
    Parameters
    ----------
    t:          float
                The time at which to calculate the voltage.
    Vs:         float
                The charging voltage for the capacitor.
    R:          float
                The ohmic value of the resistor being used
                to discharge.
    C:          float
                Capacitive value (in Farads).
    
    Returns
    -------
    Vc:         float
                The calculated voltage of the capacitor.
    &#34;&#34;&#34;
    Vc = Vs*(1-_np.exp(-t/(R*C)))
    return(Vc)</code></pre>
</details>
</dd>
<dt id="electricpy.vcapdischarge"><code class="name flex">
<span>def <span class="ident">vcapdischarge</span></span>(<span>t, Vs, R, C)</span>
</code></dt>
<dd>
<div class="desc"><p>Discharging Capacitor Function</p>
<p>Function to calculate the voltage of a
capacitor that is discharging given the time.</p>
<p>[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>
float</code></dt>
<dd>The time at which to calculate the voltage.</dd>
<dt><strong><code>Vs</code></strong> :&ensp;<code>
float</code></dt>
<dd>The starting voltage for the capacitor.</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>
float</code></dt>
<dd>The ohmic value of the resistor being used
to discharge.</dd>
<dt><strong><code>C</code></strong> :&ensp;<code>
float</code></dt>
<dd>Capacitive value (in Farads).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Vc</code></strong> :&ensp;<code>
float</code></dt>
<dd>The calculated voltage of the capacitor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vcapdischarge(t,Vs,R,C):
    &#34;&#34;&#34;
    Discharging Capacitor Function
    
    Function to calculate the voltage of a
    capacitor that is discharging given the time.
    
    .. math:: V_c=V_s*e^{\\frac{-t}{R*C}}
    
    Parameters
    ----------
    t:          float
                The time at which to calculate the voltage.
    Vs:         float
                The starting voltage for the capacitor.
    R:          float
                The ohmic value of the resistor being used
                to discharge.
    C:          float
                Capacitive value (in Farads).
    
    Returns
    -------
    Vc:         float
                The calculated voltage of the capacitor.
    &#34;&#34;&#34;
    Vc = Vs*(_np.exp(-t/(R*C)))
    return(Vc)</code></pre>
</details>
</dd>
<dt id="electricpy.vipf"><code class="name flex">
<span>def <span class="ident">vipf</span></span>(<span>V=None, I=None, PF=1, find='')</span>
</code></dt>
<dd>
<div class="desc"><p>Voltage / Current / Power Factor Solver</p>
<p>Given two of the three parameters, will solve for the
third; beit voltage, current, or power factor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>
complex</code></dt>
<dd>System voltage (in volts), default=None</dd>
<dt><strong><code>I</code></strong> :&ensp;<code>
complex</code></dt>
<dd>System current (in amps), default=None</dd>
<dt><strong><code>PF</code></strong> :&ensp;<code>
float</code></dt>
<dd>System power factor, (+)ive values denote
leading power factor, (-)ive values denote
lagging power factor; default=1</dd>
<dt><strong><code>find</code></strong> :&ensp;<code>
str</code>, optional</dt>
<dd>Control argument to specify which value
should be returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>
complex</code></dt>
<dd>System voltage (in volts), default=None</dd>
<dt><strong><code>I</code></strong> :&ensp;<code>
complex</code></dt>
<dd>System current (in amps), default=None</dd>
<dt><strong><code>PF</code></strong> :&ensp;<code>
float</code></dt>
<dd>System power factor, (+)ive values denote
leading power factor, (-)ive values denote
lagging poer factor; default=1</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vipf(V=None,I=None,PF=1,find=&#39;&#39;):
    &#34;&#34;&#34;
    Voltage / Current / Power Factor Solver
    
    Given two of the three parameters, will solve for the
    third; beit voltage, current, or power factor.
    
    Parameters
    ----------
    V:          complex
                System voltage (in volts), default=None
    I:          complex
                System current (in amps), default=None
    PF:         float
                System power factor, (+)ive values denote
                leading power factor, (-)ive values denote
                lagging power factor; default=1
    find:       str, optional
                Control argument to specify which value
                should be returned.
    
    Returns
    -------
    V:          complex
                System voltage (in volts), default=None
    I:          complex
                System current (in amps), default=None
    PF:         float
                System power factor, (+)ive values denote
                leading power factor, (-)ive values denote
                lagging poer factor; default=1
    &#34;&#34;&#34;
    # Test to find Voltage
    if isinstance(V,float) and isinstance(I,complex):
        phi = -_np.sign(PF)*_np.arccos(PF)
        V = V*_np.exp(-1j*phi)
    # Test to find Current
    elif isinstance(V,complex) and isinstance(I,float):
        phi = _np.sign(PF)*_np.arccos(PF)
        I = I*_np.exp(-1j*phi)
    # Test to find Power Factor
    elif all([V,I]):
        phi = _np.angle(V) - _np.angle(I)
        PF = _np.cos(phi)
    # Failed Mode
    else:
        raise ValueError(&#34;All values must be provided.&#34;)
    # Return
    find = find.upper()
    if find == &#39;V&#39;:
        return(V)
    elif find == &#39;I&#39;:
        return(I)
    elif find == &#39;PF&#39;:
        return(PF)
    else:
        return(V,I,PF)</code></pre>
</details>
</dd>
<dt id="electricpy.voltdiv"><code class="name flex">
<span>def <span class="ident">voltdiv</span></span>(<span>Vin, R1, R2, Rload=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Voltage Divider Function</p>
<p>This function is designed to calculate the output
voltage of a voltage divider given the input voltage,
the resistances (or impedances) and the load resistance
(or impedance) if present.</p>
<p>[
]
[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>Vin</code></strong> :&ensp;<code>
float</code></dt>
<dd>The Input Voltage, may be real or complex</dd>
<dt><strong><code>R1</code></strong> :&ensp;<code>
float</code></dt>
<dd>The top resistor of the divider (real or complex)</dd>
<dt><strong><code>R2</code></strong> :&ensp;<code>
float</code></dt>
<dd>The bottom resistor of the divider, the one which
the output voltage is measured across, may be
either real or complex</dd>
<dt><strong><code>Rload</code></strong> :&ensp;<code> float</code>, optional</dt>
<dd>The Load Resistor (or impedance), default=None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Vout</code></strong> :&ensp;<code>
float</code></dt>
<dd>The Output voltage as measured across R2 and/or Rload</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def voltdiv(Vin,R1,R2,Rload=None):
    &#34;&#34;&#34;
    Voltage Divider Function
    
    This function is designed to calculate the output
    voltage of a voltage divider given the input voltage,
    the resistances (or impedances) and the load resistance
    (or impedance) if present.
    
    .. math:: V_{out} = V_{in} * \\frac{R_2}{R_1+R+2}
    
    .. math:: V_{out}=V_{in}*\\frac{R_2||R_{load}}{R_1+(R_2||R_{load})}
    
    Parameters
    ----------
    Vin:    float
            The Input Voltage, may be real or complex
    R1:     float
            The top resistor of the divider (real or complex)
    R2:     float
            The bottom resistor of the divider, the one which
            the output voltage is measured across, may be
            either real or complex
    Rload:  float, optional
            The Load Resistor (or impedance), default=None
    
    Returns
    -------
    Vout:   float
            The Output voltage as measured across R2 and/or Rload
    &#34;&#34;&#34;
    # Determine whether Rload is given
    if(Rload==None): # No Load Given
        Vout = Vin * R2 / (R1+R2)
    else:   # Load was given
        Rp = parallelz((R2,Rload))
        Vout = Vin * Rp / (R1+Rp)
    return(Vout)</code></pre>
</details>
</dd>
<dt id="electricpy.vscdcbus"><code class="name flex">
<span>def <span class="ident">vscdcbus</span></span>(<span>VLL, Zs, P, Q=0, mmax=0.8, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Voltage Sourced Converter DC Bus Voltage Function</p>
<p>The purpose of this function is to calculate the
required DC-bus voltage for a Voltage-Sourced-
Converter (VSC) given the desired P/Q parameters
and the known source impedance (Vs) of the VSC.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>VLL</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Line-to-Line voltage on the line-side of
the source impedance.</dd>
<dt><strong><code>Zs</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The source impedance of the VSC</dd>
<dt><strong><code>P</code></strong> :&ensp;<code>
float</code></dt>
<dd>The desired real-power output</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The desired reactive-power output, default=0</dd>
<dt><strong><code>mmax</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The maximum of the m value for the converter
default=0.8</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code> bool</code>, optional</dt>
<dd>Control value to enable printing stages of
the calculation, default=False</dd>
</dl>
<h2 id="return">Return</h2>
<p>VDC:
float
The DC bus voltage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vscdcbus(VLL,Zs,P,Q=0,mmax=0.8,debug=False):
    &#34;&#34;&#34;
    Voltage Sourced Converter DC Bus Voltage Function
    
    The purpose of this function is to calculate the
    required DC-bus voltage for a Voltage-Sourced-
    Converter (VSC) given the desired P/Q parameters
    and the known source impedance (Vs) of the VSC.
    
    Parameters
    ----------
    VLL:    complex
            Line-to-Line voltage on the line-side of
            the source impedance.
    Zs:     complex
            The source impedance of the VSC
    P:      float
            The desired real-power output
    Q:      float, optional
            The desired reactive-power output, default=0
    mmax:   float, optional
            The maximum of the m value for the converter
            default=0.8
    debug:  bool, optional
            Control value to enable printing stages of
            the calculation, default=False
            
    Return
    ------
    VDC:    float
            The DC bus voltage.
    &#34;&#34;&#34;
    # Determine the Load Current
    Iload = _np.conj((P+1j*Q) / (VLL*_np.sqrt(3)))
    # Evaluate the Terminal Voltage
    Vtln = abs(VLL/_np.sqrt(3) + Iload*Zs)
    # Find the Peak Terminal Voltage
    Vtpk = _np.sqrt(2)*Vtln
    # Calculate the VDC value
    VDC = 2*Vtpk / mmax
    if debug:
        print(&#34;Iload&#34;, Iload)
        print(&#34;Vtln&#34;, Vtln)
        print(&#34;Vtpk&#34;, Vtpk)
        print(&#34;VDC&#34;, VDC)
    return(VDC)</code></pre>
</details>
</dd>
<dt id="electricpy.vscgains"><code class="name flex">
<span>def <span class="ident">vscgains</span></span>(<span>Rs, Ls, tau=0.005, freq=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Voltage Sourced Converter Gains Calculator</p>
<p>This function is designed to calculate the kp, ki,
and omega-not-L values for a Phase-Lock-Loop based VSC.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Rs</code></strong> :&ensp;<code>
float</code></dt>
<dd>The equiv-resistance (in ohms) of the VSC</dd>
<dt><strong><code>Ls</code></strong> :&ensp;<code>
float</code></dt>
<dd>The equiv-inductance (in Henrys) of the VSC</dd>
<dt><strong><code>tau</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The desired time-constant, default=0.005</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The system frequency (in Hz), default=60</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>kp</code></strong> :&ensp;<code>
float</code></dt>
<dd>The Kp-Gain Value</dd>
<dt><strong><code>ki</code></strong> :&ensp;<code>
float</code></dt>
<dd>The Ki-Gain Value</dd>
<dt><strong><code>w0L</code></strong> :&ensp;<code>
float</code></dt>
<dd>The omega-not-L gain value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vscgains(Rs,Ls,tau=0.005,freq=60):
    &#34;&#34;&#34;
    Voltage Sourced Converter Gains Calculator
    
    This function is designed to calculate the kp, ki,
    and omega-not-L values for a Phase-Lock-Loop based VSC.
    
    Parameters
    ----------
    Rs:     float
            The equiv-resistance (in ohms) of the VSC
    Ls:     float
            The equiv-inductance (in Henrys) of the VSC
    tau:    float, optional
            The desired time-constant, default=0.005
    freq:   float, optional
            The system frequency (in Hz), default=60
    
    Returns
    -------
    kp:     float
            The Kp-Gain Value
    ki:     float
            The Ki-Gain Value
    w0L:    float
            The omega-not-L gain value
    &#34;&#34;&#34;
    # Calculate kp
    kp = Ls / tau
    # Calculate ki
    ki = kp*Rs/Ls
    # Calculate w0L
    w0L = 2*_np.pi*freq*Ls
    return(kp,ki,w0L)</code></pre>
</details>
</dd>
<dt id="electricpy.watts"><code class="name flex">
<span>def <span class="ident">watts</span></span>(<span>hp)</span>
</code></dt>
<dd>
<div class="desc"><p>Horsepower to Watts Formula</p>
<p>Calculates the power (in watts) given the
horsepower.</p>
<p>[
]
Same as <code><a title="electricpy.watts" href="#electricpy.watts">hp_to_watts()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hp</code></strong> :&ensp;<code>
float</code></dt>
<dd>The horspower to compute.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>watts</code></strong> :&ensp;<code>
float</code></dt>
<dd>The power in watts.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hp_to_watts(hp):
    &#34;&#34;&#34;
    Horsepower to Watts Formula
    
    Calculates the power (in watts) given the
    horsepower.
    
    .. math:: P_{\\text{watts}}=P_{\\text{horsepower}}\\cdot745.699872
    
    Same as `watts`.
    
    Parameters
    ----------
    hp:         float
                The horspower to compute.
    
    Returns
    -------
    watts:      float
                The power in watts.
    &#34;&#34;&#34;
    return(hp * 745.699872)</code></pre>
</details>
</dd>
<dt id="electricpy.watts_to_hp"><code class="name flex">
<span>def <span class="ident">watts_to_hp</span></span>(<span>watts)</span>
</code></dt>
<dd>
<div class="desc"><p>Watts to Horsepower Function</p>
<p>Calculates the power (in horsepower) given
the power in watts.</p>
<p>[
]
Same as <code><a title="electricpy.horsepower" href="#electricpy.horsepower">watts_to_hp()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>watts</code></strong> :&ensp;<code>
float</code></dt>
<dd>The wattage to compute.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hp</code></strong> :&ensp;<code>
float</code></dt>
<dd>The power in horsepower.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watts_to_hp(watts):
    &#34;&#34;&#34;
    Watts to Horsepower Function
    
    Calculates the power (in horsepower) given
    the power in watts.
    
    .. math:: P_{\\text{horsepower}}=\\frac{P_{\\text{watts}}}{745.699872}
    
    Same as `horsepower`.
    
    Parameters
    ----------
    watts:      float
                The wattage to compute.
    
    Returns
    -------
    hp:         float
                The power in horsepower.
    &#34;&#34;&#34;
    return(watts / 745.699872)</code></pre>
</details>
</dd>
<dt id="electricpy.wrms"><code class="name flex">
<span>def <span class="ident">wrms</span></span>(<span>func, dw=0.1, NN=100, quad=False, plot=True, title='Power Density Spectrum', round=3)</span>
</code></dt>
<dd>
<div class="desc"><p>WRMS Function:</p>
<p>This function is designed to calculate the RMS
bandwidth (Wrms) using a numerical process.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>
function</code></dt>
<dd>The callable function to use for evaluation</dd>
<dt><strong><code>dw</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The delta-omega to be used, default=0.1</dd>
<dt><strong><code>NN</code></strong> :&ensp;<code>
int</code>, optional</dt>
<dd>The total number of points, default=100</dd>
<dt><strong><code>quad</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control value to enable use of integrals
default=False</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control to enable plotting, default=True</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>
string</code>, optional</dt>
<dd>Title displayed with plot,
default="Power Density Spectrum"</dd>
<dt><strong><code>round</code></strong> :&ensp;<code>
int</code>, optional</dt>
<dd>Control to round the Wrms on plot,
default=3</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>W</code></strong> :&ensp;<code>
float</code></dt>
<dd>Calculated RMS Bandwidth (rad/sec)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrms(func,dw=0.1,NN=100,quad=False,plot=True,
         title=&#34;Power Density Spectrum&#34;,round=3):
    &#34;&#34;&#34;
    WRMS Function:
    
    This function is designed to calculate the RMS
    bandwidth (Wrms) using a numerical process.
    
    Parameters
    ----------
    func:       function
                The callable function to use for evaluation
    dw:         float, optional
                The delta-omega to be used, default=0.1
    NN:         int, optional
                The total number of points, default=100
    quad:       bool, optional
                Control value to enable use of integrals
                default=False
    plot:       bool, optional
                Control to enable plotting, default=True
    title:      string, optional
                Title displayed with plot,
                default=&#34;Power Density Spectrum&#34;
    round:      int, optional
                Control to round the Wrms on plot,
                default=3
    
    Returns
    -------
    W:          float
                Calculated RMS Bandwidth (rad/sec)
    &#34;&#34;&#34;
    # Define omega
    omega = _np.linspace(0,(NN-1)*del_w,NN)
    # Initialize Fraction Terms
    Stot = Sw2 = 0
    # Power Density Spectrum
    Sxx = _np.array([])
    for n in range(NN):
        # Calculate Power Density Spectrum
        Sxx = _np.append(Sxx,func(omega[n]))
        Stot = Stot + Sxx[n]
        Sw2 = Sw2 + (omega[n]**2)*Sxx[n]
    if(quad):
        def intf(w):
            return(w**2*func(w))
        num = integrate(intf,0,_np.inf)[0]
        den = integrate(func,0,_np.inf)[0]
        # Calculate W
        W = _np.sqrt(num/den)
    else:
        # Calculate W
        W = _np.sqrt(Sw2/Stot)
    Wr = _np.around(W,round)
    # Plot Upon Request
    if(plot):
        _plt.plot(omega,Sxx)
        _plt.title(title)
        # Evaluate Text Location
        x = 0.65*max(omega)
        y = 0.80*max(Sxx)
        _plt.text(x,y,&#34;Wrms: &#34;+str(Wr))
        _plt.show()
    # Return Calculated RMS Bandwidth
    return(W)</code></pre>
</details>
</dd>
<dt id="electricpy.xfmphs"><code class="name flex">
<span>def <span class="ident">xfmphs</span></span>(<span>style='DY', shift=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple Transformer Phase-Shift Calculator</p>
<p>Use with transformer orientation to evaluate
the phase-shift across a transformer. For
example, find the phase shift for a Delta-Wye
transformer as seen from the delta side.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>style</code></strong> :&ensp;<code>{'DY','YD','DD','YY'}</code>, optional</dt>
<dd>String that denotes the transformer
orientation. default='DY'</dd>
<dt><strong><code>shift</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Transformer angle shift, default=30</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>phase</code></strong> :&ensp;<code>
complex</code></dt>
<dd>Phasor including the phase shift and
positive or negative characteristic.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; import electricpy as ep
&gt;&gt;&gt; # Find shift of Delta-Wye Transformer w/ 30° shift
&gt;&gt;&gt; shift = ep.xfmphs(style=&quot;DY&quot;,shift=30)
&gt;&gt;&gt; ep.cprint(shift)
1.0 ∠ 30.0°
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xfmphs(style=&#34;DY&#34;,shift=30):
    &#34;&#34;&#34;
    Simple Transformer Phase-Shift Calculator
    
    Use with transformer orientation to evaluate
    the phase-shift across a transformer. For
    example, find the phase shift for a Delta-Wye
    transformer as seen from the delta side.
    
    Parameters
    ----------
    style:      {&#39;DY&#39;,&#39;YD&#39;,&#39;DD&#39;,&#39;YY&#39;}, optional
                String that denotes the transformer
                orientation. default=&#39;DY&#39;
    shift:      float, optional
                Transformer angle shift, default=30
    
    Returns
    -------
    phase:      complex
                Phasor including the phase shift and
                positive or negative characteristic.
    
    Examples
    --------
    &gt;&gt;&gt; import electricpy as ep
    &gt;&gt;&gt; # Find shift of Delta-Wye Transformer w/ 30° shift
    &gt;&gt;&gt; shift = ep.xfmphs(style=&#34;DY&#34;,shift=30)
    &gt;&gt;&gt; ep.cprint(shift)
    1.0 ∠ 30.0°
    &#34;&#34;&#34;
    # Define Direction Dictionary
    orientation = {
        &#34;DY&#34; : 1,
        &#34;YD&#34; : -1,
        &#34;DD&#34; : 0,
        &#34;YY&#34; : 0,
    }
    # Find Direction
    v = orientation[style.upper()]
    # Calculate Shift
    phase = _np.exp(1j*_np.radians(v*abs(shift)))
    # Return
    return(phase)</code></pre>
</details>
</dd>
<dt id="electricpy.zdecompose"><code class="name flex">
<span>def <span class="ident">zdecompose</span></span>(<span>Zmag, XoR)</span>
</code></dt>
<dd>
<div class="desc"><p>Impedance Decomposition Function</p>
<p>A function to decompose the impedance magnitude into its
corresponding resistance and reactance using the X/R ratio.</p>
<p>It is possible to "neglect" R, or make it a very small number;
this is done by setting the X/R ratio to a very large number
(X being much larger than R).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Zmag</code></strong> :&ensp;<code>
float</code></dt>
<dd>The magnitude of the impedance.</dd>
<dt><strong><code>XoR</code></strong> :&ensp;<code>
float</code></dt>
<dd>The X/R ratio (reactance over impedance).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>
float</code></dt>
<dd>The resistance (in ohms)</dd>
<dt><strong><code>X</code></strong> :&ensp;<code>
float</code></dt>
<dd>The reactance (in ohms)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zdecompose(Zmag,XoR):
    &#34;&#34;&#34;
    Impedance Decomposition Function
    
    A function to decompose the impedance magnitude into its
    corresponding resistance and reactance using the X/R ratio.
    
    It is possible to &#34;neglect&#34; R, or make it a very small number;
    this is done by setting the X/R ratio to a very large number
    (X being much larger than R).
    
    Parameters
    ----------
    Zmag:       float
                The magnitude of the impedance.
    XoR:        float
                The X/R ratio (reactance over impedance).
    
    Returns
    -------
    R:          float
                The resistance (in ohms)
    X:          float
                The reactance (in ohms)
    &#34;&#34;&#34;
    # Evaluate Resistance
    R = Zmag/_np.sqrt(XoR**2+1)
    # Evaluate Reactance
    X = R * XoR
    # Return
    return(R,X)</code></pre>
</details>
</dd>
<dt id="electricpy.zperlength"><code class="name flex">
<span>def <span class="ident">zperlength</span></span>(<span>Rd=None, Rself=None, Rac=None, Rgwac=None, De=None, rho='AVG', Ds=None, Dsgw=None, dia_gw=None, Dab=None, Dbc=None, Dca=None, Dagw=None, Dbgw=None, Dcgw=None, resolve=True, freq=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Transmission Line Impedance (RL) Calculator</p>
<p>Simple impedance matrix generator to provide the full
impedance per length matrix.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Rd</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Resistance Rd term in ohms, will be generated
automatically if set to None, default=None</dd>
<dt><strong><code>Rself</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Self Resistance term in ohms.</dd>
<dt><strong><code>Rac</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>AC resistance in ohms.</dd>
<dt><strong><code>Rgwac</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Ground-Wire AC resistance in ohms.</dd>
<dt><strong><code>De</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>De term, in feet, if None provided, and <code>rho</code>
parameter is specified, will interpretively be
calculated.</dd>
<dt><strong><code>rho</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Earth resistivity in ohm-meters. default="AVG"</dd>
<dt><strong><code>Ds</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Distance (self) for each phase conductor in feet,
commonly known as GMD.</dd>
<dt><strong><code>Dsgw</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Distance (self) for the ground wire conductor in
feet, commonly known as GMD.</dd>
<dt><strong><code>dia_gw</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Ground-Wire diameter in feet, may be used to
calculate an approximate Dsgw if no Dsgw is provided.</dd>
<dt><strong><code>Dab</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Distance between phases A and B, in feet.</dd>
<dt><strong><code>Dbc</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Distance between phases B and C, in feet.</dd>
<dt><strong><code>Dca</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Distance between phases C and A, in feet.</dd>
<dt><strong><code>Dagw</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Distance between phase A and ground conductor, in feet.</dd>
<dt><strong><code>Dbgw</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Distance between phase B and ground conductor, in feet.</dd>
<dt><strong><code>Dcgw</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>Distance between phase C and ground conductor, in feet.</dd>
<dt><strong><code>resolve</code></strong> :&ensp;<code>
bool</code>, optional</dt>
<dd>Control argument to specify whether the resultant
ground-wire inclusive per-length impedance matrix
should be reduced to a 3x3 equivalent matrix.
default=True</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>System frequency in Hertz.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zperlength(Rd=None,Rself=None,Rac=None,Rgwac=None,De=None,
               rho=&#34;AVG&#34;,Ds=None,Dsgw=None,dia_gw=None,Dab=None,
               Dbc=None,Dca=None,Dagw=None,Dbgw=None,Dcgw=None,
               resolve=True,freq=60):
    &#34;&#34;&#34;
    Transmission Line Impedance (RL) Calculator
    
    Simple impedance matrix generator to provide the full
    impedance per length matrix.
    
    Parameters
    ----------
    Rd:         float, optional
                Resistance Rd term in ohms, will be generated
                automatically if set to None, default=None
    Rself:      float, optional
                Self Resistance term in ohms.
    Rac:        float, optional
                AC resistance in ohms.
    Rgwac:      float, optional
                Ground-Wire AC resistance in ohms.
    De:         float, optional
                De term, in feet, if None provided, and `rho`
                parameter is specified, will interpretively be
                calculated.
    rho:        float, optional
                Earth resistivity in ohm-meters. default=&#34;AVG&#34;
    Ds:         float, optional
                Distance (self) for each phase conductor in feet,
                commonly known as GMD.
    Dsgw:       float, optional
                Distance (self) for the ground wire conductor in
                feet, commonly known as GMD.
    dia_gw:     float, optional
                Ground-Wire diameter in feet, may be used to
                calculate an approximate Dsgw if no Dsgw is provided.
    Dab:        float, optional
                Distance between phases A and B, in feet.
    Dbc:        float, optional
                Distance between phases B and C, in feet.
    Dca:        float, optional
                Distance between phases C and A, in feet.
    Dagw:       float, optional
                Distance between phase A and ground conductor, in feet.
    Dbgw:       float, optional
                Distance between phase B and ground conductor, in feet.
    Dcgw:       float, optional
                Distance between phase C and ground conductor, in feet.
    resolve:    bool, optional
                Control argument to specify whether the resultant
                ground-wire inclusive per-length impedance matrix
                should be reduced to a 3x3 equivalent matrix.
                default=True
    freq:       float, optional
                System frequency in Hertz.
    &#34;&#34;&#34;
    # Start with Empty Arrays
    Rperlen = 0
    Lperlen = 0
    # Generate Rd
    if Rd==None:
        Rd = freq * carson_r
    # Generate Dsgw if Not Provided
    if Dsgw==None and dia_gw!=None:
        Dsgw = _np.exp(-1/4) * dia_gw/2
    # Generate Real Part
    if Rd &gt; 0:
        # Generate Rself if not Provided
        if Rself==None:
            # Validate Inputs
            if not all((Rd,Rac)):
                raise ValueError(&#34;Too few arguments&#34;)
            Rself = Rac + Rd
        # Generate RperLength Matrix
        Rperlen = _np.array([
            [Rself,Rd,Rd],
            [Rd,Rself,Rd],
            [Rd,Rd,Rself]
            ])
        # Add GW effects If Necessary
        if all((Rgwac,Dsgw,Dagw,Dbgw,Dcgw)):
            # Calculate Rselfgw
            Rselfgw = Rgwac + Rd
            # Append Right-Most Column
            Rperlen = _np.append(Rperlen,
                [[Rd],[Rd],[Rd]],axis=1)
            # Append New Row
            Rperlen = _np.append(Rperlen,
                [[Rd,Rd,Rd,Rselfgw]],axis=0)
    # Generate Imaginary Part
    if any((De,Ds,rho)):
        # Validate Inputs
        if not all((Dab,Dbc,Dca)):
            raise ValueError(&#34;Distance Terms [Dab,Dbc,Dca] Required&#34;)
        if Ds==None:
            raise ValueError(&#34;Distance Self (Ds) Required&#34;)
        # De must be generated
        if De==None:
            if rho==None:
                raise ValueError(&#34;Too few arguments&#34;)
            De = de_calc(rho,freq)
        # Generate LperLength Matrix
        Lperlen = _np.array([
            [_np.log(De/Ds),_np.log(De/Dab),_np.log(De/Dca)],
            [_np.log(De/Dab),_np.log(De/Ds),_np.log(De/Dbc)],
            [_np.log(De/Dca),_np.log(De/Dbc),_np.log(De/Ds)]
            ])
        # Add GW effects If Necessary
        if all((Rgwac,Dsgw,Dagw,Dbgw,Dcgw)):
            # Append Right-Most Column
            Lperlen = _np.append(Lperlen,
                [[_np.log(De/Dagw)],[_np.log(De/Dbgw)],[_np.log(De/Dcgw)]],
                axis=1)
            # Append New Row
            Lperlen = _np.append(Lperlen,
                [[_np.log(De/Dagw),_np.log(De/Dbgw),
                _np.log(De/Dcgw),_np.log(De/Dsgw)]],axis=0)
        Lperlen = Lperlen * (1j*u0*freq)
    # Add Real and Imaginary Parts
    Zperlen = Rperlen + Lperlen
    # Resolve to 3x3 Matrix if Needed
    if resolve and all((Rgwac,Dsgw,Dagw,Dbgw,Dcgw)):
        # Perform Slicing to Retrieve Useful Arrays
        Za = Zperlen[:3,:3]
        Zb = Zperlen[:3,3:4]
        Zc = Zperlen[3:4,:3]
        Zd = Zperlen[3:4,3:4]
        # Calculate New (3x3) Equivalent Zperlen
        Zperlen = Za - _np.dot(Zb,_np.dot(_np.linalg.inv(Zd),Zc))
    return(Zperlen)</code></pre>
</details>
</dd>
<dt id="electricpy.zpu"><code class="name flex">
<span>def <span class="ident">zpu</span></span>(<span>S, VLL=None, VLN=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Per-Unit Impedance Evaluator</p>
<p>Evaluates the per-unit impedance value given the per-unit
power and voltage bases.</p>
<p>[
]
[
]
Parameters</p>
<hr>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>
float</code></dt>
<dd>The per-unit power base.</dd>
<dt><strong><code>VLL</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Line-to-Line Voltage; default=None</dd>
<dt><strong><code>VLN</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Line-to-Neutral Voltage; default=None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Zbase</code></strong> :&ensp;<code>
float</code></dt>
<dd>The per-unit impedance base.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zpu(S,VLL=None,VLN=None):
    &#34;&#34;&#34;
    Per-Unit Impedance Evaluator
    
    Evaluates the per-unit impedance value given the per-unit
    power and voltage bases.
    
    .. math:: Z_{pu}=\\frac{V_{LL}^2}{S}
    
    .. math:: Z_{pu}=\\frac{(\\sqrt{3}*V_{LN})^2}{S}
    
    Parameters
    ----------
    S:          float
                The per-unit power base.
    VLL:        float, optional
                The Line-to-Line Voltage; default=None
    VLN:        float, optional
                The Line-to-Neutral Voltage; default=None
    
    Returns
    -------
    Zbase:      float
                The per-unit impedance base.
    &#34;&#34;&#34;
    if(VLL==None and VLN==None):
        raise ValueError(&#34;ERROR: One voltage must be provided.&#34;)
    if VLL!=None:
        return(VLL**2/S)
    else:
        return((_np.sqrt(3)*VLN)**2/S)</code></pre>
</details>
</dd>
<dt id="electricpy.zrecompose"><code class="name flex">
<span>def <span class="ident">zrecompose</span></span>(<span>z_pu, S3phs, VLL=None, VLN=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Impedance from Per-Unit System Evaluator</p>
<p>Function to reverse per-unit conversion and return the ohmic value
of an impedance given its per-unit parameters of R and X (as Z).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>z_pu</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The per-unit, complex value corresponding to the
impedance</dd>
<dt><strong><code>S3phs</code></strong> :&ensp;<code>
float</code></dt>
<dd>The total three-phase power rating of the system.</dd>
<dt><strong><code>VLL</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Line-to-Line Voltage; default=None</dd>
<dt><strong><code>VLN</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The Line-to-Neutral Voltage; default=None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>z</code></strong> :&ensp;<code>
complex</code></dt>
<dd>The ohmic impedance evaluated from the per-unit base.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zrecompose(z_pu,S3phs,VLL=None,VLN=None):
    &#34;&#34;&#34;
    Impedance from Per-Unit System Evaluator
    
    Function to reverse per-unit conversion and return the ohmic value
    of an impedance given its per-unit parameters of R and X (as Z).
    
    Parameters
    ----------
    z_pu:       complex
                The per-unit, complex value corresponding to the
                impedance
    S3phs:      float
                The total three-phase power rating of the system.
    VLL:        float, optional
                The Line-to-Line Voltage; default=None
    VLN:        float, optional
                The Line-to-Neutral Voltage; default=None
    
    Returns
    -------
    z:          complex
                The ohmic impedance evaluated from the per-unit base.
    &#34;&#34;&#34;
    # Evaluate the per-unit impedance
    zbase = zpu(S3phs,VLL,VLN)
    # Evaluate the impedance
    z = z_pu * zbase
    return(z)</code></pre>
</details>
</dd>
<dt id="electricpy.zsource"><code class="name flex">
<span>def <span class="ident">zsource</span></span>(<span>S, V, XoR, Sbase=None, Vbase=None, perunit=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Source Impedance Calculator</p>
<p>Used to calculate the source impedance given the apparent power
magnitude and the X/R ratio.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>
float</code></dt>
<dd>The (rated) apparent power magnitude of the source.
This may also be refferred to as the "Short-Circuit MVA"</dd>
<dt><strong><code>V</code></strong> :&ensp;<code>
float</code></dt>
<dd>The (rated) voltage of the source terminals, not
specifically identified as either Line-to-Line or Line-to-
Neutral.</dd>
<dt><strong><code>XoR</code></strong> :&ensp;<code>
float</code></dt>
<dd>The X/R ratio rated for the source, may optionally be a list
of floats to accomidate sequence impedances or otherwise.</dd>
<dt><strong><code>Sbase</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The per-unit base for the apparent power. If set to
None, will automatically force Sbase to equal S.
If set to True will treat S as the per-unit value.</dd>
<dt><strong><code>Vbase</code></strong> :&ensp;<code>
float</code>, optional</dt>
<dd>The per-unit base for the terminal voltage. If set to
None, will automaticlaly force Vbase to equal V. If
set to True, will treat V as the per-unit value.</dd>
<dt><strong><code>perunit</code></strong> :&ensp;<code>
boolean</code>, optional</dt>
<dd>Control value to enable the return of output in per-
unit base. default=True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Zsource_pu</code></strong> :&ensp;<code>complex</code></dt>
<dd>The per-unit evaluation of the source impedance.
Will be returned in ohmic (not per-unit) value if
<em>perunit</em> argument is specified as False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zsource(S,V,XoR,Sbase=None,Vbase=None,perunit=True):
    &#34;&#34;&#34;
    Source Impedance Calculator
    
    Used to calculate the source impedance given the apparent power
    magnitude and the X/R ratio.
    
    Parameters
    ----------
    S:          float
                The (rated) apparent power magnitude of the source.
                This may also be refferred to as the &#34;Short-Circuit MVA&#34;
    V:          float
                The (rated) voltage of the source terminals, not
                specifically identified as either Line-to-Line or Line-to-
                Neutral.
    XoR:        float
                The X/R ratio rated for the source, may optionally be a list
                of floats to accomidate sequence impedances or otherwise.
    Sbase:      float, optional
                The per-unit base for the apparent power. If set to
                None, will automatically force Sbase to equal S.
                If set to True will treat S as the per-unit value.
    Vbase:      float, optional
                The per-unit base for the terminal voltage. If set to
                None, will automaticlaly force Vbase to equal V. If
                set to True, will treat V as the per-unit value.
    perunit:    boolean, optional
                Control value to enable the return of output in per-
                unit base. default=True
    
    Returns
    -------
    Zsource_pu: complex
                The per-unit evaluation of the source impedance.
                Will be returned in ohmic (not per-unit) value if
                *perunit* argument is specified as False.
    &#34;&#34;&#34;
    # Force Sbase and Vbase if needed
    if Vbase == None:
        Vbase = V
    if Sbase == None:
        Sbase = S
    # Prevent scaling if per-unit already applied
    if Vbase == True:
        Vbase = 1
    if Sbase == True:
        Sbase = 1
    # Set to per-unit
    Spu = S/Sbase
    Vpu = V/Vbase
    # Evaluate Zsource Magnitude
    Zsource_pu = Vpu**2/Spu
    # Evaluate the angle
    nu = _np.degrees(_np.arctan(XoR))
    # Conditionally Evaluate Phasor Impedance
    if isinstance(nu, (list,_np.ndarray)):
        Zsource_pu = []
        for angle in nu:
            Zsource_pu.append(phasor(Zsource_pu, angle))
    else:
        Zsource_pu = phasor(Zsource_pu, nu)
    if not perunit:
        Zsource = Zsource_pu * Vbase**2/Sbase
        return(Zsource)
    return(Zsource_pu)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#electricpypy">electricpy.py</a></li>
<li><a href="#included-constants">Included Constants</a></li>
<li><a href="#symmetrical-components-matricies">Symmetrical Components Matricies</a></li>
<li><a href="#included-functions">Included Functions</a></li>
<li><a href="#additional-available-sub-modules">Additional Available Sub-Modules</a></li>
<li><a href="#functions-available-in-electricpyfaultpy">Functions Available in electricpy.fault.py</a></li>
<li><a href="#functions-available-in-electricpybodepy">Functions Available in electricpy.bode.py</a></li>
<li><a href="#functions-available-in-electricpysimpy">Functions Available in electricpy.sim.py</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="electricpy.bode" href="bode.html">electricpy.bode</a></code></li>
<li><code><a title="electricpy.constants" href="constants.html">electricpy.constants</a></code></li>
<li><code><a title="electricpy.fault" href="fault.html">electricpy.fault</a></code></li>
<li><code><a title="electricpy.sim" href="sim.html">electricpy.sim</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="electricpy.abc_to_seq" href="#electricpy.abc_to_seq">abc_to_seq</a></code></li>
<li><code><a title="electricpy.acpiv" href="#electricpy.acpiv">acpiv</a></code></li>
<li><code><a title="electricpy.btu" href="#electricpy.btu">btu</a></code></li>
<li><code><a title="electricpy.btu_to_kwh" href="#electricpy.btu_to_kwh">btu_to_kwh</a></code></li>
<li><code><a title="electricpy.capbacktoback" href="#electricpy.capbacktoback">capbacktoback</a></code></li>
<li><code><a title="electricpy.capenergy" href="#electricpy.capenergy">capenergy</a></code></li>
<li><code><a title="electricpy.captransfer" href="#electricpy.captransfer">captransfer</a></code></li>
<li><code><a title="electricpy.characterz" href="#electricpy.characterz">characterz</a></code></li>
<li><code><a title="electricpy.clatex" href="#electricpy.clatex">clatex</a></code></li>
<li><code><a title="electricpy.coldjunction" href="#electricpy.coldjunction">coldjunction</a></code></li>
<li><code><a title="electricpy.compose" href="#electricpy.compose">compose</a></code></li>
<li><code><a title="electricpy.convbar" href="#electricpy.convbar">convbar</a></code></li>
<li><code><a title="electricpy.convolve" href="#electricpy.convolve">convolve</a></code></li>
<li><code><a title="electricpy.cosfilt" href="#electricpy.cosfilt">cosfilt</a></code></li>
<li><code><a title="electricpy.cprint" href="#electricpy.cprint">cprint</a></code></li>
<li><code><a title="electricpy.crcremainder" href="#electricpy.crcremainder">crcremainder</a></code></li>
<li><code><a title="electricpy.crcsender" href="#electricpy.crcsender">crcsender</a></code></li>
<li><code><a title="electricpy.curdiv" href="#electricpy.curdiv">curdiv</a></code></li>
<li><code><a title="electricpy.de_calc" href="#electricpy.de_calc">de_calc</a></code></li>
<li><code><a title="electricpy.dynetz" href="#electricpy.dynetz">dynetz</a></code></li>
<li><code><a title="electricpy.farads" href="#electricpy.farads">farads</a></code></li>
<li><code><a title="electricpy.fftplot" href="#electricpy.fftplot">fftplot</a></code></li>
<li><code><a title="electricpy.fftsumplot" href="#electricpy.fftsumplot">fftsumplot</a></code></li>
<li><code><a title="electricpy.funcfft" href="#electricpy.funcfft">funcfft</a></code></li>
<li><code><a title="electricpy.funcrms" href="#electricpy.funcrms">funcrms</a></code></li>
<li><code><a title="electricpy.gausdist" href="#electricpy.gausdist">gausdist</a></code></li>
<li><code><a title="electricpy.gaussian" href="#electricpy.gaussian">gaussian</a></code></li>
<li><code><a title="electricpy.geninternalv" href="#electricpy.geninternalv">geninternalv</a></code></li>
<li><code><a title="electricpy.gmd" href="#electricpy.gmd">gmd</a></code></li>
<li><code><a title="electricpy.harmonics" href="#electricpy.harmonics">harmonics</a></code></li>
<li><code><a title="electricpy.hartleydata" href="#electricpy.hartleydata">hartleydata</a></code></li>
<li><code><a title="electricpy.hertz" href="#electricpy.hertz">hertz</a></code></li>
<li><code><a title="electricpy.horsepower" href="#electricpy.horsepower">horsepower</a></code></li>
<li><code><a title="electricpy.hp_to_watts" href="#electricpy.hp_to_watts">hp_to_watts</a></code></li>
<li><code><a title="electricpy.hz_to_rad" href="#electricpy.hz_to_rad">hz_to_rad</a></code></li>
<li><code><a title="electricpy.hz_to_rpm" href="#electricpy.hz_to_rpm">hz_to_rpm</a></code></li>
<li><code><a title="electricpy.imfoc_control" href="#electricpy.imfoc_control">imfoc_control</a></code></li>
<li><code><a title="electricpy.indmachfocratings" href="#electricpy.indmachfocratings">indmachfocratings</a></code></li>
<li><code><a title="electricpy.indmachiar" href="#electricpy.indmachiar">indmachiar</a></code></li>
<li><code><a title="electricpy.indmachpem" href="#electricpy.indmachpem">indmachpem</a></code></li>
<li><code><a title="electricpy.indmachpkslip" href="#electricpy.indmachpkslip">indmachpkslip</a></code></li>
<li><code><a title="electricpy.indmachpktorq" href="#electricpy.indmachpktorq">indmachpktorq</a></code></li>
<li><code><a title="electricpy.indmachstarttorq" href="#electricpy.indmachstarttorq">indmachstarttorq</a></code></li>
<li><code><a title="electricpy.indmachtem" href="#electricpy.indmachtem">indmachtem</a></code></li>
<li><code><a title="electricpy.indmachvth" href="#electricpy.indmachvth">indmachvth</a></code></li>
<li><code><a title="electricpy.indmachzth" href="#electricpy.indmachzth">indmachzth</a></code></li>
<li><code><a title="electricpy.inductorcharge" href="#electricpy.inductorcharge">inductorcharge</a></code></li>
<li><code><a title="electricpy.inductordischarge" href="#electricpy.inductordischarge">inductordischarge</a></code></li>
<li><code><a title="electricpy.inductorenergy" href="#electricpy.inductorenergy">inductorenergy</a></code></li>
<li><code><a title="electricpy.instpower" href="#electricpy.instpower">instpower</a></code></li>
<li><code><a title="electricpy.ipu" href="#electricpy.ipu">ipu</a></code></li>
<li><code><a title="electricpy.iscrl" href="#electricpy.iscrl">iscrl</a></code></li>
<li><code><a title="electricpy.kwh" href="#electricpy.kwh">kwh</a></code></li>
<li><code><a title="electricpy.kwh_to_btu" href="#electricpy.kwh_to_btu">kwh_to_btu</a></code></li>
<li><code><a title="electricpy.loadedvcapdischarge" href="#electricpy.loadedvcapdischarge">loadedvcapdischarge</a></code></li>
<li><code><a title="electricpy.machslip" href="#electricpy.machslip">machslip</a></code></li>
<li><code><a title="electricpy.motorstartcap" href="#electricpy.motorstartcap">motorstartcap</a></code></li>
<li><code><a title="electricpy.natfreq" href="#electricpy.natfreq">natfreq</a></code></li>
<li><code><a title="electricpy.nlinpf" href="#electricpy.nlinpf">nlinpf</a></code></li>
<li><code><a title="electricpy.parallelz" href="#electricpy.parallelz">parallelz</a></code></li>
<li><code><a title="electricpy.peak" href="#electricpy.peak">peak</a></code></li>
<li><code><a title="electricpy.pfcorrection" href="#electricpy.pfcorrection">pfcorrection</a></code></li>
<li><code><a title="electricpy.phase" href="#electricpy.phase">phase</a></code></li>
<li><code><a title="electricpy.phaseline" href="#electricpy.phaseline">phaseline</a></code></li>
<li><code><a title="electricpy.phasor" href="#electricpy.phasor">phasor</a></code></li>
<li><code><a title="electricpy.phasordata" href="#electricpy.phasordata">phasordata</a></code></li>
<li><code><a title="electricpy.phasorlist" href="#electricpy.phasorlist">phasorlist</a></code></li>
<li><code><a title="electricpy.phasorplot" href="#electricpy.phasorplot">phasorplot</a></code></li>
<li><code><a title="electricpy.phasorz" href="#electricpy.phasorz">phasorz</a></code></li>
<li><code><a title="electricpy.phs" href="#electricpy.phs">phs</a></code></li>
<li><code><a title="electricpy.phs3valpha" href="#electricpy.phs3valpha">phs3valpha</a></code></li>
<li><code><a title="electricpy.phs_to_seq" href="#electricpy.phs_to_seq">phs_to_seq</a></code></li>
<li><code><a title="electricpy.powerflow" href="#electricpy.powerflow">powerflow</a></code></li>
<li><code><a title="electricpy.powerimpedance" href="#electricpy.powerimpedance">powerimpedance</a></code></li>
<li><code><a title="electricpy.powerset" href="#electricpy.powerset">powerset</a></code></li>
<li><code><a title="electricpy.powertriangle" href="#electricpy.powertriangle">powertriangle</a></code></li>
<li><code><a title="electricpy.primary" href="#electricpy.primary">primary</a></code></li>
<li><code><a title="electricpy.probdensity" href="#electricpy.probdensity">probdensity</a></code></li>
<li><code><a title="electricpy.protor" href="#electricpy.protor">protor</a></code></li>
<li><code><a title="electricpy.pstator" href="#electricpy.pstator">pstator</a></code></li>
<li><code><a title="electricpy.puchgbase" href="#electricpy.puchgbase">puchgbase</a></code></li>
<li><code><a title="electricpy.rad_to_hz" href="#electricpy.rad_to_hz">rad_to_hz</a></code></li>
<li><code><a title="electricpy.rad_to_rpm" href="#electricpy.rad_to_rpm">rad_to_rpm</a></code></li>
<li><code><a title="electricpy.radsec" href="#electricpy.radsec">radsec</a></code></li>
<li><code><a title="electricpy.reactance" href="#electricpy.reactance">reactance</a></code></li>
<li><code><a title="electricpy.rectifiercap" href="#electricpy.rectifiercap">rectifiercap</a></code></li>
<li><code><a title="electricpy.rfft" href="#electricpy.rfft">rfft</a></code></li>
<li><code><a title="electricpy.rms" href="#electricpy.rms">rms</a></code></li>
<li><code><a title="electricpy.rpm_to_hz" href="#electricpy.rpm_to_hz">rpm_to_hz</a></code></li>
<li><code><a title="electricpy.rpm_to_rad" href="#electricpy.rpm_to_rad">rpm_to_rad</a></code></li>
<li><code><a title="electricpy.rtdtemp" href="#electricpy.rtdtemp">rtdtemp</a></code></li>
<li><code><a title="electricpy.rxrecompose" href="#electricpy.rxrecompose">rxrecompose</a></code></li>
<li><code><a title="electricpy.sampfft" href="#electricpy.sampfft">sampfft</a></code></li>
<li><code><a title="electricpy.secondary" href="#electricpy.secondary">secondary</a></code></li>
<li><code><a title="electricpy.seq_to_abc" href="#electricpy.seq_to_abc">seq_to_abc</a></code></li>
<li><code><a title="electricpy.seq_to_phs" href="#electricpy.seq_to_phs">seq_to_phs</a></code></li>
<li><code><a title="electricpy.sequencez" href="#electricpy.sequencez">sequencez</a></code></li>
<li><code><a title="electricpy.shannondata" href="#electricpy.shannondata">shannondata</a></code></li>
<li><code><a title="electricpy.sinfilt" href="#electricpy.sinfilt">sinfilt</a></code></li>
<li><code><a title="electricpy.step" href="#electricpy.step">step</a></code></li>
<li><code><a title="electricpy.string_to_bits" href="#electricpy.string_to_bits">string_to_bits</a></code></li>
<li><code><a title="electricpy.syncspeed" href="#electricpy.syncspeed">syncspeed</a></code></li>
<li><code><a title="electricpy.synmach_Eq" href="#electricpy.synmach_Eq">synmach_Eq</a></code></li>
<li><code><a title="electricpy.tcycle" href="#electricpy.tcycle">tcycle</a></code></li>
<li><code><a title="electricpy.tflatex" href="#electricpy.tflatex">tflatex</a></code></li>
<li><code><a title="electricpy.thermocouple" href="#electricpy.thermocouple">thermocouple</a></code></li>
<li><code><a title="electricpy.timedischarge" href="#electricpy.timedischarge">timedischarge</a></code></li>
<li><code><a title="electricpy.transformertest" href="#electricpy.transformertest">transformertest</a></code></li>
<li><code><a title="electricpy.transposez" href="#electricpy.transposez">transposez</a></code></li>
<li><code><a title="electricpy.unbalance" href="#electricpy.unbalance">unbalance</a></code></li>
<li><code><a title="electricpy.vcapcharge" href="#electricpy.vcapcharge">vcapcharge</a></code></li>
<li><code><a title="electricpy.vcapdischarge" href="#electricpy.vcapdischarge">vcapdischarge</a></code></li>
<li><code><a title="electricpy.vipf" href="#electricpy.vipf">vipf</a></code></li>
<li><code><a title="electricpy.voltdiv" href="#electricpy.voltdiv">voltdiv</a></code></li>
<li><code><a title="electricpy.vscdcbus" href="#electricpy.vscdcbus">vscdcbus</a></code></li>
<li><code><a title="electricpy.vscgains" href="#electricpy.vscgains">vscgains</a></code></li>
<li><code><a title="electricpy.watts" href="#electricpy.watts">watts</a></code></li>
<li><code><a title="electricpy.watts_to_hp" href="#electricpy.watts_to_hp">watts_to_hp</a></code></li>
<li><code><a title="electricpy.wrms" href="#electricpy.wrms">wrms</a></code></li>
<li><code><a title="electricpy.xfmphs" href="#electricpy.xfmphs">xfmphs</a></code></li>
<li><code><a title="electricpy.zdecompose" href="#electricpy.zdecompose">zdecompose</a></code></li>
<li><code><a title="electricpy.zperlength" href="#electricpy.zperlength">zperlength</a></code></li>
<li><code><a title="electricpy.zpu" href="#electricpy.zpu">zpu</a></code></li>
<li><code><a title="electricpy.zrecompose" href="#electricpy.zrecompose">zrecompose</a></code></li>
<li><code><a title="electricpy.zsource" href="#electricpy.zsource">zsource</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>