
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>electricpy &#8212; electricpy 0.3.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/material.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="shortcut icon" href="../_static/ElectricpyLogo.svg"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  
   

  </head>
  <body dir=ltr
        data-md-color-primary=blue data-md-color-accent=light-blue>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#_modules/electricpy" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../index.html" title="electricpy 0.3.0 documentation"
           class="md-header-nav__button md-logo">
          
              <img src="../_static/ElectricpyLogo.svg" height="26"
                   alt="electricpy 0.3.0 documentation logo">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">ElectricPy</span>
          <span class="md-header-nav__topic"> electricpy </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../search.html" method="get" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/engineerjoe440/ElectricPy/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    ElectricPy
  </div>
</a>
          </div>
        </div>
      
      
  
  <script src="../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../"versions.json"",
        target_loc = "../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>
  

    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../index.html" class="md-tabs__link">electricpy 0.3.0 documentation</a></li>
          <li class="md-tabs__item"><a href="index.html" class="md-tabs__link">Module code</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../index.html" title="electricpy 0.3.0 documentation" class="md-nav__button md-logo">
      
        <img src="../_static/ElectricpyLogo.svg" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../index.html"
       title="electricpy 0.3.0 documentation">ElectricPy</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/engineerjoe440/ElectricPy/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    ElectricPy
  </div>
</a>
    </div>
  
  

  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
    
      <a href="../electricpyapi.html" class="md-nav__link">ElectricPy API</a>
      <ul class="md-nav__list"> 
    <li class="md-nav__item">
    
    
      <a href="../api/electricpy.html" class="md-nav__link">electricpy</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../api/electricpy.bode.html" class="md-nav__link">electricpy.bode</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../api/electricpy.conversions.html" class="md-nav__link">electricpy.conversions</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../api/electricpy.fault.html" class="md-nav__link">electricpy.fault</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../api/electricpy.latex.html" class="md-nav__link">electricpy.latex</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../api/electricpy.math.html" class="md-nav__link">electricpy.math</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../api/electricpy.passive.html" class="md-nav__link">electricpy.passive</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../api/electricpy.phasor.html" class="md-nav__link">electricpy.phasor</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../api/electricpy.sim.html" class="md-nav__link">electricpy.sim</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../api/electricpy.visu.html" class="md-nav__link">electricpy.visu</a>
      
    
    </li></ul>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../constants.html" class="md-nav__link">Constants</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../additionalresources.html" class="md-nav__link">Additional Resources</a>
      <ul class="md-nav__list"> 
    <li class="md-nav__item">
    
    
      <a href="../additionalresources.html#generic-and-data-science" class="md-nav__link">Generic and Data Science</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../additionalresources.html#electrical-engineering-focus" class="md-nav__link">Electrical Engineering Focus</a>
      
    
    </li></ul>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../changes.html" class="md-nav__link">Recent Changes</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="https://github.com/engineerjoe440/ElectricPy" class="md-nav__link">Github</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="https://pypi.org/project/electricpy" class="md-nav__link">PyPI</a>
      
    
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
  <ul class="md-nav__list" data-md-scrollfix="">
    

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  <h1 id="modules-electricpy--page-root">Source code for electricpy</h1><div class="highlight"><pre>
<span></span><span class="c1">################################################################################</span>
<span class="sd">"""</span>
<span class="sd">`electricpy` Package - Main Module.</span>

<span class="sd">&gt;&gt;&gt; import electricpy as ep</span>

<span class="sd">Filled with calculators, evaluators, and plotting functions, this package will</span>
<span class="sd">provide a wide array of capabilities to any electrical engineer.</span>

<span class="sd">Built to support operations similar to Numpy and Scipy, this package is designed</span>
<span class="sd">to aid in scientific calculations.</span>
<span class="sd">"""</span>
<span class="c1">################################################################################</span>


<span class="kn">from</span> <span class="nn">.version</span> <span class="kn">import</span> <span class="n">NAME</span><span class="p">,</span> <span class="n">VERSION</span>
<span class="kn">import</span> <span class="nn">cmath</span> <span class="k">as</span> <span class="nn">_c</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">getframeinfo</span> <span class="k">as</span> <span class="n">_getframeinfo</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">stack</span> <span class="k">as</span> <span class="n">_stack</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">showwarning</span> <span class="k">as</span> <span class="n">_showwarning</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">_plt</span>
<span class="c1"># Import Supporting Modules</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_np</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">quad</span> <span class="k">as</span> <span class="n">integrate</span>

<span class="c1"># Import Submodules</span>
<span class="kn">from</span> <span class="nn">.constants</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.phasors</span> <span class="kn">import</span> <span class="n">phasor</span><span class="p">,</span> <span class="n">parallelz</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="n">VERSION</span>

<span class="c1"># Define Cycle Time Function</span>


<div class="viewcode-block" id="tcycle"><a class="viewcode-back" href="../api/electricpy.tcycle.html#electricpy.tcycle">[docs]</a><span class="k">def</span> <span class="nf">tcycle</span><span class="p">(</span><span class="n">ncycles</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Time of Electrical Cycles.</span>

<span class="sd">    Evaluates the time for a number of n</span>
<span class="sd">    cycles given the system frequency.</span>

<span class="sd">    .. math:: t = \frac{n_{cycles}}{freq}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ncycles:    float, optional</span>
<span class="sd">                Number (n) of cycles to evaluate, default=1</span>
<span class="sd">    freq:       float, optional</span>
<span class="sd">                System frequency in Hz, default=60</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    t:          float</span>
<span class="sd">                Total time for *ncycles*</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import electricpy as ep</span>
<span class="sd">    &gt;&gt;&gt; ep.tcycle(1, freq=60) #Value of ncycles=1 &amp; freq=60</span>
<span class="sd">    0.016666666666666666</span>
<span class="sd">    &gt;&gt;&gt; ep.tcycle(1, freq=50) #Value of ncycles=1 &amp; freq=50</span>
<span class="sd">    0.02</span>
<span class="sd">    """</span>
    <span class="c1"># Condition Inputs</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ncycles</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ncycles</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">freq</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"ncycles and freq must be the same shape"</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ncycles</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ncycles</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"ncycles and freq must be the same length"</span><span class="p">)</span>

    <span class="n">ncycles</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ncycles</span><span class="p">)</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">freq</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">"Frequency must not be 0"</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">freq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="c1"># frequency must be postive value</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Frequency must be postive value"</span><span class="p">)</span>
    <span class="c1"># Evaluate the time for ncycles</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">ncycles</span> <span class="o">/</span> <span class="n">freq</span>
    <span class="c1"># Return</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">time</span></div>

<span class="c1"># Define Reactance Calculator</span>


<div class="viewcode-block" id="reactance"><a class="viewcode-back" href="../api/electricpy.reactance.html#electricpy.reactance">[docs]</a><span class="k">def</span> <span class="nf">reactance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">sensetivity</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Capacitance/Inductance from Impedance.</span>

<span class="sd">    Calculates the Capacitance or Inductance in Farads or Henreys</span>
<span class="sd">    (respectively) provided the impedance of an element.</span>
<span class="sd">    Will return capacitance (in Farads) if ohmic impedance is</span>
<span class="sd">    negative :eq:`cap`, or inductance (in Henrys) if ohmic impedance is</span>
<span class="sd">    positive :eq:`ind`. If imaginary: calculate with j factor</span>
<span class="sd">    (imaginary number).</span>

<span class="sd">    .. math:: C = \frac{1}{\omega*Z}</span>
<span class="sd">       :label: cap</span>

<span class="sd">    .. math:: L = \frac{Z}{\omega}</span>
<span class="sd">       :label: ind</span>

<span class="sd">    This requires that the radian frequency is found as follows:</span>

<span class="sd">    .. math:: \omega = 2*\pi*freq</span>

<span class="sd">    where `freq` is the frequency in Hertz.</span>

<span class="sd">    .. note::</span>
<span class="sd">       It's worth noting here, that the resistance will be found by</span>
<span class="sd">       extracting the real part of a complex value. That is:</span>

<span class="sd">       .. math:: R = Real( R + jX )</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z:              complex</span>
<span class="sd">                    The Impedance Provided, may be complex (R+jI)</span>
<span class="sd">    freq:           float, optional</span>
<span class="sd">                    The Frequency Base for Provided Impedance, default=60</span>
<span class="sd">    sensetivity:    float, optional</span>
<span class="sd">                    The sensetivity used to check if a resistance was</span>
<span class="sd">                    provided, default=1e-12</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float:          Capacitance or Inductance of Impedance</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import electricpy as ep</span>
<span class="sd">    &gt;&gt;&gt; ep.reactance(z=5) # ohms - inductive impedance</span>
<span class="sd">    0.0132629...</span>
<span class="sd">    """</span>
    <span class="c1"># Evaluate Omega</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span>
    <span class="c1"># Input is Complex</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="nb">complex</span><span class="p">):</span>
        <span class="c1"># Test for Resistance</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sensetivity</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">real</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">imag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">z</span> <span class="o">/</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="c1"># Combine with resistance if present</span>
        <span class="k">if</span> <span class="n">R</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">z</span> <span class="o">/</span> <span class="n">w</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="c1"># Return Output</span>
    <span class="k">return</span> <span class="n">out</span></div>


<span class="c1"># Define display function</span>
<div class="viewcode-block" id="cprint"><a class="viewcode-back" href="../api/electricpy.cprint.html#electricpy.cprint">[docs]</a><span class="k">def</span> <span class="nf">cprint</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
           <span class="n">pretty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">printval</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Phasor (Complex) Printing Function.</span>

<span class="sd">    This function is designed to accept a complex value (val) and print</span>
<span class="sd">    the value in the standard electrical engineering notation:</span>

<span class="sd">    **magnitude ∠ angle °**</span>

<span class="sd">    This function will print the magnitude in degrees, and can print</span>
<span class="sd">    a unit and label in addition to the value itself.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    val:        complex</span>
<span class="sd">                The Complex Value to be Printed, may be singular value,</span>
<span class="sd">                tuple of values, or list/array.</span>
<span class="sd">    unit:       string, optional</span>
<span class="sd">                The string to be printed corresponding to the unit mark.</span>
<span class="sd">    label:      str, optional</span>
<span class="sd">                The pre-pended string used as a descriptive labeling string.</span>
<span class="sd">    title:      str, optional</span>
<span class="sd">                The pre-pended string describing a set of complex values.</span>
<span class="sd">    pretty:     bool, optional</span>
<span class="sd">                Control argument to force printed result to a *pretty*</span>
<span class="sd">                format without array braces. default=True</span>
<span class="sd">    printval:   bool, optional</span>
<span class="sd">                Control argument enabling/disabling printing of the string.</span>
<span class="sd">                default=True</span>
<span class="sd">    ret:        bool, optional</span>
<span class="sd">                Control argument allowing the evaluated value to be returned.</span>
<span class="sd">                default=False</span>
<span class="sd">    decimals:   int, optional</span>
<span class="sd">                Replaces `round` argument. Control argument specifying how</span>
<span class="sd">                many decimals of the complex value to be printed. May be</span>
<span class="sd">                negative to round to spaces to the left of the decimal place</span>
<span class="sd">                (follows standard round() functionality). default=3</span>
<span class="sd">    round:      int, optional, DEPRECATED</span>
<span class="sd">                Control argument specifying how many decimals of the complex</span>
<span class="sd">                value to be printed. May be negative to round to spaces</span>
<span class="sd">                to the left of the decimal place (follows standard round()</span>
<span class="sd">                functionality). default=3</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numarr:     numpy.ndarray</span>
<span class="sd">                The array of values corresponding to the magnitude and angle,</span>
<span class="sd">                values are returned in the form: [[ mag, ang ],...,[ mag, ang ]]</span>
<span class="sd">                where the angles are evaluated in degrees.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import electricpy as ep</span>
<span class="sd">    &gt;&gt;&gt; from electricpy import phasors</span>
<span class="sd">    &gt;&gt;&gt; v = phasor(67, 120)</span>
<span class="sd">    &gt;&gt;&gt; ep.cprint(v)</span>
<span class="sd">    67.0 ∠ 120.0°</span>
<span class="sd">    &gt;&gt;&gt; voltages = np.array([[67,0],</span>
<span class="sd">    ...                      [67,-120],</span>
<span class="sd">    ...                      [67,120]])</span>
<span class="sd">    &gt;&gt;&gt; Vset = ep.phasors.phasorlist( voltages )</span>
<span class="sd">    &gt;&gt;&gt; ep.cprint(Vset)</span>
<span class="sd">    67.0 ∠ 0.0°</span>
<span class="sd">    67.0 ∠ -120.0°</span>
<span class="sd">    67.0 ∠ 120.0°</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    electricpy.phasors.phasor:       Phasor Generating Function</span>
<span class="sd">    electricpy.phasors.phasorlist:   Phasor Generating Function for Lists/Arrays</span>
<span class="sd">    electricpy.phasors.phasorz:      Impedance Phasor Generator</span>
<span class="sd">    """</span>
    <span class="c1"># Use depricated `round`</span>
    <span class="k">if</span> <span class="nb">round</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">decimals</span> <span class="o">=</span> <span class="nb">round</span>
        <span class="n">caller</span> <span class="o">=</span> <span class="n">_getframeinfo</span><span class="p">(</span><span class="n">_stack</span><span class="p">()[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Demonstrate Deprecation Warning</span>
        <span class="n">_showwarning</span><span class="p">(</span><span class="s1">'`round` argument will be deprecated in favor of `decimals`'</span><span class="p">,</span>
                     <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">caller</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">caller</span><span class="o">.</span><span class="n">lineno</span><span class="p">)</span>
    <span class="c1"># Interpret as numpy array if simple list</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>  <span class="c1"># Ensure that input is array</span>
    <span class="c1"># Find length of the input array</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">shp</span>  <span class="c1"># Interpret Shape of Object</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">shp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">col</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">size</span>
        <span class="c1"># Handle Label as a List or Array</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">label</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">[</span><span class="n">tmp</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">sz</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Too Few Label Arguments"</span><span class="p">)</span>
        <span class="c1"># Handle Label as String</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">label</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">[</span><span class="n">tmp</span><span class="p">])</span>
        <span class="c1"># Handle Lack of Label</span>
        <span class="k">elif</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Handle all Other Cases</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Invalid Label"</span><span class="p">)</span>
        <span class="c1"># Handle Unit as a List or Array</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">unit</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="p">[</span><span class="n">tmp</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">sz</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unit</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Too Few Unit Arguments"</span><span class="p">)</span>
        <span class="c1"># Handle Unit as String</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">unit</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="p">[</span><span class="n">tmp</span><span class="p">])</span>
        <span class="c1"># Handle Lack of Unit</span>
        <span class="k">elif</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Handle all Other Cases</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Invalid Unit"</span><span class="p">)</span>
        <span class="c1"># Generate Default Arrays</span>
        <span class="n">printarr</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>  <span class="c1"># Empty array</span>
        <span class="n">numarr</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>  <span class="c1"># Empty array</span>
        <span class="c1"># Operate on List/Array</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">_label</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">_unit</span> <span class="o">=</span> <span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">mag</span><span class="p">,</span> <span class="n">ang_r</span> <span class="o">=</span> <span class="n">_c</span><span class="o">.</span><span class="n">polar</span><span class="p">(</span><span class="n">_val</span><span class="p">)</span>  <span class="c1"># Convert to polar form</span>
            <span class="n">ang</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">ang_r</span><span class="p">)</span>  <span class="c1"># Convert to degrees</span>
            <span class="n">mag</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">decimals</span><span class="p">)</span>  <span class="c1"># Round</span>
            <span class="n">ang</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="n">decimals</span><span class="p">)</span>  <span class="c1"># Round</span>
            <span class="n">strg</span> <span class="o">=</span> <span class="s2">""</span>
            <span class="k">if</span> <span class="n">_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">strg</span> <span class="o">+=</span> <span class="n">_label</span> <span class="o">+</span> <span class="s2">" "</span>
            <span class="n">strg</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span> <span class="o">+</span> <span class="s2">" ∠ "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span> <span class="o">+</span> <span class="s2">"°"</span>
            <span class="k">if</span> <span class="n">_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">strg</span> <span class="o">+=</span> <span class="s2">" "</span> <span class="o">+</span> <span class="n">_unit</span>
            <span class="n">printarr</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">printarr</span><span class="p">,</span> <span class="n">strg</span><span class="p">)</span>
            <span class="n">numarr</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numarr</span><span class="p">,</span> <span class="p">[</span><span class="n">mag</span><span class="p">,</span> <span class="n">ang</span><span class="p">])</span>
        <span class="c1"># Reshape Arrays</span>
        <span class="n">printarr</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">printarr</span><span class="p">,</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>
        <span class="n">numarr</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">numarr</span><span class="p">,</span> <span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c1"># Print</span>
        <span class="k">if</span> <span class="n">printval</span> <span class="ow">and</span> <span class="n">row</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">strg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">printval</span> <span class="ow">and</span> <span class="n">pretty</span><span class="p">:</span>
            <span class="n">strg</span> <span class="o">=</span> <span class="s1">''</span>
            <span class="n">start</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">printarr</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">start</span><span class="p">:</span>
                    <span class="n">strg</span> <span class="o">+=</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span>
                <span class="n">strg</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">start</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">strg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">printval</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">printarr</span><span class="p">)</span>
        <span class="c1"># Return if Necessary</span>
        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">numarr</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
        <span class="c1"># Handle Invalid Unit/Label</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Invalid Unit Type for Value"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Invalid Label Type for Value"</span><span class="p">)</span>
        <span class="n">mag</span><span class="p">,</span> <span class="n">ang_r</span> <span class="o">=</span> <span class="n">_c</span><span class="o">.</span><span class="n">polar</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>  <span class="c1"># Convert to polar form</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">ang_r</span><span class="p">)</span>  <span class="c1"># Convert to degrees</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">decimals</span><span class="p">)</span>  <span class="c1"># Round</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="n">decimals</span><span class="p">)</span>  <span class="c1"># Round</span>
        <span class="n">strg</span> <span class="o">=</span> <span class="s2">""</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">strg</span> <span class="o">+=</span> <span class="n">label</span> <span class="o">+</span> <span class="s2">" "</span>
        <span class="n">strg</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span> <span class="o">+</span> <span class="s2">" ∠ "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span> <span class="o">+</span> <span class="s2">"°"</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">strg</span> <span class="o">+=</span> <span class="s2">" "</span> <span class="o">+</span> <span class="n">unit</span>
        <span class="c1"># Print values (by default)</span>
        <span class="k">if</span> <span class="n">printval</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">strg</span><span class="p">)</span>
        <span class="c1"># Return values when requested</span>
        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">([</span><span class="n">mag</span><span class="p">,</span> <span class="n">ang</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Invalid Input Type"</span><span class="p">)</span></div>


<span class="c1"># Define Phase/Line Converter</span>
<div class="viewcode-block" id="phaseline"><a class="viewcode-back" href="../api/electricpy.phaseline.html#electricpy.phaseline">[docs]</a><span class="k">def</span> <span class="nf">phaseline</span><span class="p">(</span><span class="n">VLL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">VLN</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Iline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Iphase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">realonly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Line-Line to Line-Neutral Converter.</span>

<span class="sd">    This function is designed to return the phase- or line-equivalent</span>
<span class="sd">    of the voltage/current provided. It is designed to be used when</span>
<span class="sd">    converting delta- to wye-connections and vice-versa.</span>
<span class="sd">    Given a voltage of one type, this function will return the</span>
<span class="sd">    voltage of the opposite type. The same is true for current.</span>

<span class="sd">    .. math:: V_{LL} = \sqrt{3}∠30° * V_{LN}</span>
<span class="sd">       :label: voltages</span>

<span class="sd">    Typical American (United States) standard is to note voltages in</span>
<span class="sd">    Line-to-Line values (VLL), and often, the Line-to-Neutral voltage</span>
<span class="sd">    is of value, this function uses the voltage :eq:`voltages` relation</span>
<span class="sd">    to evaluate either voltage given the other.</span>

<span class="sd">    .. math:: I_{Φ} = \frac{I_{line}}{\sqrt{3}∠30°}</span>
<span class="sd">       :label: currents</span>

<span class="sd">    Often, the phase current in a delta-connected device is of</span>
<span class="sd">    particular interest, and the line-current is provided. This</span>
<span class="sd">    function uses the current :eq:`currents` formula to evaluate</span>
<span class="sd">    phase- and line-current given the opposing term.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    VLL:        float, optional</span>
<span class="sd">                The Line-to-Line Voltage; default=None</span>
<span class="sd">    VLN:        float, optional</span>
<span class="sd">                The Line-to-Neutral Voltage; default=None</span>
<span class="sd">    Iline:      float, optional</span>
<span class="sd">                The Line-Current; default=None</span>
<span class="sd">    Iphase:     float, optional</span>
<span class="sd">                The Phase-Current; default=None</span>
<span class="sd">    realonly:   bool, optional</span>
<span class="sd">                Replacement of `complex` argument. Control to return</span>
<span class="sd">                value in complex form; default=None</span>
<span class="sd">    complex:    bool, optional, DEPRECATED</span>
<span class="sd">                Control to return value in complex form, refer to</span>
<span class="sd">                `realonly` instead. default=None</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import electricpy as ep</span>
<span class="sd">    &gt;&gt;&gt; ep.cprint(ep.phaseline(VLL=(13.8*ep.k))) # 13.8kV</span>
<span class="sd">    7967.434 ∠ -30.0°</span>
<span class="sd">    """</span>
    <span class="c1"># Monitor for deprecated input</span>
    <span class="k">if</span> <span class="s1">'complex'</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">realonly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">realonly</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">'complex'</span><span class="p">]</span>
        <span class="n">caller</span> <span class="o">=</span> <span class="n">_getframeinfo</span><span class="p">(</span><span class="n">_stack</span><span class="p">()[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Demonstrate Deprecation Warning</span>
        <span class="n">_showwarning</span><span class="p">(</span><span class="s1">'`complex` argument will be deprecated in favor of `realonly`'</span><span class="p">,</span>
                     <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">caller</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">caller</span><span class="o">.</span><span class="n">lineno</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Given VLL, convert to VLN</span>
    <span class="k">if</span> <span class="n">VLL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">VLN</span> <span class="o">=</span> <span class="n">VLL</span> <span class="o">/</span> <span class="p">(</span><span class="n">VLLcVLN</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">VLN</span>
    <span class="c1"># Given VLN, convert to VLL</span>
    <span class="k">elif</span> <span class="n">VLN</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">VLL</span> <span class="o">=</span> <span class="n">VLN</span> <span class="o">*</span> <span class="n">VLLcVLN</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">VLL</span>
    <span class="c1"># Given Iphase, convert to Iline</span>
    <span class="k">elif</span> <span class="n">Iphase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Iline</span> <span class="o">=</span> <span class="n">Iphase</span> <span class="o">*</span> <span class="n">ILcIP</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">Iline</span>
    <span class="c1"># Given Iline, convert to Iphase</span>
    <span class="k">elif</span> <span class="n">Iline</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Iphase</span> <span class="o">=</span> <span class="n">Iline</span> <span class="o">/</span> <span class="n">ILcIP</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">Iphase</span>
    <span class="c1"># None given, error encountered</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"ERROR: No value given"</span> <span class="o">+</span>
              <span class="s2">"or innapropriate value"</span> <span class="o">+</span>
              <span class="s2">"given."</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Auto-detect Complex Values</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">realonly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">realonly</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># Return as complex only when requested</span>
    <span class="k">if</span> <span class="n">realonly</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span></div>


<span class="c1"># Define Power Set Function</span>
<div class="viewcode-block" id="powerset"><a class="viewcode-back" href="../api/electricpy.powerset.html#electricpy.powerset">[docs]</a><span class="k">def</span> <span class="nf">powerset</span><span class="p">(</span><span class="n">P</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">PF</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">find</span><span class="o">=</span><span class="s1">''</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Power Triangle Conversion Function.</span>

<span class="sd">    This function is designed to calculate all values</span>
<span class="sd">    in the set { P, Q, S, PF } when two (2) of the</span>
<span class="sd">    values are provided. The equations in this</span>
<span class="sd">    function are prepared for AC values, that is:</span>
<span class="sd">    real and reactive power, apparent power, and power</span>
<span class="sd">    factor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    P:      float, optional</span>
<span class="sd">            Real Power, unitless; default=None</span>
<span class="sd">    Q:      float, optional</span>
<span class="sd">            Reactive Power, unitless; default=None</span>
<span class="sd">    S:      float, optional</span>
<span class="sd">            Apparent Power, unitless; default=None</span>
<span class="sd">    PF:     float, optional</span>
<span class="sd">            Power Factor, unitless, provided as a</span>
<span class="sd">            decimal value, lagging is positive,</span>
<span class="sd">            leading is negative; default=None</span>
<span class="sd">    find:   str, optional</span>
<span class="sd">            Control argument to specify which value</span>
<span class="sd">            should be returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P:      float</span>
<span class="sd">            Calculated Real Power Magnitude</span>
<span class="sd">    Q:      float</span>
<span class="sd">            Calculated Reactive Power Magnitude</span>
<span class="sd">    S:      float</span>
<span class="sd">            Calculated Apparent Power Magnitude</span>
<span class="sd">    PF:     float</span>
<span class="sd">            Calculated Power Factor</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import electricpy as ep</span>
<span class="sd">    &gt;&gt;&gt; ep.powerset(P=400, Q=300)</span>
<span class="sd">    (400, 300, 500.0, 0.8)</span>
<span class="sd">    &gt;&gt;&gt; ep.powerset(P=400, Q=300, find="PF")</span>
<span class="sd">    0.8</span>
<span class="sd">    """</span>
    <span class="c1"># Given P and Q</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">P</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">Q</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">P</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Q</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">PF</span> <span class="o">=</span> <span class="n">P</span> <span class="o">/</span> <span class="n">S</span>
        <span class="k">if</span> <span class="n">Q</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">PF</span> <span class="o">=</span> <span class="o">-</span><span class="n">PF</span>
    <span class="c1"># Given S and PF</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">PF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">P</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="n">PF</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">P</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">PF</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="o">-</span><span class="n">Q</span>
    <span class="c1"># Given P and PF</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">P</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">PF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">P</span> <span class="o">/</span> <span class="n">PF</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">P</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">PF</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="o">-</span><span class="n">Q</span>
    <span class="c1"># Given P and S</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">P</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">P</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">PF</span> <span class="o">=</span> <span class="n">P</span> <span class="o">/</span> <span class="n">S</span>
    <span class="c1"># Given Q and S</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">Q</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">Q</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">PF</span> <span class="o">=</span> <span class="n">P</span> <span class="o">/</span> <span class="n">S</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"ERROR: Invalid Parameters or too few"</span> <span class="o">+</span>
                         <span class="s2">" parameters given to calculate."</span><span class="p">)</span>
    <span class="c1"># Return</span>
    <span class="n">find</span> <span class="o">=</span> <span class="n">find</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">find</span> <span class="o">==</span> <span class="s1">'P'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">P</span>
    <span class="k">elif</span> <span class="n">find</span> <span class="o">==</span> <span class="s1">'Q'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Q</span>
    <span class="k">elif</span> <span class="n">find</span> <span class="o">==</span> <span class="s1">'S'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span>
    <span class="k">elif</span> <span class="n">find</span> <span class="o">==</span> <span class="s1">'PF'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">PF</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">PF</span></div>


<div class="viewcode-block" id="slew_rate"><a class="viewcode-back" href="../api/electricpy.slew_rate.html#electricpy.slew_rate">[docs]</a><span class="k">def</span> <span class="nf">slew_rate</span><span class="p">(</span><span class="n">V</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">SR</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">find</span><span class="o">=</span><span class="s1">''</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Slew Rate Calculator.</span>

<span class="sd">    This function is designed to calculate slew rate</span>
<span class="sd">    i.e the change of voltage per unit of time`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    V:      float, optional</span>
<span class="sd">            Voltage, Volts; default=None</span>
<span class="sd">    freq:      float, optional</span>
<span class="sd">            Frequency, Hz; default=None</span>
<span class="sd">    SR:      float, optional</span>
<span class="sd">            Slew Rate, Volts/sec; default=None</span>
<span class="sd">    find:   str, optional</span>
<span class="sd">            Control argument to specify which value</span>
<span class="sd">            should be returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    V:      float</span>
<span class="sd">            Calculated Volatage</span>
<span class="sd">    freq:   float</span>
<span class="sd">            Calculated frequency</span>
<span class="sd">    SR:     float</span>
<span class="sd">            Calculated slew rate</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">V</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">SR</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">V</span> <span class="o">*</span> <span class="n">freq</span>
    <span class="k">elif</span> <span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">SR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">SR</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">V</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">SR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">SR</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"ERROR: Invalid Parameters or too few"</span> <span class="o">+</span>
                         <span class="s2">" parameters given to calculate."</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">find</span> <span class="o">==</span> <span class="s1">'V'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">V</span>
    <span class="k">elif</span> <span class="n">find</span> <span class="o">==</span> <span class="s1">'freq'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">freq</span>
    <span class="k">elif</span> <span class="n">find</span> <span class="o">==</span> <span class="s1">'SR'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SR</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">V</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">SR</span></div>


<span class="c1"># Define Non-Linear Power Factor Calculator</span>
<div class="viewcode-block" id="non_linear_pf"><a class="viewcode-back" href="../api/electricpy.non_linear_pf.html#electricpy.non_linear_pf">[docs]</a><span class="k">def</span> <span class="nf">non_linear_pf</span><span class="p">(</span><span class="n">PFtrue</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">PFdist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">PFdisp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Non-Linear Power Factor Evaluator.</span>

<span class="sd">    This function is designed to evaluate one of three unknowns</span>
<span class="sd">    given the other two. These particular unknowns are the arguments</span>
<span class="sd">    and as such, they are described in the representative sections</span>
<span class="sd">    below.</span>

<span class="sd">    .. note:: Also available as `nlinpf`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    PFtrue:     float, exclusive</span>
<span class="sd">                The "True" power-factor, default=None</span>
<span class="sd">    PFdist:     float, exclusive</span>
<span class="sd">                The "Distorted" power-factor, default=None</span>
<span class="sd">    PFdisp:     float, exclusive</span>
<span class="sd">                The "Displacement" power-factor, default=None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float:  This function will return the unknown variable from the previously</span>
<span class="sd">            described set of variables.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">PFtrue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">PFdist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">PFdisp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"ERROR: Too many constraints, no solution."</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">PFdist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">PFdisp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">PFdist</span> <span class="o">*</span> <span class="n">PFdisp</span>
    <span class="k">if</span> <span class="n">PFtrue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">PFdisp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">PFtrue</span> <span class="o">/</span> <span class="n">PFdisp</span>
    <span class="k">if</span> <span class="n">PFtrue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">PFdist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">PFtrue</span> <span class="o">/</span> <span class="n">PFdist</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"ERROR: Function requires at least two arguments."</span><span class="p">)</span></div>


<span class="c1"># Alias to original Name</span>
<span class="n">nlinpf</span> <span class="o">=</span> <span class="n">non_linear_pf</span>


<span class="c1"># Define Short-Circuit RL Current Calculator</span>
<div class="viewcode-block" id="short_circuit_current"><a class="viewcode-back" href="../api/electricpy.short_circuit_current.html#electricpy.short_circuit_current">[docs]</a><span class="k">def</span> <span class="nf">short_circuit_current</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mxcurrent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Short-Circuit-Current (ISC) Calculator.</span>

<span class="sd">    The Isc-RL function (Short Circuit Current for RL Circuit)</span>
<span class="sd">    is designed to calculate the short-circuit current for an</span>
<span class="sd">    RL circuit.</span>

<span class="sd">    .. note:: Also available as `iscrl`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    V:          float</span>
<span class="sd">                The absolute magnitude of the voltage.</span>
<span class="sd">    Z:          float</span>
<span class="sd">                The complex value of the impedance. (R + jX)</span>
<span class="sd">    t:          float, optional</span>
<span class="sd">                The time at which the value should be calculated,</span>
<span class="sd">                should be specified in seconds, default=None</span>
<span class="sd">    f:          float, optional</span>
<span class="sd">                The system frequency, specified in Hz, default=None</span>
<span class="sd">    mxcurrent:  bool, optional</span>
<span class="sd">                Control variable to enable calculating the value at</span>
<span class="sd">                maximum current, default=True</span>
<span class="sd">    alpha:      float, optional</span>
<span class="sd">                Angle specification, default=None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Opt 1 - (Irms, IAC, K):     The RMS current with maximum DC</span>
<span class="sd">                                offset, the AC current magnitude,</span>
<span class="sd">                                and the asymmetry factor.</span>
<span class="sd">    Opt 2 - (i, iAC, iDC, T):   The Instantaneous current with</span>
<span class="sd">                                maximum DC offset, the instantaneous</span>
<span class="sd">                                AC current, the instantaneous DC</span>
<span class="sd">                                current, and the time-constant T.</span>
<span class="sd">    Opt 3 - (Iac):              The RMS current without DC offset.</span>
<span class="sd">    """</span>
    <span class="c1"># Calculate omega, theta, R, and X</span>
    <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">f</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">R</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">X</span> <span class="o">/</span> <span class="n">R</span><span class="p">)</span>

    <span class="c1"># If Maximum Current is Desired and No alpha provided</span>
    <span class="k">if</span> <span class="n">mxcurrent</span> <span class="ow">and</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">-</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">mxcurrent</span> <span class="ow">and</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"ERROR: Inappropriate Arguments Provided.</span><span class="se">\n</span><span class="s2">"</span> <span class="o">+</span>
                         <span class="s2">"Not both mxcurrent and alpha can be provided."</span><span class="p">)</span>

    <span class="c1"># Calculate Asymmetrical (total) Current if t is not None</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Calculate RMS if none of the angular values are provided</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">omega</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Calculate tau</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="n">t</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">60</span><span class="p">)</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">tau</span> <span class="o">/</span> <span class="p">(</span><span class="n">X</span> <span class="o">/</span> <span class="n">R</span><span class="p">)))</span>
            <span class="n">IAC</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">V</span> <span class="o">/</span> <span class="n">Z</span><span class="p">)</span>
            <span class="n">Irms</span> <span class="o">=</span> <span class="n">K</span> <span class="o">*</span> <span class="n">IAC</span>
            <span class="c1"># Return Values</span>
            <span class="k">return</span> <span class="n">Irms</span><span class="p">,</span> <span class="n">IAC</span><span class="p">,</span> <span class="n">K</span>
        <span class="k">elif</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">omega</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"ERROR: Inappropriate Arguments Provided."</span><span class="p">)</span>
        <span class="c1"># Calculate Instantaneous if all angular values provided</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Convert Degrees to Radians</span>
            <span class="n">omega</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="c1"># Calculate T</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">X</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span>  <span class="c1"># seconds</span>
            <span class="c1"># Calculate iAC and iDC</span>
            <span class="n">iAC</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">V</span> <span class="o">/</span> <span class="n">Z</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span>
            <span class="n">iDC</span> <span class="o">=</span> <span class="o">-</span><span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">V</span> <span class="o">/</span> <span class="n">Z</span> <span class="o">*</span> \
                <span class="n">_np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">iAC</span> <span class="o">+</span> <span class="n">iDC</span>
            <span class="c1"># Return Values</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">iAC</span><span class="p">,</span> <span class="n">iDC</span><span class="p">,</span> <span class="n">T</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"ERROR: Inappropriate Arguments Provided.</span><span class="se">\n</span><span class="s2">"</span> <span class="o">+</span>
                         <span class="s2">"Must provide both t and f or neither."</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Iac</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">V</span> <span class="o">/</span> <span class="n">Z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Iac</span></div>


<span class="c1"># Alias to original Name</span>
<span class="n">iscrl</span> <span class="o">=</span> <span class="n">short_circuit_current</span>


<span class="c1"># Define Voltage Divider Calculator</span>
<div class="viewcode-block" id="voltdiv"><a class="viewcode-back" href="../api/electricpy.voltdiv.html#electricpy.voltdiv">[docs]</a><span class="k">def</span> <span class="nf">voltdiv</span><span class="p">(</span><span class="n">Vin</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">Rload</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Electrical Voltage Divider Function.</span>

<span class="sd">    This function is designed to calculate the output</span>
<span class="sd">    voltage of a voltage divider given the input voltage,</span>
<span class="sd">    the resistances (or impedances) and the load resistance</span>
<span class="sd">    (or impedance) if present.</span>

<span class="sd">    .. math:: V_{out} = V_{in} * \frac{R_2}{R_1+R_2}</span>

<span class="sd">    .. math:: V_{out}=V_{in}*\frac{R_2||R_{load}}{R_1+(R_2||R_{load})}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Vin:    float</span>
<span class="sd">            The Input Voltage, may be real or complex</span>
<span class="sd">    R1:     float</span>
<span class="sd">            The top resistor of the divider (real or complex)</span>
<span class="sd">    R2:     float</span>
<span class="sd">            The bottom resistor of the divider, the one which</span>
<span class="sd">            the output voltage is measured across, may be</span>
<span class="sd">            either real or complex</span>
<span class="sd">    Rload:  float, optional</span>
<span class="sd">            The Load Resistor (or impedance), default=None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Vout:   float</span>
<span class="sd">            The Output voltage as measured across R2 and/or Rload</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import electricpy as ep</span>
<span class="sd">    &gt;&gt;&gt; ep.voltdiv(Vin=12, R1=4, R2=8)</span>
<span class="sd">    8.0</span>
<span class="sd">    &gt;&gt;&gt; ep.voltdiv(Vin=12, R1=6, R2=12, Rload=12) # R2 and Rload are parallel</span>
<span class="sd">    6.0</span>
<span class="sd">    """</span>
    <span class="c1"># Determine whether Rload is given</span>
    <span class="k">if</span> <span class="n">Rload</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># No Load Given</span>
        <span class="n">Vout</span> <span class="o">=</span> <span class="n">Vin</span> <span class="o">*</span> <span class="n">R2</span> <span class="o">/</span> <span class="p">(</span><span class="n">R1</span> <span class="o">+</span> <span class="n">R2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Load was given</span>
        <span class="n">Rp</span> <span class="o">=</span> <span class="n">R2</span> <span class="o">*</span> <span class="n">Rload</span> <span class="o">/</span> <span class="p">(</span><span class="n">R2</span> <span class="o">+</span> <span class="n">Rload</span><span class="p">)</span>
        <span class="n">Vout</span> <span class="o">=</span> <span class="n">Vin</span> <span class="o">*</span> <span class="n">Rp</span> <span class="o">/</span> <span class="p">(</span><span class="n">R1</span> <span class="o">+</span> <span class="n">Rp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Vout</span></div>


<span class="c1"># Define Current Divider Calculator</span>
<div class="viewcode-block" id="curdiv"><a class="viewcode-back" href="../api/electricpy.curdiv.html#electricpy.curdiv">[docs]</a><span class="k">def</span> <span class="nf">curdiv</span><span class="p">(</span><span class="n">Ri</span><span class="p">,</span> <span class="n">Rset</span><span class="p">,</span> <span class="n">Vin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Iin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Vout</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Electrical Current Divider Function.</span>

<span class="sd">    This function is disigned to accept the input current, or input</span>
<span class="sd">    voltage to a resistor (or impedance) network of parallel resistors</span>
<span class="sd">    (impedances) and calculate the current through a particular element.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Ri:         float</span>
<span class="sd">                The Particular Resistor of Interest, should not be included in</span>
<span class="sd">                the tuple passed to Rset.</span>
<span class="sd">    Rset:       float</span>
<span class="sd">                Tuple of remaining resistances (impedances) in network.</span>
<span class="sd">    Vin:        float, optional</span>
<span class="sd">                The input voltage for the system, default=None</span>
<span class="sd">    Iin:        float, optional</span>
<span class="sd">                The input current for the system, default=None</span>
<span class="sd">    Vout:       bool, optional</span>
<span class="sd">                Control argument to enable return of the voltage across the</span>
<span class="sd">                resistor (impedance) of interest (Ri)</span>
<span class="sd">    combine:    bool, optional</span>
<span class="sd">                Control argument to force resistance combination. default=True</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Opt1 - Ii:          The Current through the resistor (impedance) of interest</span>
<span class="sd">    Opt2 - (Ii,Vi):     The afore mentioned current, and voltage across the</span>
<span class="sd">                        resistor (impedance) of interest</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from electricpy.constants import k</span>
<span class="sd">    &gt;&gt;&gt; import electricpy as ep</span>
<span class="sd">    &gt;&gt;&gt; ep.curdiv(Ri=1*k, Rset=(1*k, 1*k), Iin=12) # 12-amps, split three ways</span>
<span class="sd">    4.0</span>
<span class="sd">    &gt;&gt;&gt; ep.curdiv(Ri=1*k, Rset=(1*k, 1*k), Iin=12, Vout=True) # Find Voltage</span>
<span class="sd">    (4.0, 4000.0)</span>
<span class="sd">    """</span>
    <span class="c1"># Validate Tuple</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Rset</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">Rset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Rset</span><span class="p">,)</span>  <span class="c1"># Set as Tuple</span>
    <span class="c1"># Calculate The total impedance</span>
    <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
        <span class="c1"># Combine tuples, then calculate total resistance</span>
        <span class="n">Rtot</span> <span class="o">=</span> <span class="n">parallelz</span><span class="p">(</span><span class="n">Rset</span> <span class="o">+</span> <span class="p">(</span><span class="n">Ri</span><span class="p">,))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Rtot</span> <span class="o">=</span> <span class="n">parallelz</span><span class="p">(</span><span class="n">Rset</span><span class="p">)</span>
    <span class="c1"># Determine Whether Input was given as Voltage or Current</span>
    <span class="k">if</span> <span class="n">Vin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Iin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Vin Provided</span>
        <span class="n">Iin</span> <span class="o">=</span> <span class="n">Vin</span> <span class="o">/</span> <span class="n">Rtot</span>  <span class="c1"># Calculate total current</span>
        <span class="n">Ii</span> <span class="o">=</span> <span class="n">Iin</span> <span class="o">*</span> <span class="n">Rtot</span> <span class="o">/</span> <span class="n">Ri</span>  <span class="c1"># Calculate the current of interest</span>
    <span class="k">elif</span> <span class="n">Vin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Iin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Iin provided</span>
        <span class="n">Ii</span> <span class="o">=</span> <span class="n">Iin</span> <span class="o">*</span> <span class="n">Rtot</span> <span class="o">/</span> <span class="n">Ri</span>  <span class="c1"># Calculate the current of interest</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"ERROR: Too many or too few constraints provided."</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Vout</span><span class="p">:</span>  <span class="c1"># Asked for voltage across resistor of interest</span>
        <span class="n">Vi</span> <span class="o">=</span> <span class="n">Ii</span> <span class="o">*</span> <span class="n">Ri</span>
        <span class="k">return</span> <span class="n">Ii</span><span class="p">,</span> <span class="n">Vi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Ii</span></div>


<span class="c1"># Induction Machine Slip</span>
<div class="viewcode-block" id="induction_machine_slip"><a class="viewcode-back" href="../api/electricpy.induction_machine_slip.html#electricpy.induction_machine_slip">[docs]</a><span class="k">def</span> <span class="nf">induction_machine_slip</span><span class="p">(</span><span class="n">Nr</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">poles</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Induction Machine slip calculator.</span>

<span class="sd">    This function is used to calculate the slip of an induction machine.</span>

<span class="sd">    .. math:: slip = 1 - \frac{Nr}{120*frac{freq}{poles}}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Nr: float, Induction Machine Speed (in rpm)</span>
<span class="sd">    freq: int, Supply AC frequency, default=60</span>
<span class="sd">    poles: Number of poles inside Induction Machine, default=4</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    slip: float, Induction Machine forward Slip</span>
<span class="sd">    """</span>
    <span class="n">Ns</span> <span class="o">=</span> <span class="p">(</span><span class="mi">120</span> <span class="o">*</span> <span class="n">freq</span><span class="p">)</span> <span class="o">/</span> <span class="n">poles</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Ns</span> <span class="o">-</span> <span class="n">Nr</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Ns</span><span class="p">)</span></div>


<span class="c1"># Define Function to Evaluate Resistance Needed for LED</span>
<div class="viewcode-block" id="led_resistor"><a class="viewcode-back" href="../api/electricpy.led_resistor.html#electricpy.led_resistor">[docs]</a><span class="k">def</span> <span class="nf">led_resistor</span><span class="p">(</span><span class="n">Vsrc</span><span class="p">,</span> <span class="n">Vfwd</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">Ifwd</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    LED Resistor Calculator.</span>

<span class="sd">    This function will evaluate the necessary resistance value for a simple LED</span>
<span class="sd">    circuit with a voltage source, resistor, and LED.</span>

<span class="sd">    .. math:: R_\text{LED} = \frac{V_\text{SRC} - V_\text{FWD}}{I_\text{FWD}}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Vsrc:   float</span>
<span class="sd">            Source voltage, as measured across both LED and resistor in circuit.</span>
<span class="sd">    Vfwd:   float, optional</span>
<span class="sd">            Forward voltage of LED (or series LEDs if available), default=2</span>
<span class="sd">    Ifwd:   float, optional</span>
<span class="sd">            Forward current of LEDs in milliamps, default=20 (milliamps)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R:      float</span>
<span class="sd">            The resistance value most appropriate for the LED circuit.</span>
<span class="sd">    """</span>
    <span class="c1"># Calculate and Return!</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vsrc</span> <span class="o">-</span> <span class="n">Vfwd</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Ifwd</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">R</span></div>


<span class="c1"># Define Instantaneous Power Calculator</span>
<div class="viewcode-block" id="instpower"><a class="viewcode-back" href="../api/electricpy.instpower.html#electricpy.instpower">[docs]</a><span class="k">def</span> <span class="nf">instpower</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Instantaneous Power Function.</span>

<span class="sd">    This function is designed to calculate the instantaneous power at a</span>
<span class="sd">    specified time t given the magnitudes of P and Q.</span>

<span class="sd">    .. math:: P_{inst} = P+P*cos(2*\omega*t)-Q*sin(2*\omega*t)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    P:      float</span>
<span class="sd">            Magnitude of Real Power</span>
<span class="sd">    Q:      float</span>
<span class="sd">            Magnitude of Reactive Power</span>
<span class="sd">    t:      float</span>
<span class="sd">            Time at which to evaluate</span>
<span class="sd">    freq:   float, optional</span>
<span class="sd">            System frequency (in Hz), default=60</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float:  Instantaneous Power at time t.</span>
<span class="sd">    """</span>
    <span class="c1"># Evaluate omega</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span>
    <span class="c1"># Calculate</span>
    <span class="n">Pinst</span> <span class="o">=</span> <span class="n">P</span> <span class="o">+</span> <span class="n">P</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">Q</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Pinst</span></div>


<span class="c1"># Define Delta-Wye Impedance Network Calculator</span>
<div class="viewcode-block" id="dynetz"><a class="viewcode-back" href="../api/electricpy.dynetz.html#electricpy.dynetz">[docs]</a><span class="k">def</span> <span class="nf">dynetz</span><span class="p">(</span><span class="n">delta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wye</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Delta-Wye Impedance Converter.</span>

<span class="sd">    This function is designed to act as the conversion utility</span>
<span class="sd">    to transform delta-connected impedance values to wye-</span>
<span class="sd">    connected and vice-versa.</span>

<span class="sd">    .. math::</span>
<span class="sd">       Z_{sum} = Z_{1/2} + Z_{2/3} + Z_{3/1}//</span>
<span class="sd">       Z_1 = \frac{Z_{1/2}*Z_{3/1}}{Z_{sum}}//</span>
<span class="sd">       Z_2 = \frac{Z_{1/2}*Z_{2/3}}{Z_{sum}}//</span>
<span class="sd">       Z_3 = \frac{Z_{2/3}*Z_{3/1}}{Z_{sum}}</span>

<span class="sd">    .. math::</span>
<span class="sd">       Z_{ms} = Z_1*Z_2 + Z_2*Z_3 + Z_3*Z_1//</span>
<span class="sd">       Z_{2/3} = \frac{Z_{ms}}{Z_1}//</span>
<span class="sd">       Z_{3/1} = \frac{Z_{ms}}{Z_2}//</span>
<span class="sd">       Z_{1/2} = \frac{Z_{ms}}{Z_3}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    delta:  tuple of float, exclusive</span>
<span class="sd">            Tuple of the delta-connected impedance values as:</span>
<span class="sd">            { Z12, Z23, Z31 }, default=None</span>
<span class="sd">    wye:    tuple of float, exclusive</span>
<span class="sd">            Tuple of the wye-connected impedance valuse as:</span>
<span class="sd">            { Z1, Z2, Z3 }, default=None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    delta-set:  tuple of float</span>
<span class="sd">                Delta-Connected impedance values { Z12, Z23, Z31 }</span>
<span class="sd">    wye-set:    tuple of float</span>
<span class="sd">                Wye-Connected impedance values { Z1, Z2, Z3 }</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">wye</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">"ERROR: Either delta or wye impedances must be specified."</span>
        <span class="p">)</span>
    <span class="c1"># Determine which set of impedances was provided</span>
    <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">wye</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Z12</span><span class="p">,</span> <span class="n">Z23</span><span class="p">,</span> <span class="n">Z31</span> <span class="o">=</span> <span class="n">delta</span>  <span class="c1"># Gather particular impedances</span>
        <span class="n">Zsum</span> <span class="o">=</span> <span class="n">Z12</span> <span class="o">+</span> <span class="n">Z23</span> <span class="o">+</span> <span class="n">Z31</span>  <span class="c1"># Find Sum</span>
        <span class="c1"># Calculate Wye Impedances</span>
        <span class="n">Z1</span> <span class="o">=</span> <span class="n">Z12</span> <span class="o">*</span> <span class="n">Z31</span> <span class="o">/</span> <span class="n">Zsum</span>
        <span class="n">Z2</span> <span class="o">=</span> <span class="n">Z12</span> <span class="o">*</span> <span class="n">Z23</span> <span class="o">/</span> <span class="n">Zsum</span>
        <span class="n">Z3</span> <span class="o">=</span> <span class="n">Z23</span> <span class="o">*</span> <span class="n">Z31</span> <span class="o">/</span> <span class="n">Zsum</span>
        <span class="n">Zset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Z1</span><span class="p">,</span> <span class="n">Z2</span><span class="p">,</span> <span class="n">Z3</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">round</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Zset</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">Zset</span><span class="p">,</span> <span class="nb">round</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Zset</span>  <span class="c1"># Return Wye Impedances</span>
    <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">wye</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Z1</span><span class="p">,</span> <span class="n">Z2</span><span class="p">,</span> <span class="n">Z3</span> <span class="o">=</span> <span class="n">wye</span>  <span class="c1"># Gather particular impedances</span>
        <span class="n">Zmultsum</span> <span class="o">=</span> <span class="n">Z1</span> <span class="o">*</span> <span class="n">Z2</span> <span class="o">+</span> <span class="n">Z2</span> <span class="o">*</span> <span class="n">Z3</span> <span class="o">+</span> <span class="n">Z3</span> <span class="o">*</span> <span class="n">Z1</span>
        <span class="n">Z23</span> <span class="o">=</span> <span class="n">Zmultsum</span> <span class="o">/</span> <span class="n">Z1</span>
        <span class="n">Z31</span> <span class="o">=</span> <span class="n">Zmultsum</span> <span class="o">/</span> <span class="n">Z2</span>
        <span class="n">Z12</span> <span class="o">=</span> <span class="n">Zmultsum</span> <span class="o">/</span> <span class="n">Z3</span>
        <span class="n">Zset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Z12</span><span class="p">,</span> <span class="n">Z23</span><span class="p">,</span> <span class="n">Z31</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">round</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Zset</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">Zset</span><span class="p">,</span> <span class="nb">round</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Zset</span>  <span class="c1"># Return Delta Impedances</span></div>


<span class="c1"># calculating impedance of bridge network</span>
<div class="viewcode-block" id="bridge_impedance"><a class="viewcode-back" href="../api/electricpy.bridge_impedance.html#electricpy.bridge_impedance">[docs]</a><span class="k">def</span> <span class="nf">bridge_impedance</span><span class="p">(</span><span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">,</span> <span class="n">z3</span><span class="p">,</span> <span class="n">z4</span><span class="p">,</span> <span class="n">z5</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Bridge Impedance Calculator.</span>

<span class="sd">    The following condition describing the Wheatstone Bridge is utilized to</span>
<span class="sd">    ensure that current through `z5` will be zero.</span>

<span class="sd">    .. math:: z1 \cdot z3 = z2 \cdot z4</span>

<span class="sd">    .. image:: /static/WheatstoneBridgeCircuit.png</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z1:     [float, complex]</span>
<span class="sd">            Bridge impedance 1iscrl</span>
<span class="sd">    z2:     [float, complex]</span>
<span class="sd">            Bridge impedance 2</span>
<span class="sd">    z3:     [float, complex]</span>
<span class="sd">            Bridge impedance 3</span>
<span class="sd">    z4:     [float, complex]</span>
<span class="sd">            Bridge impedance 4</span>
<span class="sd">    z5:     [float, complex]</span>
<span class="sd">            Detector impedance or impedance between two bridge branches</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    effective bridge impedance</span>

<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">z1</span> <span class="o">*</span> <span class="n">z3</span> <span class="o">==</span> <span class="n">z2</span> <span class="o">*</span> <span class="n">z4</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">z1</span> <span class="o">+</span> <span class="n">z2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">z3</span> <span class="o">+</span> <span class="n">z4</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">z1</span> <span class="o">+</span> <span class="n">z2</span> <span class="o">+</span> <span class="n">z3</span> <span class="o">+</span> <span class="n">z4</span><span class="p">)</span>
    <span class="n">za</span><span class="p">,</span> <span class="n">zb</span><span class="p">,</span> <span class="n">zc</span> <span class="o">=</span> <span class="n">dynetz</span><span class="p">(</span><span class="n">delta</span><span class="o">=</span><span class="p">(</span><span class="n">z1</span><span class="p">,</span> <span class="n">z5</span><span class="p">,</span> <span class="n">z4</span><span class="p">))</span>
    <span class="n">ze1</span> <span class="o">=</span> <span class="n">zb</span> <span class="o">+</span> <span class="n">z2</span>
    <span class="n">ze2</span> <span class="o">=</span> <span class="n">zc</span> <span class="o">+</span> <span class="n">z3</span>
    <span class="k">return</span> <span class="n">za</span> <span class="o">+</span> <span class="p">(</span><span class="n">ze1</span> <span class="o">*</span> <span class="n">ze2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ze1</span> <span class="o">+</span> <span class="n">ze2</span><span class="p">)</span></div>


<span class="c1"># Define Single Line Power Flow Calculator</span>
<div class="viewcode-block" id="powerflow"><a class="viewcode-back" href="../api/electricpy.powerflow.html#electricpy.powerflow">[docs]</a><span class="k">def</span> <span class="nf">powerflow</span><span class="p">(</span><span class="n">Vsend</span><span class="p">,</span> <span class="n">Vrec</span><span class="p">,</span> <span class="n">Xline</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Approximated Power-Flow Calculator.</span>

<span class="sd">    This function is designed to calculate the ammount of real</span>
<span class="sd">    power transferred from the sending end to the recieving end</span>
<span class="sd">    of an electrical line given the sending voltage (complex),</span>
<span class="sd">    the receiving voltage (complex) and the line impedance.</span>

<span class="sd">    .. math::</span>
<span class="sd">       P_{flow}=\frac{|V_{send}|*|V_{rec}|}{X_{line}}*sin(\theta_{send}</span>
<span class="sd">       -\theta_{rec})</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Vsend:      complex</span>
<span class="sd">                The sending-end voltage, should be complex</span>
<span class="sd">    Vrec:       complex</span>
<span class="sd">                The receiving-end voltage, should be complex</span>
<span class="sd">    Xline:      float</span>
<span class="sd">                The line admitance, should be float</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pflow:      float</span>
<span class="sd">                The Real power transferred from sending-end to</span>
<span class="sd">                receiving-end, positive values denote power</span>
<span class="sd">                flow from send to receive, negative values</span>
<span class="sd">                denote vice-versa.</span>
<span class="sd">    """</span>
    <span class="c1"># Evaluate the Input Terms</span>
    <span class="n">Vs</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Vsend</span><span class="p">)</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">_c</span><span class="o">.</span><span class="n">phase</span><span class="p">(</span><span class="n">Vsend</span><span class="p">)</span>
    <span class="n">Vr</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Vrec</span><span class="p">)</span>
    <span class="n">dr</span> <span class="o">=</span> <span class="n">_c</span><span class="o">.</span><span class="n">phase</span><span class="p">(</span><span class="n">Vrec</span><span class="p">)</span>
    <span class="c1"># Calculate Power Flow</span>
    <span class="n">pflow</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vs</span> <span class="o">*</span> <span class="n">Vr</span><span class="p">)</span> <span class="o">/</span> <span class="n">Xline</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ds</span> <span class="o">-</span> <span class="n">dr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pflow</span></div>


<span class="c1"># Define Impedance From Power and X/R</span>
<div class="viewcode-block" id="zsource"><a class="viewcode-back" href="../api/electricpy.zsource.html#electricpy.zsource">[docs]</a><span class="k">def</span> <span class="nf">zsource</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">XoR</span><span class="p">,</span> <span class="n">Sbase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Vbase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">perunit</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Source Impedance Calculator.</span>

<span class="sd">    Used to calculate the source impedance given the apparent power</span>
<span class="sd">    magnitude and the X/R ratio.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S:          float</span>
<span class="sd">                The (rated) apparent power magnitude of the source.</span>
<span class="sd">                This may also be refferred to as the "Short-Circuit MVA"</span>
<span class="sd">    V:          float</span>
<span class="sd">                The (rated) voltage of the source terminals, not</span>
<span class="sd">                specifically identified as either Line-to-Line or Line-to-</span>
<span class="sd">                Neutral.</span>
<span class="sd">    XoR:        float</span>
<span class="sd">                The X/R ratio rated for the source, may optionally be a list</span>
<span class="sd">                of floats to accomidate sequence impedances or otherwise.</span>
<span class="sd">    Sbase:      float, optional</span>
<span class="sd">                The per-unit base for the apparent power. If set to</span>
<span class="sd">                None, will automatically force Sbase to equal S.</span>
<span class="sd">                If set to True will treat S as the per-unit value.</span>
<span class="sd">    Vbase:      float, optional</span>
<span class="sd">                The per-unit base for the terminal voltage. If set to</span>
<span class="sd">                None, will automaticlaly force Vbase to equal V. If</span>
<span class="sd">                set to True, will treat V as the per-unit value.</span>
<span class="sd">    perunit:    boolean, optional</span>
<span class="sd">                Control value to enable the return of output in per-</span>
<span class="sd">                unit base. default=True</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Zsource_pu: complex</span>
<span class="sd">                The per-unit evaluation of the source impedance.</span>
<span class="sd">                Will be returned in ohmic (not per-unit) value if</span>
<span class="sd">                *perunit* argument is specified as False.</span>
<span class="sd">    """</span>
    <span class="c1"># Force Sbase and Vbase if needed</span>
    <span class="k">if</span> <span class="n">Vbase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Vbase</span> <span class="o">=</span> <span class="n">V</span>
    <span class="k">if</span> <span class="n">Sbase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Sbase</span> <span class="o">=</span> <span class="n">S</span>
    <span class="c1"># Prevent scaling if per-unit already applied</span>
    <span class="k">if</span> <span class="n">Vbase</span><span class="p">:</span>
        <span class="n">Vbase</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">Sbase</span><span class="p">:</span>
        <span class="n">Sbase</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1"># Set to per-unit</span>
    <span class="n">Spu</span> <span class="o">=</span> <span class="n">S</span> <span class="o">/</span> <span class="n">Sbase</span>
    <span class="n">Vpu</span> <span class="o">=</span> <span class="n">V</span> <span class="o">/</span> <span class="n">Vbase</span>
    <span class="c1"># Evaluate Zsource Magnitude</span>
    <span class="n">Zsource_pu</span> <span class="o">=</span> <span class="n">Vpu</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">Spu</span>
    <span class="c1"># Evaluate the angle</span>
    <span class="n">nu</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">XoR</span><span class="p">))</span>
    <span class="c1"># Conditionally Evaluate Phasor Impedance</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">Zsource_pu</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">nu</span><span class="p">:</span>
            <span class="n">Zsource_pu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">phasors</span><span class="p">(</span><span class="n">Zsource_pu</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Zsource_pu</span> <span class="o">=</span> <span class="n">phasors</span><span class="p">(</span><span class="n">Zsource_pu</span><span class="p">,</span> <span class="n">nu</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">perunit</span><span class="p">:</span>
        <span class="n">Zsource</span> <span class="o">=</span> <span class="n">Zsource_pu</span> <span class="o">*</span> <span class="n">Vbase</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">Sbase</span>
        <span class="k">return</span> <span class="n">Zsource</span>
    <span class="k">return</span> <span class="n">Zsource_pu</span></div>


<span class="c1"># Define Impedance Decomposer</span>
<div class="viewcode-block" id="zdecompose"><a class="viewcode-back" href="../api/electricpy.zdecompose.html#electricpy.zdecompose">[docs]</a><span class="k">def</span> <span class="nf">zdecompose</span><span class="p">(</span><span class="n">Zmag</span><span class="p">,</span> <span class="n">XoR</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Impedance Decomposition Function.</span>

<span class="sd">    A function to decompose the impedance magnitude into its</span>
<span class="sd">    corresponding resistance and reactance using the X/R ratio.</span>

<span class="sd">    It is possible to "neglect" R, or make it a very small number;</span>
<span class="sd">    this is done by setting the X/R ratio to a very large number</span>
<span class="sd">    (X being much larger than R).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Zmag:       float</span>
<span class="sd">                The magnitude of the impedance.</span>
<span class="sd">    XoR:        float</span>
<span class="sd">                The X/R ratio (reactance over impedance).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R:          float</span>
<span class="sd">                The resistance (in ohms)</span>
<span class="sd">    X:          float</span>
<span class="sd">                The reactance (in ohms)</span>
<span class="sd">    """</span>
    <span class="c1"># Evaluate Resistance</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">Zmag</span> <span class="o">/</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">XoR</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Evaluate Reactance</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">R</span> <span class="o">*</span> <span class="n">XoR</span>
    <span class="c1"># Return</span>
    <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">X</span></div>


<span class="c1"># Define Power Reactance Calculator</span>
<div class="viewcode-block" id="powerimpedance"><a class="viewcode-back" href="../api/electricpy.powerimpedance.html#electricpy.powerimpedance">[docs]</a><span class="k">def</span> <span class="nf">powerimpedance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">PF</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Impedance from Apparent Power Formula.</span>

<span class="sd">    Function to determine the ohmic resistance/reactance</span>
<span class="sd">    (impedance) represented by the apparent power (S).</span>

<span class="sd">    .. math:: R = \frac{V^2}{P} \hspace{2cm} X = \frac{V^2}{Q}</span>
<span class="sd">       :label: series-resistance</span>

<span class="sd">    .. math:: Z = \left(\frac{V^2}{S}\right)^*</span>
<span class="sd">       :label: series-impedance</span>

<span class="sd">    .. math:: Z = \left(\frac{V^2}{(3*S)}\right)^*</span>
<span class="sd">       :label: parallel</span>

<span class="sd">    This function can evaluate the component values for</span>
<span class="sd">    both series :eq:`series-resistance`/:eq:`series-impedance`</span>
<span class="sd">    and parallel :eq:`parallel` connected circuits.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S:          complex, float</span>
<span class="sd">                The apparent power of the passive element,</span>
<span class="sd">                may be purely resistive or purely reactive.</span>
<span class="sd">    V:          float</span>
<span class="sd">                The operating voltage of the passive element.</span>
<span class="sd">                Note that this is specifically not Line-Line or</span>
<span class="sd">                Line-Neutral voltage, rather the voltage of the</span>
<span class="sd">                element.</span>
<span class="sd">    PF:         float, optional</span>
<span class="sd">                The operating Power-Factor, should be specified</span>
<span class="sd">                if S is given as a float (not complex). Positive</span>
<span class="sd">                PF correlates to lagging, negative to leading.</span>
<span class="sd">                default=None</span>
<span class="sd">    parallel:   bool, optional</span>
<span class="sd">                Control point to specify whether the ohmic</span>
<span class="sd">                impedance should be returned as series components</span>
<span class="sd">                (False opt.) or parallel components (True opt.).</span>
<span class="sd">    terms:      bool, optional</span>
<span class="sd">                Control point to specify whether return should</span>
<span class="sd">                be made as resistance and reactance, or simply</span>
<span class="sd">                the complex impedance. Setting of False will</span>
<span class="sd">                return complex impedance, setting of True will</span>
<span class="sd">                return individual components (R, X).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R:          float</span>
<span class="sd">                The ohmic resistance required to consume the</span>
<span class="sd">                specified apparent power (S) at the rated</span>
<span class="sd">                voltage (V).</span>
<span class="sd">    X:          float</span>
<span class="sd">                The ohmic reactance required to consume the</span>
<span class="sd">                specified apparent power (S) at the rated</span>
<span class="sd">                voltage (V).</span>
<span class="sd">    """</span>
    <span class="c1"># Condition Inputs</span>
    <span class="n">V</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="c1"># Test for Parallel Component Option and Evaluate</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span> <span class="ow">or</span> <span class="n">PF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">PF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Evaluate Elements</span>
            <span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">PF</span> <span class="o">=</span> <span class="n">powerset</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">PF</span><span class="o">=</span><span class="n">PF</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">real</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">imag</span>
        <span class="c1"># Compute Elements</span>
        <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
            <span class="n">Zp</span> <span class="o">=</span> <span class="n">V</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">Q</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Zp</span> <span class="o">=</span> <span class="n">V</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">Q</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">Zp</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">real</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">imag</span>
        <span class="c1"># Conditionally Return as Impedance</span>
        <span class="k">if</span> <span class="n">terms</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Z</span>
    <span class="c1"># Not Complex (just R)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">V</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">S</span>
    <span class="k">return</span> <span class="n">R</span></div>


<span class="c1"># Define function to find VDC setpoint</span>
<div class="viewcode-block" id="vscdcbus"><a class="viewcode-back" href="../api/electricpy.vscdcbus.html#electricpy.vscdcbus">[docs]</a><span class="k">def</span> <span class="nf">vscdcbus</span><span class="p">(</span><span class="n">VLL</span><span class="p">,</span> <span class="n">Zs</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mmax</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Voltage Sourced Converter DC Bus Voltage Function.</span>

<span class="sd">    The purpose of this function is to calculate the</span>
<span class="sd">    required DC-bus voltage for a Voltage-Sourced-</span>
<span class="sd">    Converter (VSC) given the desired P/Q parameters</span>
<span class="sd">    and the known source impedance (Vs) of the VSC.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    VLL:    complex</span>
<span class="sd">            Line-to-Line voltage on the line-side of</span>
<span class="sd">            the source impedance.</span>
<span class="sd">    Zs:     complex</span>
<span class="sd">            The source impedance of the VSC</span>
<span class="sd">    P:      float</span>
<span class="sd">            The desired real-power output</span>
<span class="sd">    Q:      float, optional</span>
<span class="sd">            The desired reactive-power output, default=0</span>
<span class="sd">    mmax:   float, optional</span>
<span class="sd">            The maximum of the m value for the converter</span>
<span class="sd">            default=0.8</span>
<span class="sd">    debug:  bool, optional</span>
<span class="sd">            Control value to enable printing stages of</span>
<span class="sd">            the calculation, default=False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    VDC:    float</span>
<span class="sd">            The DC bus voltage.</span>
<span class="sd">    """</span>
    <span class="c1"># Determine the Load Current</span>
    <span class="n">Iload</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">conj</span><span class="p">((</span><span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">Q</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">VLL</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
    <span class="c1"># Evaluate the Terminal Voltage</span>
    <span class="n">Vtln</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">VLL</span> <span class="o">/</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">Iload</span> <span class="o">*</span> <span class="n">Zs</span><span class="p">)</span>
    <span class="c1"># Find the Peak Terminal Voltage</span>
    <span class="n">Vtpk</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">Vtln</span>
    <span class="c1"># Calculate the VDC value</span>
    <span class="n">VDC</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Vtpk</span> <span class="o">/</span> <span class="n">mmax</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Iload"</span><span class="p">,</span> <span class="n">Iload</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Vtln"</span><span class="p">,</span> <span class="n">Vtln</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Vtpk"</span><span class="p">,</span> <span class="n">Vtpk</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"VDC"</span><span class="p">,</span> <span class="n">VDC</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">VDC</span></div>


<span class="c1"># Define kp/ki/w0L calculating function</span>
<div class="viewcode-block" id="vscgains"><a class="viewcode-back" href="../api/electricpy.vscgains.html#electricpy.vscgains">[docs]</a><span class="k">def</span> <span class="nf">vscgains</span><span class="p">(</span><span class="n">Rs</span><span class="p">,</span> <span class="n">Ls</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Voltage Sourced Converter Gains Calculator.</span>

<span class="sd">    This function is designed to calculate the kp, ki,</span>
<span class="sd">    and omega-not-L values for a Phase-Lock-Loop based VSC.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Rs:     float</span>
<span class="sd">            The equiv-resistance (in ohms) of the VSC</span>
<span class="sd">    Ls:     float</span>
<span class="sd">            The equiv-inductance (in Henrys) of the VSC</span>
<span class="sd">    tau:    float, optional</span>
<span class="sd">            The desired time-constant, default=0.005</span>
<span class="sd">    freq:   float, optional</span>
<span class="sd">            The system frequency (in Hz), default=60</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kp:     float</span>
<span class="sd">            The Kp-Gain Value</span>
<span class="sd">    ki:     float</span>
<span class="sd">            The Ki-Gain Value</span>
<span class="sd">    w0L:    float</span>
<span class="sd">            The omega-not-L gain value</span>
<span class="sd">    """</span>
    <span class="c1"># Calculate kp</span>
    <span class="n">kp</span> <span class="o">=</span> <span class="n">Ls</span> <span class="o">/</span> <span class="n">tau</span>
    <span class="c1"># Calculate ki</span>
    <span class="n">ki</span> <span class="o">=</span> <span class="n">kp</span> <span class="o">*</span> <span class="n">Rs</span> <span class="o">/</span> <span class="n">Ls</span>
    <span class="c1"># Calculate w0L</span>
    <span class="n">w0L</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">Ls</span>
    <span class="k">return</span> <span class="n">kp</span><span class="p">,</span> <span class="n">ki</span><span class="p">,</span> <span class="n">w0L</span></div>


<span class="c1"># Define Peak Calculator</span>
<div class="viewcode-block" id="peak"><a class="viewcode-back" href="../api/electricpy.peak.html#electricpy.peak">[docs]</a><span class="k">def</span> <span class="nf">peak</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Sinusoid RMS to Peak Converter.</span>

<span class="sd">    Provides a readable format to convert an RMS (Root-Mean-Square) value to its</span>
<span class="sd">    peak representation. Performs a simple multiplication with the square-root</span>
<span class="sd">    of two.</span>

<span class="sd">    .. math:: V_{\text{peak}} = \sqrt{2} \cdot V_{\text{RMS}}</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import electricpy as ep</span>
<span class="sd">    &gt;&gt;&gt; ep.peak(120)</span>
<span class="sd">    169.7056274847714</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">val</span></div>


<span class="c1"># Define RMS Calculator</span>
<div class="viewcode-block" id="rms"><a class="viewcode-back" href="../api/electricpy.rms.html#electricpy.rms">[docs]</a><span class="k">def</span> <span class="nf">rms</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Sinusoid Peak to RMS Converter.</span>

<span class="sd">    Provides a readable format to convert a peak value to its RMS</span>
<span class="sd">    (Root-Mean-Square) representation. Performs a simple division by the</span>
<span class="sd">    square-root of two.</span>

<span class="sd">    .. math:: V_{\text{RMS}} = \frac{V_{\text{peak}}}{\sqrt{2}}</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import electricpy as ep</span>
<span class="sd">    &gt;&gt;&gt; ep.rms(169.7)</span>
<span class="sd">    119.99602076735711</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">val</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span></div>


<span class="c1"># Define Normalized Power Spectrum Function</span>
<div class="viewcode-block" id="wrms"><a class="viewcode-back" href="../api/electricpy.wrms.html#electricpy.wrms">[docs]</a><span class="k">def</span> <span class="nf">wrms</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">dw</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">NN</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">quad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
         <span class="n">title</span><span class="o">=</span><span class="s2">"Power Density Spectrum"</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    WRMS Function.</span>

<span class="sd">    This function is designed to calculate the RMS bandwidth (Wrms) using a</span>
<span class="sd">    numerical process.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func:       function</span>
<span class="sd">                The callable function to use for evaluation</span>
<span class="sd">    dw:         float, optional</span>
<span class="sd">                The delta-omega to be used, default=0.1</span>
<span class="sd">    NN:         int, optional</span>
<span class="sd">                The total number of points, default=100</span>
<span class="sd">    quad:       bool, optional</span>
<span class="sd">                Control value to enable use of integrals</span>
<span class="sd">                default=False</span>
<span class="sd">    plot:       bool, optional</span>
<span class="sd">                Control to enable plotting, default=True</span>
<span class="sd">    title:      string, optional</span>
<span class="sd">                Title displayed with plot,</span>
<span class="sd">                default="Power Density Spectrum"</span>
<span class="sd">    round:      int, optional</span>
<span class="sd">                Control to round the Wrms on plot,</span>
<span class="sd">                default=3</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    W:          float</span>
<span class="sd">                Calculated RMS Bandwidth (rad/sec)</span>
<span class="sd">    """</span>
    <span class="c1"># Define omega</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">NN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dw</span><span class="p">,</span> <span class="n">NN</span><span class="p">)</span>
    <span class="c1"># Initialize Fraction Terms</span>
    <span class="n">Stot</span> <span class="o">=</span> <span class="n">Sw2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Power Density Spectrum</span>
    <span class="n">Sxx</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NN</span><span class="p">):</span>
        <span class="c1"># Calculate Power Density Spectrum</span>
        <span class="n">Sxx</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Sxx</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
        <span class="n">Stot</span> <span class="o">=</span> <span class="n">Stot</span> <span class="o">+</span> <span class="n">Sxx</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">Sw2</span> <span class="o">=</span> <span class="n">Sw2</span> <span class="o">+</span> <span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">Sxx</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">quad</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">intf</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">w</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">func</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

        <span class="n">num</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">inf</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">inf</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Calculate W</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Calculate W</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Sw2</span> <span class="o">/</span> <span class="n">Stot</span><span class="p">)</span>
    <span class="n">Wr</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="nb">round</span><span class="p">)</span>
    <span class="c1"># Plot Upon Request</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">_plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">Sxx</span><span class="p">)</span>
        <span class="n">_plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="c1"># Evaluate Text Location</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mf">0.65</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mf">0.80</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">Sxx</span><span class="p">)</span>
        <span class="n">_plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">"Wrms: "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">Wr</span><span class="p">))</span>
        <span class="n">_plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="c1"># Return Calculated RMS Bandwidth</span>
    <span class="k">return</span> <span class="n">W</span></div>


<span class="c1"># Define Hartley's Equation for Data Capacity</span>
<div class="viewcode-block" id="hartleydata"><a class="viewcode-back" href="../api/electricpy.hartleydata.html#electricpy.hartleydata">[docs]</a><span class="k">def</span> <span class="nf">hartleydata</span><span class="p">(</span><span class="n">BW</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Hartley Data Function.</span>

<span class="sd">    Function to calculate Hartley's Law, the maximum data rate achievable for</span>
<span class="sd">    a given noiseless channel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    BW:         float</span>
<span class="sd">                Bandwidth of the data channel.</span>
<span class="sd">    M:          float</span>
<span class="sd">                Number of signal levels.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C:          float</span>
<span class="sd">                Capacity of channel (in bits per second)</span>
<span class="sd">    """</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">BW</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span></div>


<span class="c1"># Define Shannon's Equation For Data Capacity</span>
<div class="viewcode-block" id="shannondata"><a class="viewcode-back" href="../api/electricpy.shannondata.html#electricpy.shannondata">[docs]</a><span class="k">def</span> <span class="nf">shannondata</span><span class="p">(</span><span class="n">BW</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Shannon Data Function.</span>

<span class="sd">    Function to calculate the maximum data rate that may be achieved given a</span>
<span class="sd">    data channel and signal/noise characteristics using Shannon's equation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    BW:         float</span>
<span class="sd">                Bandwidth of the data channel.</span>
<span class="sd">    S:          float</span>
<span class="sd">                Signal strength (in Watts).</span>
<span class="sd">    N:          float</span>
<span class="sd">                Noise strength (in Watts).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C:          float</span>
<span class="sd">                Capacity of channel (in bits per second)</span>
<span class="sd">    """</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">BW</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">S</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span></div>


<span class="c1"># Define Per-Unit Impedance Formula</span>
<div class="viewcode-block" id="zpu"><a class="viewcode-back" href="../api/electricpy.zpu.html#electricpy.zpu">[docs]</a><span class="k">def</span> <span class="nf">zpu</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">VLL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">VLN</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Per-Unit Impedance Evaluator.</span>

<span class="sd">    Evaluates the per-unit impedance value given the per-unit power and voltage</span>
<span class="sd">    bases.</span>

<span class="sd">    .. math:: Z_{pu}=\frac{V_{LL}^2}{S}</span>

<span class="sd">    .. math:: Z_{pu}=\frac{(\sqrt{3}*V_{LN})^2}{S}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S:          float</span>
<span class="sd">                The per-unit power base.</span>
<span class="sd">    VLL:        float, optional</span>
<span class="sd">                The Line-to-Line Voltage; default=None</span>
<span class="sd">    VLN:        float, optional</span>
<span class="sd">                The Line-to-Neutral Voltage; default=None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Zbase:      float</span>
<span class="sd">                The per-unit impedance base.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">VLL</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">VLN</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"ERROR: One voltage must be provided."</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">VLL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">VLL</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">S</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">VLN</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">S</span></div>


<span class="c1"># Define Per-Unit Current Formula</span>
<div class="viewcode-block" id="ipu"><a class="viewcode-back" href="../api/electricpy.ipu.html#electricpy.ipu">[docs]</a><span class="k">def</span> <span class="nf">ipu</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">VLL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">VLN</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">V1phs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Per-Unit Current Evaluator.</span>

<span class="sd">    Evaluates the per-unit current value given the per-unit</span>
<span class="sd">    power and voltage bases.</span>

<span class="sd">    .. math:: I_{pu}=\frac{S}{\sqrt{3}*V_{LL}}</span>

<span class="sd">    .. math:: I_{pu}=\frac{S}{3*V_{LN}}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S:          float</span>
<span class="sd">                The per-unit power base.</span>
<span class="sd">    VLL:        float, optional</span>
<span class="sd">                The Line-to-Line Voltage; default=None</span>
<span class="sd">    VLN:        float, optional</span>
<span class="sd">                The Line-to-Neutral Voltage; default=None</span>
<span class="sd">    V1phs:      float, optional</span>
<span class="sd">                The voltage base of the single phase system.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Ibase:      float</span>
<span class="sd">                The per-unit current base.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">VLL</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">VLN</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"ERROR: One voltage must be provided."</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">VLL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span> <span class="o">/</span> <span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">VLL</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">VLN</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">VLN</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span> <span class="o">/</span> <span class="n">V1phs</span></div>


<span class="c1"># Define Per-Unit Change of Base Function</span>
<div class="viewcode-block" id="puchgbase"><a class="viewcode-back" href="../api/electricpy.puchgbase.html#electricpy.puchgbase">[docs]</a><span class="k">def</span> <span class="nf">puchgbase</span><span class="p">(</span><span class="n">quantity</span><span class="p">,</span> <span class="n">puB_old</span><span class="p">,</span> <span class="n">puB_new</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Per-Unit Change of Base Function.</span>

<span class="sd">    Performs a per-unit change of base operation for the given</span>
<span class="sd">    value constrained by the old base and new base.</span>

<span class="sd">    .. math:: Z_{pu-new}=Z_{pu-old}*\frac{BASE_{OLD}}{BASE_{NEW}}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    quantity:   complex</span>
<span class="sd">                Current per-unit value in old base.</span>
<span class="sd">    puB_old:    float</span>
<span class="sd">                Old per-unit base.</span>
<span class="sd">    puB_new:    float</span>
<span class="sd">                New per-unit base.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pu_new:     complex</span>
<span class="sd">                New per-unit value.</span>
<span class="sd">    """</span>
    <span class="n">pu_new</span> <span class="o">=</span> <span class="n">quantity</span> <span class="o">*</span> <span class="n">puB_old</span> <span class="o">/</span> <span class="n">puB_new</span>
    <span class="k">return</span> <span class="n">pu_new</span></div>


<span class="c1"># Define Recomposition Function</span>
<div class="viewcode-block" id="zrecompose"><a class="viewcode-back" href="../api/electricpy.zrecompose.html#electricpy.zrecompose">[docs]</a><span class="k">def</span> <span class="nf">zrecompose</span><span class="p">(</span><span class="n">z_pu</span><span class="p">,</span> <span class="n">S3phs</span><span class="p">,</span> <span class="n">VLL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">VLN</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Impedance from Per-Unit System Evaluator.</span>

<span class="sd">    Function to reverse per-unit conversion and return the ohmic value</span>
<span class="sd">    of an impedance given its per-unit parameters of R and X (as Z).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z_pu:       complex</span>
<span class="sd">                The per-unit, complex value corresponding to the</span>
<span class="sd">                impedance</span>
<span class="sd">    S3phs:      float</span>
<span class="sd">                The total three-phase power rating of the system.</span>
<span class="sd">    VLL:        float, optional</span>
<span class="sd">                The Line-to-Line Voltage; default=None</span>
<span class="sd">    VLN:        float, optional</span>
<span class="sd">                The Line-to-Neutral Voltage; default=None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z:          complex</span>
<span class="sd">                The ohmic impedance evaluated from the per-unit base.</span>
<span class="sd">    """</span>
    <span class="c1"># Evaluate the per-unit impedance</span>
    <span class="n">zbase</span> <span class="o">=</span> <span class="n">zpu</span><span class="p">(</span><span class="n">S3phs</span><span class="p">,</span> <span class="n">VLL</span><span class="p">,</span> <span class="n">VLN</span><span class="p">)</span>
    <span class="c1"># Evaluate the impedance</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z_pu</span> <span class="o">*</span> <span class="n">zbase</span>
    <span class="k">return</span> <span class="n">z</span></div>


<span class="c1"># Define X/R Recomposition Function</span>
<div class="viewcode-block" id="rxrecompose"><a class="viewcode-back" href="../api/electricpy.rxrecompose.html#electricpy.rxrecompose">[docs]</a><span class="k">def</span> <span class="nf">rxrecompose</span><span class="p">(</span><span class="n">x_pu</span><span class="p">,</span> <span class="n">XoR</span><span class="p">,</span> <span class="n">S3phs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">VLL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">VLN</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Resistance/Reactance from Per-Unit System Evaluator.</span>

<span class="sd">    Function to reverse per-unit conversion and return the ohmic value</span>
<span class="sd">    of an impedance given its per-unit parameters of X.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x_pu:       float</span>
<span class="sd">                The per-unit, complex value corresponding to the</span>
<span class="sd">                impedance</span>
<span class="sd">    XoR:        float</span>
<span class="sd">                The X/R ratio (reactance over impedance).</span>
<span class="sd">    S3phs:      float, optional</span>
<span class="sd">                The total three-phase power rating of the system.</span>
<span class="sd">                If left as None, the per-unit values will be set</span>
<span class="sd">                to 1, resulting in an unscaled impedance</span>
<span class="sd">    VLL:        float, optional</span>
<span class="sd">                The Line-to-Line Voltage; default=None</span>
<span class="sd">    VLN:        float, optional</span>
<span class="sd">                The Line-to-Neutral Voltage; default=None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z:          complex</span>
<span class="sd">                The ohmic impedance evaluated from the per-unit base.</span>
<span class="sd">    """</span>
    <span class="c1"># Ensure Absolute Value</span>
    <span class="n">x_pu</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x_pu</span><span class="p">)</span>
    <span class="c1"># Find R from X/R</span>
    <span class="n">r_pu</span> <span class="o">=</span> <span class="n">x_pu</span> <span class="o">/</span> <span class="n">XoR</span>
    <span class="c1"># Compose into z</span>
    <span class="n">z_pu</span> <span class="o">=</span> <span class="n">r_pu</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">x_pu</span>
    <span class="c1"># Recompose</span>
    <span class="k">if</span> <span class="n">S3phs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">z_pu</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">zrecompose</span><span class="p">(</span><span class="n">z_pu</span><span class="p">,</span> <span class="n">S3phs</span><span class="p">,</span> <span class="n">VLL</span><span class="p">,</span> <span class="n">VLN</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">z</span></div>


<span class="c1"># Define Generator Internal Voltage Calculator</span>
<div class="viewcode-block" id="geninternalv"><a class="viewcode-back" href="../api/electricpy.geninternalv.html#electricpy.geninternalv">[docs]</a><span class="k">def</span> <span class="nf">geninternalv</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">Zs</span><span class="p">,</span> <span class="n">Vt</span><span class="p">,</span> <span class="n">Vgn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Zm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Zmp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Zmpp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ip</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ipp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Electric Generator Internal Voltage Evaluator.</span>

<span class="sd">    Evaluates the internal voltage for a generator given the</span>
<span class="sd">    generator's internal impedance and internal mutual coupling</span>
<span class="sd">    impedance values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    I:          complex</span>
<span class="sd">                The current on the phase of interest.</span>
<span class="sd">    Zs:         complex</span>
<span class="sd">                The internal impedance of the phase of</span>
<span class="sd">                interest in ohms.</span>
<span class="sd">    Vt:         complex</span>
<span class="sd">                The generator's terminal voltage.</span>
<span class="sd">    Vgn:        complex, optional</span>
<span class="sd">                The ground-to-neutral connection voltage.</span>
<span class="sd">    Zmp:        complex, optional</span>
<span class="sd">                The mutual coupling with the first additional</span>
<span class="sd">                phase impedance in ohms.</span>
<span class="sd">    Zmpp:       complex, optional</span>
<span class="sd">                The mutual coupling with the second additional</span>
<span class="sd">                phase impedance in ohms.</span>
<span class="sd">    Ip:         complex, optional</span>
<span class="sd">                The first mutual phase current in amps.</span>
<span class="sd">    Ipp:        complex, optional</span>
<span class="sd">                The second mutual phase current in amps.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Ea:         complex</span>
<span class="sd">                The internal voltage of the generator.</span>
<span class="sd">    """</span>
    <span class="c1"># All Parameters Provided</span>
    <span class="k">if</span> <span class="n">Zmp</span> <span class="o">==</span> <span class="n">Zmpp</span> <span class="o">==</span> <span class="n">Ip</span> <span class="o">==</span> <span class="n">Ipp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">Vgn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Vgn</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">Ea</span> <span class="o">=</span> <span class="n">Zs</span> <span class="o">*</span> <span class="n">I</span> <span class="o">+</span> <span class="n">Zmp</span> <span class="o">*</span> <span class="n">Ip</span> <span class="o">+</span> <span class="n">Zmpp</span> <span class="o">*</span> <span class="n">Ipp</span> <span class="o">+</span> <span class="n">Vt</span> <span class="o">+</span> <span class="n">Vgn</span>
    <span class="c1"># Select Parameters Provided</span>
    <span class="k">elif</span> <span class="n">Vgn</span> <span class="o">==</span> <span class="n">Zm</span> <span class="o">==</span> <span class="n">Ip</span> <span class="o">==</span> <span class="n">Ipp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Ea</span> <span class="o">=</span> <span class="n">Zs</span> <span class="o">*</span> <span class="n">I</span> <span class="o">+</span> <span class="n">Vt</span>
    <span class="c1"># Invalid Parameter Set</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Invalid Parameter Set"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Ea</span></div>


<span class="c1"># FFT Coefficient Calculator Function</span>
<div class="viewcode-block" id="funcfft"><a class="viewcode-back" href="../api/electricpy.funcfft.html#electricpy.funcfft">[docs]</a><span class="k">def</span> <span class="nf">funcfft</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">minfreq</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">maxmult</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="nb">complex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    FFT Evaluator for Callable Functions.</span>

<span class="sd">    Given the callable function handle for a periodic function,</span>
<span class="sd">    evaluates the harmonic components of the function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func:       function</span>
<span class="sd">                Callable function from which to evaluate values.</span>
<span class="sd">    minfreq:    float, optional</span>
<span class="sd">                Minimum frequency (in Hz) at which to evaluate FFT.</span>
<span class="sd">                default=60</span>
<span class="sd">    maxmult:    int, optional</span>
<span class="sd">                Maximum harmonic (multiple of minfreq) which to</span>
<span class="sd">                evaluate. default=15</span>
<span class="sd">    complex:    bool, optional</span>
<span class="sd">                Control argument to force returned values into</span>
<span class="sd">                complex format.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    DC:         float</span>
<span class="sd">                The DC offset of the FFT result.</span>
<span class="sd">    A:          list of float</span>
<span class="sd">                The real components from the FFT.</span>
<span class="sd">    B:          list of float</span>
<span class="sd">                The imaginary components from the FFT.</span>
<span class="sd">    """</span>
    <span class="c1"># Apply Nyquist scaling</span>
    <span class="n">NN</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">maxmult</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="c1"># Determine Time from Fundamental Frequency</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">minfreq</span>
    <span class="c1"># Generate time range to apply for FFT</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">NN</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Evaluate FFT</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="o">/</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span>
    <span class="c1"># Return Complex Values</span>
    <span class="k">if</span> <span class="nb">complex</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">y</span>
    <span class="c1"># Split out useful values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span></div>


<div class="viewcode-block" id="sampfft"><a class="viewcode-back" href="../api/electricpy.sampfft.html#electricpy.sampfft">[docs]</a><span class="k">def</span> <span class="nf">sampfft</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">minfreq</span><span class="o">=</span><span class="mf">60.0</span><span class="p">,</span> <span class="nb">complex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Sample Dataset FFT Evaluator.</span>

<span class="sd">    Given a data array and the delta-t for the data array, evaluates</span>
<span class="sd">    the harmonic composition of the data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data:       numpy.ndarray</span>
<span class="sd">                Numpy data array containing 1-D values.</span>
<span class="sd">    dt:         float</span>
<span class="sd">                Time-difference (delta-t) between data samples.</span>
<span class="sd">    minfreq:    float, optional</span>
<span class="sd">                Minimum frequency (in Hz) at which to evaluate FFT.</span>
<span class="sd">                default=60</span>
<span class="sd">    complex:    bool, optional</span>
<span class="sd">                Control argument to force returned values into</span>
<span class="sd">                complex format.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    DC:         float</span>
<span class="sd">                The DC offset of the FFT result.</span>
<span class="sd">    A:          list of float</span>
<span class="sd">                The real components from the FFT.</span>
<span class="sd">    B:          list of float</span>
<span class="sd">                The imaginary components from the FFT.</span>
<span class="sd">    """</span>
    <span class="c1"># Calculate Terms</span>
    <span class="n">FR</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">NN</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">//</span> <span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">minfreq</span><span class="p">)</span>
    <span class="c1"># Test for Invalid System</span>
    <span class="k">if</span> <span class="n">FR</span> <span class="o">&gt;</span> <span class="n">minfreq</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">"Too few data samples to evaluate FFT at specified minimum "</span>
            <span class="s2">"frequency."</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">FR</span> <span class="o">==</span> <span class="n">minfreq</span><span class="p">:</span>
        <span class="c1"># Evaluate FFT</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Slice data array to appropriate fundamental frequency</span>
        <span class="n">cut_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="n">NN</span><span class="p">)]</span>
        <span class="c1"># Evaluate FFT</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">cut_data</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">cut_data</span><span class="p">)</span>
    <span class="c1"># Return Complex Values</span>
    <span class="k">if</span> <span class="nb">complex</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="c1"># Split out useful values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span></div>


<span class="c1"># Define FFT Plotting Function</span>
<div class="viewcode-block" id="fftplot"><a class="viewcode-back" href="../api/electricpy.fftplot.html#electricpy.fftplot">[docs]</a><span class="k">def</span> <span class="nf">fftplot</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">"Fourier Coefficients"</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    FFT System Plotter.</span>

<span class="sd">    Plotting function for FFT (harmonic) values, plots the DC, Real, and</span>
<span class="sd">    Imaginary components.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dc:         float</span>
<span class="sd">                The DC offset term</span>
<span class="sd">    real:       list of float</span>
<span class="sd">                Real terms of FFT (cosine terms)</span>
<span class="sd">    imag:       list of float, optional</span>
<span class="sd">                Imaginary terms of FFT (sine terms)</span>
<span class="sd">    title:      str, optional</span>
<span class="sd">                String appended to plot title,</span>
<span class="sd">                default="Fourier Coefficients"</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    matplotlib.pyplot:  Plotting object to be used for additional configuration</span>
<span class="sd">                        or plotting.</span>
<span class="sd">    """</span>
    <span class="c1"># Define Range values for plots</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">real</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">xtic</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">real</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Set up Arguments</span>
    <span class="n">a0x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">a0y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">dc</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span>
    <span class="c1"># Plot</span>
    <span class="n">_plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">_plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">a0x</span><span class="p">,</span> <span class="n">a0y</span><span class="p">,</span> <span class="s1">'g'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">"DC-Term"</span><span class="p">)</span>
    <span class="n">_plt</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span>
        <span class="n">rng</span><span class="p">,</span>
        <span class="n">real</span><span class="p">,</span>
        <span class="n">linefmt</span><span class="o">=</span><span class="s1">'r'</span><span class="p">,</span>
        <span class="n">markerfmt</span><span class="o">=</span><span class="s1">'ro'</span><span class="p">,</span>
        <span class="n">label</span><span class="o">=</span><span class="s2">"Real-Terms"</span><span class="p">,</span>
        <span class="n">use_line_collection</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">imag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_plt</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span>
            <span class="n">rng</span><span class="p">,</span>
            <span class="n">imag</span><span class="p">,</span>
            <span class="n">linefmt</span><span class="o">=</span><span class="s1">'b'</span><span class="p">,</span>
            <span class="n">markerfmt</span><span class="o">=</span><span class="s1">'bo'</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">"Imaginary-Terms"</span><span class="p">,</span>
            <span class="n">use_line_collection</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="n">_plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Harmonics (Multiple of Fundamental)"</span><span class="p">)</span>
    <span class="n">_plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Harmonic Magnitude"</span><span class="p">)</span>
    <span class="n">_plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">'k'</span><span class="p">)</span>
    <span class="n">_plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xtic</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">):</span>
        <span class="n">_plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">xtic</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_plt</span></div>


<span class="c1"># Define FFT Composition Plotting Function</span>
<div class="viewcode-block" id="fftsumplot"><a class="viewcode-back" href="../api/electricpy.fftsumplot.html#electricpy.fftsumplot">[docs]</a><span class="k">def</span> <span class="nf">fftsumplot</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">xrange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
               <span class="n">plotall</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">"Fourier Series Summation"</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    FFT Summation Plotter.</span>

<span class="sd">    Function to generate the plot of the sumed FFT results.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dc:         float</span>
<span class="sd">                The DC offset term</span>
<span class="sd">    real:       list of float</span>
<span class="sd">                Real terms of FFT (cosine terms)</span>
<span class="sd">    imag:       list of float</span>
<span class="sd">                Imaginary terms of FFT (sine terms)</span>
<span class="sd">    freq:       float, optional</span>
<span class="sd">                Fundamental (minimum nonzero) frequency in Hz,</span>
<span class="sd">                default=60</span>
<span class="sd">    xrange:     list of float, optional</span>
<span class="sd">                List of two floats containing the minimum</span>
<span class="sd">                time and the maximum time.</span>
<span class="sd">    npts:       int, optional</span>
<span class="sd">                Number of time step points, default=1000</span>
<span class="sd">    title:      str, optional</span>
<span class="sd">                String appended to plot title,</span>
<span class="sd">                default="Fourier Series Summation"</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    matplotlib.pyplot:  Plotting object to be used for additional configuration</span>
<span class="sd">                        or plotting.</span>
<span class="sd">    """</span>
    <span class="c1"># Determine the number (N) of terms</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">real</span><span class="p">)</span>
    <span class="c1"># Determine the system period (T)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">freq</span>
    <span class="c1"># Generate Domain Array</span>
    <span class="k">if</span> <span class="n">xrange</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">npts</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">npts</span><span class="p">)</span>
    <span class="c1"># Initialize output with DC term</span>
    <span class="n">yout</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">*</span> <span class="n">dc</span>
    <span class="c1"># Plot each iteration of the Fourier Series</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">plotall</span><span class="p">:</span>
            <span class="n">_plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yout</span><span class="p">)</span>
        <span class="n">yout</span> <span class="o">+=</span> <span class="n">real</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">imag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">yout</span> <span class="o">+=</span> <span class="n">imag</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">_plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yout</span><span class="p">)</span>
    <span class="n">_plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">_plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"Time (seconds)"</span><span class="p">)</span>
    <span class="n">_plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"Magnitude"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_plt</span></div>


<span class="c1"># Define harmonic system generation function</span>
<div class="viewcode-block" id="harmonics"><a class="viewcode-back" href="../api/electricpy.harmonics.html#electricpy.harmonics">[docs]</a><span class="k">def</span> <span class="nf">harmonics</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Harmonic Function Generator.</span>

<span class="sd">    Generate a function or dataset for a harmonic system</span>
<span class="sd">    given the real (cosine), imaginary (sine), and DC</span>
<span class="sd">    components of the system.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    real:       list of float</span>
<span class="sd">                The real (cosine) component coefficients</span>
<span class="sd">                for the harmonic system.</span>
<span class="sd">    imag:       list of float, optional</span>
<span class="sd">                The imaginary (sine) component coefficients</span>
<span class="sd">                for the harmonic system.</span>
<span class="sd">    dc:         float, optional</span>
<span class="sd">                The DC offset for the harmonic system,</span>
<span class="sd">                default=0</span>
<span class="sd">    freq:       float, optional</span>
<span class="sd">                The fundamental frequency of the system in</span>
<span class="sd">                Hz, default=60</span>
<span class="sd">    domain:     list of float, optional</span>
<span class="sd">                Domain of time samples at which to calculate</span>
<span class="sd">                the harmonic system, must be array-like, will</span>
<span class="sd">                cause function to return numpy array instead</span>
<span class="sd">                of function object.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    system:     function</span>
<span class="sd">                Function object handle which can be used to</span>
<span class="sd">                call the function to evaluate the harmonic</span>
<span class="sd">                system at specified times.</span>
<span class="sd">    """</span>
    <span class="c1"># Validate Inputs</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Argument *real* must be array-like."</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">imag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imag</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Argument *imag* must be array-like."</span><span class="p">)</span>
    <span class="c1"># Calculate Omega</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span>

    <span class="k">def</span> <span class="nf">_harmonic_</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">dc</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">real</span><span class="p">)):</span>
            <span class="c1"># Evaluate Current Coefficient</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">real</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">imag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">imag</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Calculate Output</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">B</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
        <span class="c1"># Return Value</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_harmonic_</span>  <span class="c1"># Return as callable for external use</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_harmonic_</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span></div>


<span class="c1"># Define Single Phase Motor Startup Capacitor Formula</span>
<div class="viewcode-block" id="motorstartcap"><a class="viewcode-back" href="../api/electricpy.motorstartcap.html#electricpy.motorstartcap">[docs]</a><span class="k">def</span> <span class="nf">motorstartcap</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Single Phase Motor Starting Capacitor Function.</span>

<span class="sd">    Function to evaluate a reccomended value for the</span>
<span class="sd">    startup capacitor associated with a single phase</span>
<span class="sd">    motor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    V:          float</span>
<span class="sd">                Magnitude of motor terminal voltage in volts.</span>
<span class="sd">    I:          float</span>
<span class="sd">                Magnitude of motor no-load current in amps.</span>
<span class="sd">    freq:       float, optional</span>
<span class="sd">                Motor/System frequency, default=60.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C:          float</span>
<span class="sd">                Suggested capacitance in Farads.</span>
<span class="sd">    """</span>
    <span class="c1"># Condition Inputs</span>
    <span class="n">I</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="c1"># Calculate Capacitance</span>
    <span class="k">return</span> <span class="n">I</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">V</span><span class="p">)</span></div>


<span class="c1"># Define Power Factor Correction Function</span>
<div class="viewcode-block" id="pfcorrection"><a class="viewcode-back" href="../api/electricpy.pfcorrection.html#electricpy.pfcorrection">[docs]</a><span class="k">def</span> <span class="nf">pfcorrection</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">PFold</span><span class="p">,</span> <span class="n">PFnew</span><span class="p">,</span> <span class="n">VLL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">VLN</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Power Factor Correction Function.</span>

<span class="sd">    Function to evaluate the additional reactive power and</span>
<span class="sd">    capacitance required to achieve the desired power factor</span>
<span class="sd">    given the old power factor and new power factor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S:          float</span>
<span class="sd">                Apparent power consumed by the load.</span>
<span class="sd">    PFold:      float</span>
<span class="sd">                The current (old) power factor, should be a decimal</span>
<span class="sd">                value.</span>
<span class="sd">    PFnew:      float</span>
<span class="sd">                The desired (new) power factor, should be a decimal</span>
<span class="sd">                value.</span>
<span class="sd">    VLL:        float, optional</span>
<span class="sd">                The Line-to-Line Voltage; default=None</span>
<span class="sd">    VLN:        float, optional</span>
<span class="sd">                The Line-to-Neutral Voltage; default=None</span>
<span class="sd">    V:          float, optional</span>
<span class="sd">                Voltage across the capacitor, ignores line-to-line</span>
<span class="sd">                or line-to-neutral constraints. default=None</span>
<span class="sd">    freq:       float, optional</span>
<span class="sd">                System frequency, default=60</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C:          float</span>
<span class="sd">                Required capacitance in Farads.</span>
<span class="sd">    Qc:         float</span>
<span class="sd">                Difference of reactive power, (Qc = Qnew - Qold)</span>
<span class="sd">    """</span>
    <span class="c1"># Condition Inputs</span>
    <span class="n">S</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="c1"># Calculate Initial Terms</span>
    <span class="n">Pold</span> <span class="o">=</span> <span class="n">S</span> <span class="o">*</span> <span class="n">PFold</span>
    <span class="n">Qold</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">Pold</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Evaluate Reactive Power Requirements</span>
    <span class="n">Scorrected</span> <span class="o">=</span> <span class="n">Pold</span> <span class="o">/</span> <span class="n">PFnew</span>
    <span class="n">Qcorrected</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Scorrected</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">Pold</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">Qc</span> <span class="o">=</span> <span class="n">Qold</span> <span class="o">-</span> <span class="n">Qcorrected</span>
    <span class="c1"># Evaluate Capacitance Based on Voltage Input</span>
    <span class="k">if</span> <span class="n">VLL</span> <span class="o">==</span> <span class="n">VLN</span> <span class="o">==</span> <span class="n">V</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"One voltage must be specified."</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">VLN</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">Qc</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">VLN</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">VLL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">VLL</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">Qc</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">V</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Return Value</span>
    <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="n">Qc</span></div>


<span class="c1"># Define Apparent Power / Voltage / Current Relation Function</span>
<div class="viewcode-block" id="acpiv"><a class="viewcode-back" href="../api/electricpy.acpiv.html#electricpy.acpiv">[docs]</a><span class="k">def</span> <span class="nf">acpiv</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">VLL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">VLN</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">PF</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    AC Power-Voltage-Current Relation Function.</span>

<span class="sd">    Relationship function to return apparent power, voltage, or</span>
<span class="sd">    current in one of various forms.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S:          complex, optional</span>
<span class="sd">                Apparent power, may be single or three-phase,</span>
<span class="sd">                specified in volt-amps (VAs)</span>
<span class="sd">    I:          complex, optional</span>
<span class="sd">                Phase current in amps</span>
<span class="sd">    VLL:        complex, optional</span>
<span class="sd">                Line-to-Line voltage in volts</span>
<span class="sd">    VLN:        complex, optional</span>
<span class="sd">                Line-to-Neutral voltage in volts</span>
<span class="sd">    V:          complex, optional</span>
<span class="sd">                Single-phase voltage in volts</span>
<span class="sd">    PF:         float, optional</span>
<span class="sd">                Power factor to condition the apparent power to an appropriate</span>
<span class="sd">                complex value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S:          complex</span>
<span class="sd">                Apparent power, returned only if one voltage</span>
<span class="sd">                and current is specified</span>
<span class="sd">    I:          complex</span>
<span class="sd">                Phase current, returned only if one voltage</span>
<span class="sd">                and apparent power is specified</span>
<span class="sd">    VLL:        complex</span>
<span class="sd">                Line-to-Line voltage, returned only if current</span>
<span class="sd">                and apparent power specified, returned as set</span>
<span class="sd">                with other voltages in form: (VLL, VLN, V)</span>
<span class="sd">    VLN:        complex</span>
<span class="sd">                Line-to-Neutral voltage, returned only if</span>
<span class="sd">                current and apparent power specified, returned</span>
<span class="sd">                as set with other voltages in form: (VLL, VLN, V)</span>
<span class="sd">    V:          complex</span>
<span class="sd">                Single-phase voltage, returned only if current</span>
<span class="sd">                and apparent power specified, returned as set</span>
<span class="sd">                with other voltages in form: (VLL, VLN, V)</span>
<span class="sd">    PF:         float, optional</span>
<span class="sd">                Supporting argument to convert floating-point</span>
<span class="sd">                apparent power to complex representation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import electricpy as ep</span>
<span class="sd">    &gt;&gt;&gt; ep.acpiv(S=550, V=167)</span>
<span class="sd">    3.2934131736526946</span>
<span class="sd">    &gt;&gt;&gt; ep.acpiv(S=550, I=3.2934131736526946)</span>
<span class="sd">    (96.4174949546675, 55.66666666666667, 167.0)</span>
<span class="sd">    """</span>
    <span class="c1"># Validate Inputs</span>
    <span class="k">if</span> <span class="n">S</span> <span class="o">==</span> <span class="n">I</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"To few arguments."</span><span class="p">)</span>
    <span class="c1"># Convert Apparent Power to Complex</span>
    <span class="k">if</span> <span class="n">PF</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">S</span> <span class="o">*</span> <span class="n">PF</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="n">PF</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Solve Single-Phase</span>
    <span class="k">if</span> <span class="n">V</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Solve for Apparent Power</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">V</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">S</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Solve for Current</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">S</span> <span class="o">/</span> <span class="n">V</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">I</span>
    <span class="c1"># Solve Line-to-Line</span>
    <span class="k">elif</span> <span class="n">VLL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Solve for Apparent Power</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">VLL</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">S</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Solve for Current</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">S</span> <span class="o">/</span> <span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">VLL</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">I</span>
    <span class="c1"># Solve Line-to-Neutral</span>
    <span class="k">elif</span> <span class="n">VLN</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Solve for Apparent Power</span>
            <span class="n">S</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">VLN</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">S</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Solve for Current</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">S</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">VLN</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">I</span>
    <span class="c1"># Solve for Voltages</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">S</span> <span class="o">/</span> <span class="n">_np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
        <span class="n">VLL</span> <span class="o">=</span> <span class="n">S</span> <span class="o">/</span> <span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">I</span><span class="p">))</span>
        <span class="n">VLN</span> <span class="o">=</span> <span class="n">S</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">I</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">VLL</span><span class="p">,</span> <span class="n">VLN</span><span class="p">,</span> <span class="n">V</span></div>


<span class="c1"># Define Primary Ratio Function</span>
<div class="viewcode-block" id="primary"><a class="viewcode-back" href="../api/electricpy.primary.html#electricpy.primary">[docs]</a><span class="k">def</span> <span class="nf">primary</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Np</span><span class="p">,</span> <span class="n">Ns</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Electrical Transformer Primary Evaluator.</span>

<span class="sd">    Returns a current or voltage value reflected across</span>
<span class="sd">    a transformer with a specified turns ratio Np/Ns.</span>
<span class="sd">    Converts to the primary side.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    val:        complex</span>
<span class="sd">                Value to be reflected across transformer.</span>
<span class="sd">    Np:         float</span>
<span class="sd">                Number of turns on primary side.</span>
<span class="sd">    Ns:         float, optional</span>
<span class="sd">                Number of turns on secondary side.</span>
<span class="sd">    invert:     bool, optional</span>
<span class="sd">                Control argument to invert the turns ratio,</span>
<span class="sd">                used when reflecting current across a</span>
<span class="sd">                voltage transformer, or voltage across a</span>
<span class="sd">                current transformer.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reflection: complex</span>
<span class="sd">                The reflected value referred to the primary</span>
<span class="sd">                side according to Np and Ns.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span> <span class="o">*</span> <span class="n">Ns</span> <span class="o">/</span> <span class="n">Np</span>
    <span class="k">return</span> <span class="n">val</span> <span class="o">*</span> <span class="n">Np</span> <span class="o">/</span> <span class="n">Ns</span></div>


<span class="c1"># Define Secondary Ratio Function</span>
<div class="viewcode-block" id="secondary"><a class="viewcode-back" href="../api/electricpy.secondary.html#electricpy.secondary">[docs]</a><span class="k">def</span> <span class="nf">secondary</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Np</span><span class="p">,</span> <span class="n">Ns</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Electrical Transformer Secondary Evaluator.</span>

<span class="sd">    Returns a current or voltage value reflected across</span>
<span class="sd">    a transformer with a specified turns ratio Np/Ns.</span>
<span class="sd">    Converts to the secondary side.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    val:        complex</span>
<span class="sd">                Value to be reflected across transformer.</span>
<span class="sd">    Np:         float</span>
<span class="sd">                Number of turns on primary side.</span>
<span class="sd">    Ns:         float, optional</span>
<span class="sd">                Number of turns on secondary side.</span>
<span class="sd">    invert:     bool, optional</span>
<span class="sd">                Control argument to invert the turns ratio,</span>
<span class="sd">                used when reflecting current across a</span>
<span class="sd">                voltage transformer, or voltage across a</span>
<span class="sd">                current transformer.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reflection: complex</span>
<span class="sd">                The reflected value referred to the secondary</span>
<span class="sd">                side according to Np and Ns.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span> <span class="o">*</span> <span class="n">Np</span> <span class="o">/</span> <span class="n">Ns</span>
    <span class="k">return</span> <span class="n">val</span> <span class="o">*</span> <span class="n">Ns</span> <span class="o">/</span> <span class="n">Np</span></div>


<div class="viewcode-block" id="tap_changing_transformer"><a class="viewcode-back" href="../api/electricpy.tap_changing_transformer.html#electricpy.tap_changing_transformer">[docs]</a><span class="k">def</span> <span class="nf">tap_changing_transformer</span><span class="p">(</span><span class="n">Vgen</span><span class="p">,</span> <span class="n">Vdis</span><span class="p">,</span> <span class="n">Pload</span><span class="p">,</span> <span class="n">Qload</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Calculate Turn Ratio of Load Tap Changing Transformer.</span>

<span class="sd">    The purpose of a tap changer is to regulate the output voltage of a</span>
<span class="sd">    transformer. It does this by altering the number of turns in one winding and</span>
<span class="sd">    thereby changing the turns ratio of the transformer</span>

<span class="sd">    .. math:: \sqrt{\frac{Vgen^2}{Vgen \cdot Vdis - R \cdot P - X \cdot Q}}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Vgen:   float</span>
<span class="sd">            Generating station voltage</span>
<span class="sd">    Vdis:   float</span>
<span class="sd">            Distribution network voltage</span>
<span class="sd">    Pload:  float</span>
<span class="sd">            Transmission line load active power in Watt</span>
<span class="sd">    Qload:  float</span>
<span class="sd">            Transmission line load reactive power in VAR</span>
<span class="sd">    R:      float</span>
<span class="sd">            Resistance of transmission line</span>
<span class="sd">    X:      float</span>
<span class="sd">            Reactance of transmission line</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ts:     float</span>
<span class="sd">            Turns ration of transformer</span>
<span class="sd">    """</span>
    <span class="c1"># Evaluate the turns ratio</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vgen</span> <span class="o">*</span> <span class="n">Vgen</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Vgen</span> <span class="o">*</span> <span class="n">Vdis</span> <span class="o">-</span> <span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="n">Pload</span> <span class="o">+</span> <span class="n">X</span> <span class="o">*</span> <span class="n">Qload</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">pow</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span></div>


<div class="viewcode-block" id="suspension_insulators"><a class="viewcode-back" href="../api/electricpy.suspension_insulators.html#electricpy.suspension_insulators">[docs]</a><span class="k">def</span> <span class="nf">suspension_insulators</span><span class="p">(</span><span class="n">number_capacitors</span><span class="p">,</span> <span class="n">capacitance_ratio</span><span class="p">,</span> <span class="n">Voltage</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Discrete Capacitors Voltage in a Suspension Insulator Strain.</span>

<span class="sd">    To perform the calculations described here, the following formulas are</span>
<span class="sd">    satisfied, and used to construct a matrix used to solve for</span>
<span class="sd">    :math:`V_i \text{i in range(1,n)}`.</span>

<span class="sd">    .. math:: \sum_{i=1}^{n-2} V_{i} + V_{n-1} \cdot (1+m) - V_{n} \cdot m=0</span>

<span class="sd">    .. math:: \sum_{i=1}^{n} V_{i} = V_{\text{transmission line}}</span>

<span class="sd">    .. image:: /static/SuspensionInuslator.png</span>

<span class="sd">    `Additional Information</span>
<span class="sd">    &lt;https://electrical-engineering-portal.com/download-center/books-and-guides/power-substations/insulator-pollution&gt;`_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    number_capacitors:  int</span>
<span class="sd">                        Number of disk capacitors hung to transmission line</span>
<span class="sd">    capacitance_ratio:  float</span>
<span class="sd">                        Ratio of disk capacitance and pin to pole air</span>
<span class="sd">                        capacitance</span>
<span class="sd">    Voltage:            float</span>
<span class="sd">                        Voltage difference between the transmission line and</span>
<span class="sd">                        ground</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string_efficiency:          float</span>
<span class="sd">                                String efficiency of capacitive disks</span>
<span class="sd">    capacitor_disk_voltages:    float</span>
<span class="sd">                                Voltage across each capacitive disk starting</span>
<span class="sd">                                from top to bottom</span>
<span class="sd">    """</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">number_capacitors</span><span class="p">,</span> <span class="n">number_capacitors</span><span class="p">))</span>
    <span class="c1"># Iterate over capacitors</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_capacitors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Iterate over capacitors</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_capacitors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># If inner iteration is less than outer iteration</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">capacitance_ratio</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_capacitors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">capacitance_ratio</span><span class="p">)</span>

        <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">m</span><span class="p">[</span><span class="n">number_capacitors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">number_capacitors</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">v</span><span class="p">[</span><span class="n">number_capacitors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Voltage</span>

    <span class="n">capacitor_disk_voltages</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span>

    <span class="n">string_efficiency</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">Voltage</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">number_capacitors</span> <span class="o">*</span> <span class="n">capacitor_disk_voltages</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">capacitor_disk_voltages</span><span class="p">,</span> <span class="n">string_efficiency</span></div>


<span class="c1"># Define Natural Frequency/Resonant Frequency Calculator</span>
<div class="viewcode-block" id="natfreq"><a class="viewcode-back" href="../api/electricpy.natfreq.html#electricpy.natfreq">[docs]</a><span class="k">def</span> <span class="nf">natfreq</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Hz</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Natural Frequency Evaluator.</span>

<span class="sd">    Evaluates the natural frequency (resonant frequency) of a circuit given the</span>
<span class="sd">    circuit's C and L values. Defaults to returning values in Hz, but may also</span>
<span class="sd">    return in rad/sec.</span>

<span class="sd">    .. math:: freq=\frac{1}{\sqrt{L*C}*(2*\pi)}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C:          float</span>
<span class="sd">                Capacitance Value in Farads.</span>
<span class="sd">    L:          float</span>
<span class="sd">                Inductance in Henries.</span>
<span class="sd">    Hz:         bool, optional</span>
<span class="sd">                Control argument to set return value in either</span>
<span class="sd">                Hz or rad/sec; default=True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    freq:       float</span>
<span class="sd">                Natural (Resonant) frequency, will be in Hz if</span>
<span class="sd">                argument *Hz* is set True (default), or rad/sec</span>
<span class="sd">                if argument is set False.</span>
<span class="sd">    """</span>
    <span class="c1"># Evaluate Natural Frequency in rad/sec</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">L</span> <span class="o">*</span> <span class="n">C</span><span class="p">)</span>
    <span class="c1"># Convert to Hz as requested</span>
    <span class="k">if</span> <span class="n">Hz</span><span class="p">:</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">freq</span><span class="p">)</span></div>


<span class="c1"># Define Voltage/Current Unbalance Equation</span>
<div class="viewcode-block" id="unbalance"><a class="viewcode-back" href="../api/electricpy.unbalance.html#electricpy.unbalance">[docs]</a><span class="k">def</span> <span class="nf">unbalance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Voltage/Current Unbalance Function.</span>

<span class="sd">    Performs a voltage/current unbalance calculation</span>
<span class="sd">    to determine the maximum current/voltage</span>
<span class="sd">    unbalance. Returns result as a decimal percentage.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A:          float</span>
<span class="sd">                Phase-A value</span>
<span class="sd">    B:          float</span>
<span class="sd">                Phase-B value</span>
<span class="sd">    C:          float</span>
<span class="sd">                Phase-C value</span>
<span class="sd">    all:        bool, optional</span>
<span class="sd">                Control argument to require function</span>
<span class="sd">                to return all voltage/current unbalances.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unbalance:  float</span>
<span class="sd">                The unbalance as a percentage of the</span>
<span class="sd">                average. (i.e. 80% = 0.8)</span>
<span class="sd">    """</span>
    <span class="c1"># Condition Inputs</span>
    <span class="n">A</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="c1"># Gather Average</span>
    <span class="n">avg</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span> <span class="o">+</span> <span class="n">C</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
    <span class="c1"># Determine Variance</span>
    <span class="n">dA</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">avg</span><span class="p">)</span>
    <span class="n">dB</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">B</span> <span class="o">-</span> <span class="n">avg</span><span class="p">)</span>
    <span class="n">dC</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">avg</span><span class="p">)</span>
    <span class="c1"># Gather Maximum Variation</span>
    <span class="n">mx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dA</span><span class="p">,</span> <span class="n">dB</span><span class="p">,</span> <span class="n">dC</span><span class="p">)</span>
    <span class="c1"># Calculate Maximum Variation</span>
    <span class="n">unbalance</span> <span class="o">=</span> <span class="n">mx</span> <span class="o">/</span> <span class="n">avg</span>
    <span class="c1"># Return Results</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dA</span> <span class="o">/</span> <span class="n">avg</span><span class="p">,</span> <span class="n">dB</span> <span class="o">/</span> <span class="n">avg</span><span class="p">,</span> <span class="n">dC</span> <span class="o">/</span> <span class="n">avg</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">unbalance</span></div>


<span class="c1"># Define Cosine Filter Function</span>
<div class="viewcode-block" id="cosfilt"><a class="viewcode-back" href="../api/electricpy.cosfilt.html#electricpy.cosfilt">[docs]</a><span class="k">def</span> <span class="nf">cosfilt</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">Srate</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Cosine Filter Function.</span>

<span class="sd">    Cosine Filter function for filtering a dataset</span>
<span class="sd">    representing a sinusoidal function with or without</span>
<span class="sd">    harmonics to evaluate the fundamental value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr:        numpy.ndarray</span>
<span class="sd">                The input data array.</span>
<span class="sd">    Srate:      int</span>
<span class="sd">                Sampling rate for dataset, specified in</span>
<span class="sd">                number of values per fundamental cycle.</span>
<span class="sd">    domain:     bool, optional</span>
<span class="sd">                Control argument to force return of</span>
<span class="sd">                x-axis array for the filtered data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cosf:       numpy.ndarray</span>
<span class="sd">                Cosine-filtered data</span>
<span class="sd">    xarray:     numpy.ndarray</span>
<span class="sd">                X-axis array for the filtered data.</span>
<span class="sd">    """</span>
    <span class="c1"># Evaluate index set</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Srate</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Define Cosine Coefficient Function</span>
    <span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Srate</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">k</span> <span class="o">/</span> <span class="n">Srate</span><span class="p">)</span>

    <span class="c1"># Calculate Constant</span>
    <span class="n">const</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">Srate</span>
    <span class="c1"># Iteratively Calculate</span>
    <span class="n">cosf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Srate</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">slc</span> <span class="o">=</span> <span class="p">(</span><span class="n">ind</span> <span class="o">-</span> <span class="p">(</span><span class="n">Srate</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">k</span>
        <span class="n">cosf</span> <span class="o">+=</span> <span class="n">cos</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Srate</span><span class="p">)</span> <span class="o">*</span> <span class="n">arr</span><span class="p">[</span><span class="n">slc</span><span class="p">]</span>
    <span class="c1"># Scale</span>
    <span class="n">cosf</span> <span class="o">=</span> <span class="n">const</span> <span class="o">*</span> <span class="n">cosf</span>
    <span class="c1"># Return Cosine-Filtered Array</span>
    <span class="k">if</span> <span class="n">domain</span><span class="p">:</span>
        <span class="n">xarray</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">Srate</span> <span class="o">+</span> <span class="n">Srate</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cosf</span><span class="p">))</span>
        <span class="n">xarray</span> <span class="o">=</span> <span class="n">xarray</span> <span class="o">/</span> <span class="n">Srate</span>
        <span class="k">return</span> <span class="n">cosf</span><span class="p">,</span> <span class="n">xarray</span>
    <span class="k">return</span> <span class="n">cosf</span></div>


<span class="c1"># Define Sine Filter Function</span>
<div class="viewcode-block" id="sinfilt"><a class="viewcode-back" href="../api/electricpy.sinfilt.html#electricpy.sinfilt">[docs]</a><span class="k">def</span> <span class="nf">sinfilt</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">Srate</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Sine Filter Function.</span>

<span class="sd">    Sine Filter function for filtering a dataset</span>
<span class="sd">    representing a sinusoidal function with or without</span>
<span class="sd">    harmonics to evaluate the fundamental value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr:        numpy.ndarray</span>
<span class="sd">                The input data array.</span>
<span class="sd">    Srate:      int</span>
<span class="sd">                Sampling rate for dataset, specified in</span>
<span class="sd">                number of values per fundamental cycle.</span>
<span class="sd">    domain:     bool, optional</span>
<span class="sd">                Control argument to force return of</span>
<span class="sd">                x-axis array for the filtered data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sinf:       numpy.ndarray</span>
<span class="sd">                Sine-filtered data</span>
<span class="sd">    xarray:     numpy.ndarray</span>
<span class="sd">                X-axis array for the filtered data.</span>
<span class="sd">    """</span>
    <span class="c1"># Evaluate index set</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Srate</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Define Cosine Coefficient Function</span>
    <span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Srate</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">k</span> <span class="o">/</span> <span class="n">Srate</span><span class="p">)</span>

    <span class="c1"># Calculate Constant</span>
    <span class="n">const</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">Srate</span>
    <span class="c1"># Iteratively Calculate</span>
    <span class="n">sinf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Srate</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">slc</span> <span class="o">=</span> <span class="p">(</span><span class="n">ind</span> <span class="o">-</span> <span class="p">(</span><span class="n">Srate</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">k</span>
        <span class="n">sinf</span> <span class="o">+=</span> <span class="n">sin</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Srate</span><span class="p">)</span> <span class="o">*</span> <span class="n">arr</span><span class="p">[</span><span class="n">slc</span><span class="p">]</span>
    <span class="c1"># Scale</span>
    <span class="n">sinf</span> <span class="o">=</span> <span class="n">const</span> <span class="o">*</span> <span class="n">sinf</span>
    <span class="c1"># Return Cosine-Filtered Array</span>
    <span class="k">if</span> <span class="n">domain</span><span class="p">:</span>
        <span class="n">xarray</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">Srate</span> <span class="o">+</span> <span class="n">Srate</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sinf</span><span class="p">))</span>
        <span class="n">xarray</span> <span class="o">=</span> <span class="n">xarray</span> <span class="o">/</span> <span class="n">Srate</span>
        <span class="k">return</span> <span class="n">sinf</span><span class="p">,</span> <span class="n">xarray</span>
    <span class="k">return</span> <span class="n">sinf</span></div>


<span class="c1"># Define Characteristic Impedance Calculator</span>
<div class="viewcode-block" id="characterz"><a class="viewcode-back" href="../api/electricpy.characterz.html#electricpy.characterz">[docs]</a><span class="k">def</span> <span class="nf">characterz</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Characteristic Impedance Calculator.</span>

<span class="sd">    Function to evaluate the characteristic</span>
<span class="sd">    impedance of a system with specefied</span>
<span class="sd">    line parameters as defined. System uses</span>
<span class="sd">    the standard characteristic impedance</span>
<span class="sd">    equation :eq:`Zc`.</span>

<span class="sd">    .. math:: Z_c = \sqrt{\frac{R+j\omega L}{G+j\omega C}}</span>
<span class="sd">       :label: Zc</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R:          float</span>
<span class="sd">                Resistance in ohms.</span>
<span class="sd">    G:          float</span>
<span class="sd">                Conductance in mhos (siemens).</span>
<span class="sd">    L:          float</span>
<span class="sd">                Inductance in Henries.</span>
<span class="sd">    C:          float</span>
<span class="sd">                Capacitance in Farads.</span>
<span class="sd">    freq:       float, optional</span>
<span class="sd">                System frequency in Hz, default=60</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Zc:         complex</span>
<span class="sd">                Charcteristic Impedance of specified line.</span>
<span class="sd">    """</span>
    <span class="c1"># Evaluate omega</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span>
    <span class="c1"># Evaluate Zc</span>
    <span class="n">Zc</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">L</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">G</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">C</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Zc</span><span class="p">)</span></div>


<span class="c1"># Define propagation_constants for long transmission line</span>
<div class="viewcode-block" id="propagation_constants"><a class="viewcode-back" href="../api/electricpy.propagation_constants.html#electricpy.propagation_constants">[docs]</a><span class="k">def</span> <span class="nf">propagation_constants</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Transaction Line Propagation Constant Calculator.</span>

<span class="sd">    This function will evaluate the propagation constants for a long transmission</span>
<span class="sd">    line whose properties are governed by the differential equation:</span>

<span class="sd">    .. math:: \frac{d^2V}{dx^2} = \gamma V</span>

<span class="sd">    From the above equation, the following formulas are derived to evaluate the</span>
<span class="sd">    desired constants.</span>

<span class="sd">    .. math:: \gamma = \sqrt( z * y )</span>

<span class="sd">    .. math:: Z_{\text{surge}} = \sqrt( z / y )</span>

<span class="sd">    .. math:: \alpha = \Re{ \gamma }</span>

<span class="sd">    .. math:: \beta = \Im{ \gamma }</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z:              complex</span>
<span class="sd">                    Impedence of the transmission line: R+j*2*pi*f*L</span>
<span class="sd">    y:              complex</span>
<span class="sd">                    Admitance of the transmission line g+j*2*pi*f*C</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    params:    dict</span>
<span class="sd">               Dictionary of propagation constants including:</span>

<span class="sd">                         gamma:   Propagation constant</span>
<span class="sd">                         zc:            Surge impedance</span>
<span class="sd">                         alpha:      Attenuation constant</span>
<span class="sd">                         beta:        Imaginary portion of gamma</span>
<span class="sd">    """</span>
    <span class="c1"># Validate the line length is substantial enough for calculation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">"Long transmission line length should be grater than 500km"</span>
        <span class="p">)</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">real</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">imag</span>
    <span class="n">zc</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">z</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">'gamma'</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
        <span class="s1">'alpha'</span><span class="p">:</span> <span class="n">alpha</span><span class="p">,</span>
        <span class="s1">'beta'</span><span class="p">:</span> <span class="n">beta</span><span class="p">,</span>
        <span class="s1">'Surge_impedance'</span><span class="p">:</span> <span class="n">zc</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">params</span></div>


<span class="c1"># Define De Calculator for Transmission Lines</span>
<div class="viewcode-block" id="de_calc"><a class="viewcode-back" href="../api/electricpy.de_calc.html#electricpy.de_calc">[docs]</a><span class="k">def</span> <span class="nf">de_calc</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    De Transmission Line Value Calculator.</span>

<span class="sd">    Simple calculator to find the De value for a line</span>
<span class="sd">    with particular earth resistivity (rho).</span>

<span class="sd">    .. math:: D_e=D_{e_{\text{constant}}}\sqrt{\frac{\rho}{freq}}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rho:        float</span>
<span class="sd">                Earth resistivity (in ohm-meters), may also</span>
<span class="sd">                be passed a string in the set: {SEA, SWAMP,</span>
<span class="sd">                AVG,AVERAGE,DAMP,DRY,SAND,SANDSTONE}</span>
<span class="sd">    freq:       float, optional</span>
<span class="sd">                System frequency in Hertz, default=60</span>
<span class="sd">    """</span>
    <span class="c1"># If Descriptive String Provided, Use to Determine Rho</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">RHO_VALUES</span><span class="p">[</span><span class="n">rho</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Invalid Earth Resistivity string try to select </span><span class="se">\</span>
<span class="s2">            from set of (SEA, SWAMP, AVG, AVERAGE, DAMP, DRY, SAND, SANDSTONE"</span><span class="p">)</span>
    <span class="c1"># Calculate De</span>
    <span class="n">De</span> <span class="o">=</span> <span class="n">De0</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rho</span> <span class="o">/</span> <span class="n">freq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">De</span></div>


<span class="c1"># Define Impedance Per Length Calculator</span>
<div class="viewcode-block" id="zperlength"><a class="viewcode-back" href="../api/electricpy.zperlength.html#electricpy.zperlength">[docs]</a><span class="k">def</span> <span class="nf">zperlength</span><span class="p">(</span><span class="n">Rd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Rself</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Rac</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Rgwac</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">De</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">rho</span><span class="o">=</span><span class="s2">"AVG"</span><span class="p">,</span> <span class="n">Ds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Dsgw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dia_gw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Dab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">Dbc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Dca</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Dagw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Dbgw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Dcgw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">resolve</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Transmission Line Impedance (RL) Calculator.</span>

<span class="sd">    Simple impedance matrix generator to provide the full</span>
<span class="sd">    impedance per length matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Rd:         float, optional</span>
<span class="sd">                Resistance Rd term in ohms, will be generated</span>
<span class="sd">                automatically if set to None, default=None</span>
<span class="sd">    Rself:      float, optional</span>
<span class="sd">                Self Resistance term in ohms.</span>
<span class="sd">    Rac:        float, optional</span>
<span class="sd">                AC resistance in ohms.</span>
<span class="sd">    Rgwac:      float, optional</span>
<span class="sd">                Ground-Wire AC resistance in ohms.</span>
<span class="sd">    De:         float, optional</span>
<span class="sd">                De term, in feet, if None provided, and `rho`</span>
<span class="sd">                parameter is specified, will interpretively be</span>
<span class="sd">                calculated.</span>
<span class="sd">    rho:        float, optional</span>
<span class="sd">                Earth resistivity in ohm-meters. default="AVG"</span>
<span class="sd">    Ds:         float, optional</span>
<span class="sd">                Distance (self) for each phase conductor in feet,</span>
<span class="sd">                commonly known as GMD.</span>
<span class="sd">    Dsgw:       float, optional</span>
<span class="sd">                Distance (self) for the ground wire conductor in</span>
<span class="sd">                feet, commonly known as GMD.</span>
<span class="sd">    dia_gw:     float, optional</span>
<span class="sd">                Ground-Wire diameter in feet, may be used to</span>
<span class="sd">                calculate an approximate Dsgw if no Dsgw is provided.</span>
<span class="sd">    Dab:        float, optional</span>
<span class="sd">                Distance between phases A and B, in feet.</span>
<span class="sd">    Dbc:        float, optional</span>
<span class="sd">                Distance between phases B and C, in feet.</span>
<span class="sd">    Dca:        float, optional</span>
<span class="sd">                Distance between phases C and A, in feet.</span>
<span class="sd">    Dagw:       float, optional</span>
<span class="sd">                Distance between phase A and ground conductor, in feet.</span>
<span class="sd">    Dbgw:       float, optional</span>
<span class="sd">                Distance between phase B and ground conductor, in feet.</span>
<span class="sd">    Dcgw:       float, optional</span>
<span class="sd">                Distance between phase C and ground conductor, in feet.</span>
<span class="sd">    resolve:    bool, optional</span>
<span class="sd">                Control argument to specify whether the resultant</span>
<span class="sd">                ground-wire inclusive per-length impedance matrix</span>
<span class="sd">                should be reduced to a 3x3 equivalent matrix.</span>
<span class="sd">                default=True</span>
<span class="sd">    freq:       float, optional</span>
<span class="sd">                System frequency in Hertz.</span>
<span class="sd">    """</span>
    <span class="c1"># Start with Empty Arrays</span>
    <span class="n">Rperlen</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Lperlen</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Generate Rd</span>
    <span class="k">if</span> <span class="n">Rd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Rd</span> <span class="o">=</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">carson_r</span>
    <span class="c1"># Generate Dsgw if Not Provided</span>
    <span class="k">if</span> <span class="n">Dsgw</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dia_gw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Dsgw</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">dia_gw</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="c1"># Generate Real Part</span>
    <span class="k">if</span> <span class="n">Rd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Generate Rself if not Provided</span>
        <span class="k">if</span> <span class="n">Rself</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Validate Inputs</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">((</span><span class="n">Rd</span><span class="p">,</span> <span class="n">Rac</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Too few arguments"</span><span class="p">)</span>
            <span class="n">Rself</span> <span class="o">=</span> <span class="n">Rac</span> <span class="o">+</span> <span class="n">Rd</span>
        <span class="c1"># Generate RperLength Matrix</span>
        <span class="n">Rperlen</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="n">Rself</span><span class="p">,</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rd</span><span class="p">],</span>
            <span class="p">[</span><span class="n">Rd</span><span class="p">,</span> <span class="n">Rself</span><span class="p">,</span> <span class="n">Rd</span><span class="p">],</span>
            <span class="p">[</span><span class="n">Rd</span><span class="p">,</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rself</span><span class="p">]</span>
        <span class="p">])</span>
        <span class="c1"># Add GW effects If Necessary</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">((</span><span class="n">Rgwac</span><span class="p">,</span> <span class="n">Dsgw</span><span class="p">,</span> <span class="n">Dagw</span><span class="p">,</span> <span class="n">Dbgw</span><span class="p">,</span> <span class="n">Dcgw</span><span class="p">)):</span>
            <span class="c1"># Calculate Rselfgw</span>
            <span class="n">Rselfgw</span> <span class="o">=</span> <span class="n">Rgwac</span> <span class="o">+</span> <span class="n">Rd</span>
            <span class="c1"># Append Right-Most Column</span>
            <span class="n">Rperlen</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Rperlen</span><span class="p">,</span>
                                 <span class="p">[[</span><span class="n">Rd</span><span class="p">],</span> <span class="p">[</span><span class="n">Rd</span><span class="p">],</span> <span class="p">[</span><span class="n">Rd</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Append New Row</span>
            <span class="n">Rperlen</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Rperlen</span><span class="p">,</span>
                                 <span class="p">[[</span><span class="n">Rd</span><span class="p">,</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rselfgw</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Generate Imaginary Part</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">De</span><span class="p">,</span> <span class="n">Ds</span><span class="p">,</span> <span class="n">rho</span><span class="p">)):</span>
        <span class="c1"># Validate Inputs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">((</span><span class="n">Dab</span><span class="p">,</span> <span class="n">Dbc</span><span class="p">,</span> <span class="n">Dca</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Distance Terms [Dab,Dbc,Dca] Required"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Distance Self (Ds) Required"</span><span class="p">)</span>
        <span class="c1"># De must be generated</span>
        <span class="k">if</span> <span class="n">De</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Too few arguments"</span><span class="p">)</span>
            <span class="n">De</span> <span class="o">=</span> <span class="n">de_calc</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>
        <span class="c1"># Generate LperLength Matrix</span>
        <span class="n">Lperlen</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">De</span> <span class="o">/</span> <span class="n">Ds</span><span class="p">),</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">De</span> <span class="o">/</span> <span class="n">Dab</span><span class="p">),</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">De</span> <span class="o">/</span> <span class="n">Dca</span><span class="p">)],</span>
            <span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">De</span> <span class="o">/</span> <span class="n">Dab</span><span class="p">),</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">De</span> <span class="o">/</span> <span class="n">Ds</span><span class="p">),</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">De</span> <span class="o">/</span> <span class="n">Dbc</span><span class="p">)],</span>
            <span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">De</span> <span class="o">/</span> <span class="n">Dca</span><span class="p">),</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">De</span> <span class="o">/</span> <span class="n">Dbc</span><span class="p">),</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">De</span> <span class="o">/</span> <span class="n">Ds</span><span class="p">)]</span>
        <span class="p">])</span>
        <span class="c1"># Add GW effects If Necessary</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">((</span><span class="n">Rgwac</span><span class="p">,</span> <span class="n">Dsgw</span><span class="p">,</span> <span class="n">Dagw</span><span class="p">,</span> <span class="n">Dbgw</span><span class="p">,</span> <span class="n">Dcgw</span><span class="p">)):</span>
            <span class="c1"># Append Right-Most Column</span>
            <span class="n">Lperlen</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Lperlen</span><span class="p">,</span>
                                 <span class="p">[[</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">De</span> <span class="o">/</span> <span class="n">Dagw</span><span class="p">)],</span> <span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">De</span> <span class="o">/</span> <span class="n">Dbgw</span><span class="p">)],</span>
                                  <span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">De</span> <span class="o">/</span> <span class="n">Dcgw</span><span class="p">)]],</span>
                                 <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Append New Row</span>
            <span class="n">Lperlen</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Lperlen</span><span class="p">,</span>
                                 <span class="p">[[</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">De</span> <span class="o">/</span> <span class="n">Dagw</span><span class="p">),</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">De</span> <span class="o">/</span> <span class="n">Dbgw</span><span class="p">),</span>
                                   <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">De</span> <span class="o">/</span> <span class="n">Dcgw</span><span class="p">),</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">De</span> <span class="o">/</span> <span class="n">Dsgw</span><span class="p">)]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">Lperlen</span> <span class="o">=</span> <span class="n">Lperlen</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">u0</span> <span class="o">*</span> <span class="n">freq</span><span class="p">)</span>
    <span class="c1"># Add Real and Imaginary Parts</span>
    <span class="n">Zperlen</span> <span class="o">=</span> <span class="n">Rperlen</span> <span class="o">+</span> <span class="n">Lperlen</span>
    <span class="c1"># Resolve to 3x3 Matrix if Needed</span>
    <span class="k">if</span> <span class="n">resolve</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">((</span><span class="n">Rgwac</span><span class="p">,</span> <span class="n">Dsgw</span><span class="p">,</span> <span class="n">Dagw</span><span class="p">,</span> <span class="n">Dbgw</span><span class="p">,</span> <span class="n">Dcgw</span><span class="p">)):</span>
        <span class="c1"># Perform Slicing to Retrieve Useful Arrays</span>
        <span class="n">Za</span> <span class="o">=</span> <span class="n">Zperlen</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">Zb</span> <span class="o">=</span> <span class="n">Zperlen</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">Zc</span> <span class="o">=</span> <span class="n">Zperlen</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">Zd</span> <span class="o">=</span> <span class="n">Zperlen</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
        <span class="c1"># Calculate New (3x3) Equivalent Zperlen</span>
        <span class="n">Zperlen</span> <span class="o">=</span> <span class="n">Za</span> <span class="o">-</span> <span class="n">_np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Zb</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Zd</span><span class="p">),</span> <span class="n">Zc</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Zperlen</span></div>


<span class="c1"># Define Transposition Matrix Formula</span>
<div class="viewcode-block" id="transposez"><a class="viewcode-back" href="../api/electricpy.transposez.html#electricpy.transposez">[docs]</a><span class="k">def</span> <span class="nf">transposez</span><span class="p">(</span><span class="n">Zeq</span><span class="p">,</span> <span class="n">fabc</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="n">fcab</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="n">fbca</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="n">linelen</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Transmission Matrix Equivalent Transposition Calculator.</span>

<span class="sd">    Given the impedance matrix and the percent of the line spent</span>
<span class="sd">    in each transposition relation (ABC, CAB, and BCA).</span>

<span class="sd">    .. math::</span>
<span class="sd">       f_{abc}Z_{eq}+f_{cab}R_p^{-1}\cdot Z_{eq}\cdot R_p+</span>
<span class="sd">       f_{bca}Z_{eq}R_p\cdot Z_{eq}\cdot R_p^{-1}</span>

<span class="sd">    where:</span>

<span class="sd">    .. math:</span>
<span class="sd">       R_p=\begin{bmatrix}\\</span>
<span class="sd">       0 &amp; 0 &amp; 1 \\</span>
<span class="sd">       1 &amp; 0 &amp; 0 \\</span>
<span class="sd">       0 &amp; 1 &amp; 0 \\</span>
<span class="sd">       \end{bmatrix}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Zeq:        array_like</span>
<span class="sd">                Per-Length (or total length) line impedance in ohms.</span>
<span class="sd">    fabc:       float, optional</span>
<span class="sd">                Percentage of line set with phase relation ABC,</span>
<span class="sd">                default=1/3</span>
<span class="sd">    fcab:       float, optional</span>
<span class="sd">                Percentage of line set with phase relation CAB,</span>
<span class="sd">                default=1/3</span>
<span class="sd">    fbca:       float, optional</span>
<span class="sd">                Percentage of line set with phase relation BCA,</span>
<span class="sd">                default=1/3</span>
<span class="sd">    linelen:    Length of line (unitless), default=1</span>
<span class="sd">    """</span>
    <span class="c1"># Condition Input</span>
    <span class="n">Zeq</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Zeq</span><span class="p">)</span>
    <span class="c1"># Define Rp Array</span>
    <span class="n">Rp</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="p">])</span>
    <span class="c1"># Define Inverse Rp Array</span>
    <span class="n">_Rp</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Rp</span><span class="p">)</span>
    <span class="n">Zeq</span> <span class="o">=</span> <span class="n">fabc</span> <span class="o">*</span> <span class="n">Zeq</span> <span class="o">+</span> <span class="n">fcab</span> <span class="o">*</span> <span class="p">(</span><span class="n">_Rp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Zeq</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Rp</span><span class="p">)))</span> <span class="o">+</span> \
        <span class="n">fbca</span> <span class="o">*</span> <span class="p">(</span><span class="n">Rp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Zeq</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_Rp</span><span class="p">)))</span>
    <span class="n">Zeq</span> <span class="o">=</span> <span class="n">Zeq</span> <span class="o">*</span> <span class="n">linelen</span>
    <span class="k">return</span> <span class="n">Zeq</span></div>


<span class="c1"># Define GMD Calculator</span>
<div class="viewcode-block" id="gmd"><a class="viewcode-back" href="../api/electricpy.gmd.html#electricpy.gmd">[docs]</a><span class="k">def</span> <span class="nf">gmd</span><span class="p">(</span><span class="n">Ds</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    GMD (Geometric Mean Distance) Calculator.</span>

<span class="sd">    Calculates the GMD (Geometric Mean Distance) for a system</span>
<span class="sd">    with the parameters of a list of arguments.</span>

<span class="sd">    .. math:: GMD=(D_s*D_1*\ddot*D_n)^{\frac{1}{1+n}}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Ds:         float</span>
<span class="sd">                Self distance (unitless), normally provided from</span>
<span class="sd">                datasheet/reference</span>
<span class="sd">    *args:      floats, optional</span>
<span class="sd">                Remaining set of distance values (unitless)</span>
<span class="sd">    """</span>
    <span class="c1"># Find the Root from Number of Arguments</span>
    <span class="n">root</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1"># Calculate the Root Term</span>
    <span class="n">gmdx</span> <span class="o">=</span> <span class="n">Ds</span>
    <span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">gmdx</span> <span class="o">*=</span> <span class="n">dist</span>
    <span class="c1"># Apply Root Calculation</span>
    <span class="n">GMD</span> <span class="o">=</span> <span class="n">gmdx</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">GMD</span></div>


<span class="c1"># Define Power-Factor Voltage/Current Relation</span>
<div class="viewcode-block" id="vipf"><a class="viewcode-back" href="../api/electricpy.vipf.html#electricpy.vipf">[docs]</a><span class="k">def</span> <span class="nf">vipf</span><span class="p">(</span><span class="n">V</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">PF</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">find</span><span class="o">=</span><span class="s1">''</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Voltage / Current / Power Factor Solver.</span>

<span class="sd">    Given two of the three parameters, will solve for the</span>
<span class="sd">    third; beit voltage, current, or power factor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    V:          complex</span>
<span class="sd">                System voltage (in volts), default=None</span>
<span class="sd">    I:          complex</span>
<span class="sd">                System current (in amps), default=None</span>
<span class="sd">    PF:         float</span>
<span class="sd">                System power factor, (+)ive values denote</span>
<span class="sd">                leading power factor, (-)ive values denote</span>
<span class="sd">                lagging power factor; default=1</span>
<span class="sd">    find:       str, optional</span>
<span class="sd">                Control argument to specify which value</span>
<span class="sd">                should be returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    V:          complex</span>
<span class="sd">                System voltage (in volts), default=None</span>
<span class="sd">    I:          complex</span>
<span class="sd">                System current (in amps), default=None</span>
<span class="sd">    PF:         float</span>
<span class="sd">                System power factor, (+)ive values denote</span>
<span class="sd">                leading power factor, (-)ive values denote</span>
<span class="sd">                lagging poer factor; default=1</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import electricpy as ep</span>
<span class="sd">    &gt;&gt;&gt; # Demonstrate the generic functionality</span>
<span class="sd">    &gt;&gt;&gt; ep.vipf(V=480, I=ep.phasors.phasor(20, 120))</span>
<span class="sd">    (480, (-9.999999999999996+17.320508075688775j), -0.499999...)</span>
<span class="sd">    &gt;&gt;&gt; # Find the power factor</span>
<span class="sd">    &gt;&gt;&gt; ep.vipf(V=480, I=ep.phasors.phasor(20, 120), find="PF")</span>
<span class="sd">    -0.49999...</span>
<span class="sd">    """</span>
    <span class="c1"># Test to find Voltage</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="nb">complex</span><span class="p">):</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="o">-</span><span class="n">_np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">PF</span><span class="p">)</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">PF</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">V</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">)</span>
    <span class="c1"># Test to find Current</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">PF</span><span class="p">)</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">PF</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span><span class="p">)</span>
    <span class="c1"># Test to find Power Factor</span>
    <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="n">V</span><span class="p">,</span> <span class="n">I</span><span class="p">]):</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">-</span> <span class="n">_np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
        <span class="n">PF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="c1"># Failed Mode</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"All values must be provided."</span><span class="p">)</span>
    <span class="c1"># Return</span>
    <span class="n">find</span> <span class="o">=</span> <span class="n">find</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">find</span> <span class="o">==</span> <span class="s1">'V'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">V</span>
    <span class="k">if</span> <span class="n">find</span> <span class="o">==</span> <span class="s1">'I'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">I</span>
    <span class="k">if</span> <span class="n">find</span> <span class="o">==</span> <span class="s1">'PF'</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">PF</span>
    <span class="k">return</span> <span class="n">V</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">PF</span></div>


<span class="c1"># Define Synchronous Speed Calculator</span>
<div class="viewcode-block" id="syncspeed"><a class="viewcode-back" href="../api/electricpy.syncspeed.html#electricpy.syncspeed">[docs]</a><span class="k">def</span> <span class="nf">syncspeed</span><span class="p">(</span><span class="n">Npol</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">Hz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rpm</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># noqa: D401   "Synchronous" is an intentional descriptor</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Synchronous Speed Calculator Function.</span>

<span class="sd">    Simple method of calculating the synchronous speed of an induction machine</span>
<span class="sd">    given the number of poles in the machine's construction, and</span>
<span class="sd">    the machine's operating electrical frequency.</span>

<span class="sd">    .. math:: \omega_{\text{syn}}=\frac{2\pi</span>
<span class="sd">       \cdot\text{freq}}{\frac{N_{\text{pol}}}{2}}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Npol:       int</span>
<span class="sd">                Number of electrical poles in machine's construction.</span>
<span class="sd">    freq:       float, optional</span>
<span class="sd">                Frequency of electrical system in Hertz, default=60</span>
<span class="sd">    Hz:         bool, optional</span>
<span class="sd">                Boolean control to enable return in Hertz. default=False</span>
<span class="sd">    rpm:        bool, optional</span>
<span class="sd">                Boolean control to enable return in rpm. default=False</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    wsyn:       float</span>
<span class="sd">                Synchronous Speed of Induction Machine, defaults to units of</span>
<span class="sd">                rad/sec, but may be set to Hertz or RPM if `Hz` or `rpm` set to True.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">Npol</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">"Poles of an electrical machine </span><span class="se">\</span>
<span class="s2">        can not be zero"</span><span class="p">)</span>
    <span class="n">wsyn</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">/</span> <span class="p">(</span><span class="n">Npol</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Hz</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">freq</span> <span class="o">/</span> <span class="p">(</span><span class="n">Npol</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">rpm</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">120</span> <span class="o">*</span> <span class="n">freq</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">Npol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wsyn</span></div>


<span class="c1"># Define Machine Slip Calculation Function</span>
<div class="viewcode-block" id="machslip"><a class="viewcode-back" href="../api/electricpy.machslip.html#electricpy.machslip">[docs]</a><span class="k">def</span> <span class="nf">machslip</span><span class="p">(</span><span class="n">mech</span><span class="p">,</span> <span class="n">syn</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Machine Slip Calculator.</span>

<span class="sd">    Given the two parameters (mechanical and synchronous speed, or frequency)</span>
<span class="sd">    this function will return the unitless slip of the rotating machine.</span>

<span class="sd">    .. math:: \text{slip}=\frac{\text{syn}-\text{mech}}</span>
<span class="sd">       {\text{syn}}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mech:       float</span>
<span class="sd">                The mechanical frequency (or speed), of the rotating machine.</span>
<span class="sd">    syn:        float, optional</span>
<span class="sd">                The synchronous frequency (or speed), defaults as a frequency</span>
<span class="sd">                set to 60Hz, default=60</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    slip:       float</span>
<span class="sd">                The rotating machine's slip constant.</span>
<span class="sd">    """</span>
    <span class="n">slip</span> <span class="o">=</span> <span class="p">(</span><span class="n">syn</span> <span class="o">-</span> <span class="n">mech</span><span class="p">)</span> <span class="o">/</span> <span class="n">syn</span>
    <span class="k">return</span> <span class="n">slip</span></div>


<span class="c1"># Define 3-Phase Valpha Calculator</span>
<div class="viewcode-block" id="phs3valpha"><a class="viewcode-back" href="../api/electricpy.phs3valpha.html#electricpy.phs3valpha">[docs]</a><span class="k">def</span> <span class="nf">phs3valpha</span><span class="p">(</span><span class="n">VA</span><span class="p">,</span> <span class="n">VB</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">VC</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Three-Phase V-Alpha Calculator.</span>

<span class="sd">    Accepts the three-phase voltages for which the accumulated Alpha voltage</span>
<span class="sd">    should be calculated.</span>

<span class="sd">    .. math:: V_{\alpha}=V_A-\frac{V_B}{2}-\frac{V_C}{2}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    VA:         [float, complex]</span>
<span class="sd">                A-phase voltage, (or tuple/list of voltages), unitless.</span>
<span class="sd">    VB:         [float, complex], optional</span>
<span class="sd">                B-phase voltage, unitless.</span>
<span class="sd">    VC:         [float, complex], optional</span>
<span class="sd">                C-phase voltage, unitless.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Valpha:     [float, complex]</span>
<span class="sd">                Alpha-voltage as calculated from input three-phase voltages.</span>
<span class="sd">                Matches type of inputs.</span>
<span class="sd">    """</span>
    <span class="c1"># Handle Combined (list/tuple) Input</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">VA</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="n">VB</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">VC</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">VA</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Invalid input set, must "</span>
                             <span class="s2">"be list of three elements, three inputs,"</span>
                             <span class="s2">" or three array-like objects of equal "</span>
                             <span class="s2">"length."</span><span class="p">)</span>
        <span class="n">Valpha</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">VA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">VA</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="c1"># Handle Separated Inputs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Valpha</span> <span class="o">=</span> <span class="n">VA</span> <span class="o">-</span> <span class="n">VB</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">VC</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="c1"># Return the Alpha-Voltage</span>
    <span class="k">return</span> <span class="n">Valpha</span></div>


<div class="viewcode-block" id="wireresistance"><a class="viewcode-back" href="../api/electricpy.wireresistance.html#electricpy.wireresistance">[docs]</a><span class="k">def</span> <span class="nf">wireresistance</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">diameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="mf">16.8</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Wire Resistance Calculator.</span>

<span class="sd">    Enter three values to calculate the remaing one. Even though every variable</span>
<span class="sd">    is unitless, please use the International System of Units.</span>

<span class="sd">    .. math:: R = \frac{\rho*l}{A}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    length:     [float], optional</span>
<span class="sd">                Wire length, unitless</span>
<span class="sd">    diameter:   [float], optional</span>
<span class="sd">                Wire diameter, unitless.</span>
<span class="sd">    rho:        [float], optional</span>
<span class="sd">                Material resistivity, unitless</span>
<span class="sd">                Default value is copper resistivity: 16.8*10-9</span>
<span class="sd">    R:          [float], optional</span>
<span class="sd">                Wire resistance, unitless.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    length:     [float], optional</span>
<span class="sd">                Wire length, unitless</span>
<span class="sd">    diameter:   [float], optional</span>
<span class="sd">                Wire diameter, unitless.</span>
<span class="sd">    rho:        [float], optional</span>
<span class="sd">                Material resistivity, unitless</span>
<span class="sd">                Default value is copper resistivity: 16.8*10-9</span>
<span class="sd">    R:          [float], optional</span>
<span class="sd">                Wire resistance, unitless.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">R</span> <span class="o">==</span> <span class="n">length</span> <span class="o">==</span> <span class="n">diameter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"To few arguments."</span><span class="p">)</span>
    <span class="c1"># Given length and diameter</span>
    <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">diameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># calculating the area</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">diameter</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span>
        <span class="k">return</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">length</span> <span class="o">/</span> <span class="n">A</span>
    <span class="c1"># Given resistance and diameter</span>
    <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">diameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># calculating the area</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">diameter</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span>
        <span class="k">return</span> <span class="n">R</span> <span class="o">*</span> <span class="n">A</span> <span class="o">/</span> <span class="n">rho</span>
    <span class="c1"># Given resistance and length</span>
    <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">length</span> <span class="o">/</span> <span class="n">R</span>
        <span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">A</span> <span class="o">/</span> <span class="n">pi</span><span class="p">)</span></div>


<div class="viewcode-block" id="parallel_plate_capacitance"><a class="viewcode-back" href="../api/electricpy.parallel_plate_capacitance.html#electricpy.parallel_plate_capacitance">[docs]</a><span class="k">def</span> <span class="nf">parallel_plate_capacitance</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="n">e0</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Parallel-Plate Capacitance Calculator.</span>

<span class="sd">    Enter three values to calculate the remaing one. Even though every variable</span>
<span class="sd">    is unitless, please use the International System of Units.</span>

<span class="sd">    .. math:: C = \frac{\varepsilon \cdot A}{d}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A:  float, optional</span>
<span class="sd">        Area of the plate, unitless.</span>
<span class="sd">    d:  float, optional</span>
<span class="sd">        Distance between the plates, unitless.</span>
<span class="sd">    e:  float, optional</span>
<span class="sd">        Permitivity of the dielectric, unitless.</span>
<span class="sd">        Default value is the permittivity of free space: 8.854E-12</span>
<span class="sd">    C:  float, optional</span>
<span class="sd">        Capacitance, unitless.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A:  float, optional</span>
<span class="sd">        Area of the plate, unitless.</span>
<span class="sd">    d:  float, optional</span>
<span class="sd">        Distance between the plates, unitless.</span>
<span class="sd">    e:  float, optional</span>
<span class="sd">        Permitivity of the dielectric, unitless.</span>
<span class="sd">        Default value is the permittivity of free space: 8.854E-12</span>
<span class="sd">    C:  float, optional</span>
<span class="sd">        Capacitance, unitless.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">C</span> <span class="o">==</span> <span class="n">A</span> <span class="o">==</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"To few arguments."</span><span class="p">)</span>
    <span class="c1"># Given area and distance</span>
    <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span> <span class="o">*</span> <span class="n">A</span> <span class="o">/</span> <span class="n">d</span>
    <span class="c1"># Given capacitance and distance</span>
    <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">d</span> <span class="o">*</span> <span class="n">C</span> <span class="o">/</span> <span class="n">e</span>
    <span class="c1"># Given capacitance and area</span>
    <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span> <span class="o">*</span> <span class="n">A</span> <span class="o">/</span> <span class="n">C</span></div>


<div class="viewcode-block" id="solenoid_inductance"><a class="viewcode-back" href="../api/electricpy.solenoid_inductance.html#electricpy.solenoid_inductance">[docs]</a><span class="k">def</span> <span class="nf">solenoid_inductance</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">u0</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Solenoid Inductance Calculator.</span>

<span class="sd">    Enter four values to calculate the remaing one. Even though every variable</span>
<span class="sd">    is unitless, please use the International System of Units.</span>

<span class="sd">    .. math:: L = \frac{\mu \cdot N^2 \cdot A}{l}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A:  float, optional</span>
<span class="sd">        Cross sectional area, unitless.</span>
<span class="sd">    l:  float, optional</span>
<span class="sd">        Length, unitless.</span>
<span class="sd">    N:  float, optional</span>
<span class="sd">        Number of turns, unitless.</span>
<span class="sd">    u:  float, optional</span>
<span class="sd">        Core permeability, unitless.</span>
<span class="sd">        Default value is the permeability of free space: 4πE-7</span>
<span class="sd">    L:  float, optional</span>
<span class="sd">        Inductance, unitless.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A:  float, optional</span>
<span class="sd">        Cross sectional area, unitless.</span>
<span class="sd">    l:  float, optional</span>
<span class="sd">        Length, unitless.</span>
<span class="sd">    N:  float, optional</span>
<span class="sd">        Number of turns, unitless.</span>
<span class="sd">    u:  float, optional</span>
<span class="sd">        Core permeability, unitless.</span>
<span class="sd">        Default value is the permeability of free space: 4πE-7</span>
<span class="sd">    L:  float, optional</span>
<span class="sd">        Inductance, unitless.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">L</span> <span class="o">==</span> <span class="n">A</span> <span class="o">==</span> <span class="n">l</span> <span class="o">==</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"To few arguments."</span><span class="p">)</span>
    <span class="c1"># Given area, length and number of turns</span>
    <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">l</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">N</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">N</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="n">A</span> <span class="o">/</span> <span class="n">l</span>
    <span class="c1"># Given inductance, length and number of turns</span>
    <span class="k">if</span> <span class="n">L</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">l</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">N</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">L</span> <span class="o">*</span> <span class="n">l</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span>
    <span class="c1"># Given inductance, area and number of turns</span>
    <span class="k">if</span> <span class="n">L</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">N</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">N</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="n">A</span> <span class="o">/</span> <span class="n">L</span>
    <span class="c1"># Given inductance, area and length</span>
    <span class="k">if</span> <span class="n">L</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">l</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">L</span> <span class="o">*</span> <span class="n">l</span> <span class="o">/</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">A</span><span class="p">))</span></div>


<div class="viewcode-block" id="ic_555_astable"><a class="viewcode-back" href="../api/electricpy.ic_555_astable.html#electricpy.ic_555_astable">[docs]</a><span class="k">def</span> <span class="nf">ic_555_astable</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_high</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_low</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    555 Integrated Circuit Calculator.</span>

<span class="sd">    Evaluate a number of common attributes related to the common 555 integrated</span>
<span class="sd">    circuit including time period, frequency, duty cycle, time spent low during</span>
<span class="sd">    each cycle, time spent high during each cycle.</span>

<span class="sd">    TODO: This function should be broken into multiple smaller functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R:      list[float, float] or tuple(float, float), optional</span>
<span class="sd">            List of 2 resistor which are need in configuring IC 555.</span>
<span class="sd">    C:      float, optional</span>
<span class="sd">            Capacitance between Threshold Pin and ground</span>
<span class="sd">    f:      float, optional</span>
<span class="sd">            Electrical system frequency in Hertz.</span>
<span class="sd">    t_high: float, optional</span>
<span class="sd">            ON time of IC 555</span>
<span class="sd">    t_low:  float, optional</span>
<span class="sd">            OFF time of IC 555</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict:   "time_period": Time period of oscillating IC 555</span>
<span class="sd">            "frequency": frequency of oscilation of IC 555</span>
<span class="sd">            "duty_cycle": ration between ON time and total time</span>
<span class="sd">            "t_low": ON time of IC 555</span>
<span class="sd">            "t_high": OFF time of IC 555</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">C</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"Monostable 555 IC will have only 2 resitances to be fixed "</span>
                <span class="sa">f</span><span class="s2">"but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="si">}</span><span class="s2"> were given"</span>
            <span class="p">)</span>

        <span class="p">[</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">C</span> <span class="o">*</span> <span class="p">(</span><span class="n">R1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">R2</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">T</span>
        <span class="n">t_low</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">C</span> <span class="o">*</span> <span class="n">R2</span>
        <span class="n">t_high</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">C</span> <span class="o">*</span> <span class="p">(</span><span class="n">R1</span> <span class="o">+</span> <span class="n">R2</span><span class="p">)</span>
        <span class="n">duty_cycle</span> <span class="o">=</span> <span class="n">t_high</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">T</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">'time_period'</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
            <span class="s1">'frequency'</span><span class="p">:</span> <span class="n">freq</span><span class="p">,</span>
            <span class="s1">'duty_cycle'</span><span class="p">:</span> <span class="n">duty_cycle</span><span class="p">,</span>
            <span class="s1">'t_low'</span><span class="p">:</span> <span class="n">t_low</span><span class="p">,</span>
            <span class="s1">'t_high'</span><span class="p">:</span> <span class="n">t_high</span>
        <span class="p">}</span>

    <span class="k">if</span> <span class="n">t_high</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">t_low</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">C</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">x2</span> <span class="o">=</span> <span class="n">t_low</span> <span class="o">/</span> <span class="n">C</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">t_high</span> <span class="o">/</span> <span class="n">C</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">t_high</span> <span class="o">+</span> <span class="n">t_low</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span class="n">duty_cycle</span> <span class="o">=</span> <span class="n">t_high</span> <span class="o">/</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">'time_period'</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
            <span class="s1">'frequency'</span><span class="p">:</span> <span class="n">freq</span><span class="p">,</span>
            <span class="s1">'duty_cycle'</span><span class="p">:</span> <span class="n">duty_cycle</span><span class="p">,</span>
            <span class="s1">'R1'</span><span class="p">:</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">,</span>
            <span class="s1">'R2'</span><span class="p">:</span> <span class="n">x2</span>
        <span class="p">}</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Not enough parqmeters are passed"</span><span class="p">)</span></div>


<div class="viewcode-block" id="ic_555_monostable"><a class="viewcode-back" href="../api/electricpy.ic_555_monostable.html#electricpy.ic_555_monostable">[docs]</a><span class="k">def</span> <span class="nf">ic_555_monostable</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_high</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t_low</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    555 Integrated Circuit Calculator.</span>

<span class="sd">    Evaluate a number of common attributes related to the common 555 integrated</span>
<span class="sd">    circuit including time period, frequency, duty cycle, time spent low during</span>
<span class="sd">    each cycle, time spent high during each cycle.</span>

<span class="sd">    TODO: This function should be broken into multiple smaller functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R:      list[float, float] or tuple(float, float), optional</span>
<span class="sd">            List of 2 resistor which are need in configuring IC 555.</span>
<span class="sd">    C:      float, optional</span>
<span class="sd">            Capacitance between Threshold Pin and ground</span>
<span class="sd">    f:      float, optional</span>
<span class="sd">            Electrical system frequency in Hertz.</span>
<span class="sd">    t_high: float, optional</span>
<span class="sd">            ON time of IC 555</span>
<span class="sd">    t_low:  float, optional</span>
<span class="sd">            OFF time of IC 555</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict:   "time_period": Time period of oscillating IC 555</span>
<span class="sd">            "frequency": frequency of oscilation of IC 555</span>
<span class="sd">            "duty_cycle": ration between ON time and total time</span>
<span class="sd">            "t_low": ON time of IC 555</span>
<span class="sd">            "t_high": OFF time of IC 555</span>
<span class="sd">    """</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">t_high</span> <span class="o">+</span> <span class="n">t_low</span>
    <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">C</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">T</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"To find Resitance, Capacitance and delay time should be "</span>
                <span class="s2">"provided"</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">T</span> <span class="o">/</span> <span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">C</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">R</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">T</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"To find Capacitance , Resistance and delay time should be "</span>
                <span class="s2">"provided"</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">T</span> <span class="o">/</span> <span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">T</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">R</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">T</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"To find Time delay , Resistance and Capacitance should be "</span>
                <span class="s2">"provided"</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">R</span> <span class="o">*</span> <span class="n">C</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span></div>


<div class="viewcode-block" id="t_attenuator"><a class="viewcode-back" href="../api/electricpy.t_attenuator.html#electricpy.t_attenuator">[docs]</a><span class="k">def</span> <span class="nf">t_attenuator</span><span class="p">(</span><span class="n">Adb</span><span class="p">,</span> <span class="n">Z0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    T attenuator.</span>

<span class="sd">    The T attenuator is a type of attenuator that looks like the letter T.</span>
<span class="sd">    The T attenuator consists of three resistors. Two of these are connected in</span>
<span class="sd">    series and the other one is connected from between the two other resistors</span>
<span class="sd">    to ground. The resistors in series often have the same resistance.</span>

<span class="sd">    .. math:: R1 = Z0*(\frac{10^{\frac{A_{db}}{20}}-1}{10^{\frac{A_{db}}{20}}+1});</span>
<span class="sd">    .. math:: R2 = Z0*(\frac{10^{\frac{A_{db}}{20}}}{10^{\frac{A_{db}}{10}}-1})</span>

<span class="sd">    .. image:: /static/t-attenuator-circuit.png</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Adb: float Attenuation in db</span>
<span class="sd">    Z0: float Impedence</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R1: float T attenuator R1</span>
<span class="sd">    R2: float T attenuator R2</span>
<span class="sd">    """</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Adb</span> <span class="o">/</span> <span class="mi">20</span>

    <span class="n">R1</span> <span class="o">=</span> <span class="n">Z0</span> <span class="o">*</span> <span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">R2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Z0</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span></div>


<div class="viewcode-block" id="pi_attenuator"><a class="viewcode-back" href="../api/electricpy.pi_attenuator.html#electricpy.pi_attenuator">[docs]</a><span class="k">def</span> <span class="nf">pi_attenuator</span><span class="p">(</span><span class="n">Adb</span><span class="p">,</span> <span class="n">Z0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Pi attenuator.</span>

<span class="sd">    The Pi attenuator is a type of attenuator that looks like the Greek letter π.</span>
<span class="sd">    The Pi attenuator consists of three resistors. One of these is connected in series and</span>
<span class="sd">    the other two are connected in parallel to ground. The parallel resistors often have the same resistance.</span>

<span class="sd">    .. math:: R1 = Z0*(\frac{10^{\frac{A_{db}}{20}}+1}{10^{\frac{A_{db}}{20}}-1})</span>
<span class="sd">    .. math:: R2 = \frac{Z0}{2}*(10^{\frac{A_{db}}{20}} - \frac{1}{10^{\frac{A_{db}}{20}}})</span>
<span class="sd">    .. image:: /static/pi-attenuator-circuit.png</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Adb: float Attenuation in db</span>
<span class="sd">    Z0: float Impedence</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R1: float π attenuator R1</span>
<span class="sd">    R2: float π attenuator R2</span>
<span class="sd">    """</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Adb</span> <span class="o">/</span> <span class="mi">20</span>

    <span class="n">R1</span> <span class="o">=</span> <span class="n">Z0</span> <span class="o">*</span> <span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">R2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Z0</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">x</span><span class="p">))))</span>

    <span class="k">return</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span></div>


<span class="c1"># Calculate Zener Diode Resistor</span>
<div class="viewcode-block" id="zener_diode_required_resistor"><a class="viewcode-back" href="../api/electricpy.zener_diode_required_resistor.html#electricpy.zener_diode_required_resistor">[docs]</a><span class="k">def</span> <span class="nf">zener_diode_required_resistor</span><span class="p">(</span><span class="n">Vin</span><span class="p">,</span> <span class="n">Vo</span><span class="p">,</span> <span class="n">I</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Zener diode required resistance function .</span>

<span class="sd">    A zener diode is uses to allow current to flow "backwards" when the zener</span>
<span class="sd">    voltage is reached. This function use to calculate the required resistor</span>
<span class="sd">    value following below formula:</span>

<span class="sd">    .. math:: R = \frac{V_{in(min)} - V_{out}}{I_{load}+0.01}</span>

<span class="sd">    .. image:: /static/zenerdiode.png</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Vin:        float</span>
<span class="sd">                Minimum input Voltage in Volt</span>
<span class="sd">    Vo:         float</span>
<span class="sd">                Output Voltage in Volt</span>
<span class="sd">    I:          float</span>
<span class="sd">                Load Current in Ampere</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R:          float</span>
<span class="sd">                Load Resistance in Ohm</span>
<span class="sd">    """</span>
    <span class="c1"># Solve Load Resistance</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vin</span> <span class="o">-</span> <span class="n">Vo</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">I</span><span class="o">+</span><span class="mf">0.01</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span></div>

<span class="c1"># Calculate Zener Diode Power</span>


<div class="viewcode-block" id="zener_diode_power"><a class="viewcode-back" href="../api/electricpy.zener_diode_power.html#electricpy.zener_diode_power">[docs]</a><span class="k">def</span> <span class="nf">zener_diode_power</span><span class="p">(</span><span class="n">Vin</span><span class="p">,</span> <span class="n">Vo</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Zener diode power loss function.</span>

<span class="sd">    A zener diode is uses to allow current to flow "backwards" when the zener</span>
<span class="sd">    voltage is reached. This function use to calculate the power in resistor</span>
<span class="sd">    following below formula:</span>

<span class="sd">    .. math:: P_R = \frac{(V_{out} - V_{in(max)})^2}{R}</span>

<span class="sd">    .. image:: /static/zenerdiode.png</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Vin:        float</span>
<span class="sd">                Maximum input Voltage in Volt</span>
<span class="sd">    Vo:         float</span>
<span class="sd">                Output Voltage in Volt</span>
<span class="sd">    R:          float</span>
<span class="sd">                Load Resistance in Ohm</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P:          float</span>
<span class="sd">                Power on resistance in Watt</span>
<span class="sd">    """</span>
    <span class="c1"># Validate Inputs</span>
    <span class="k">if</span> <span class="n">R</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Resistance Value can not be zero"</span><span class="p">)</span>

    <span class="c1"># Solve Load Resistance</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">((</span><span class="n">Vo</span> <span class="o">-</span> <span class="n">Vin</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">R</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span></div>


<div class="viewcode-block" id="lm317"><a class="viewcode-back" href="../api/electricpy.lm317.html#electricpy.lm317">[docs]</a><span class="k">def</span> <span class="nf">lm317</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">v_out</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    LM317 linear voltage regulator solver.</span>

<span class="sd">    The LM317 is a linear voltage regulator that can be adjusted to supply a</span>
<span class="sd">    specific output voltage. The LM317 has three pins, adjust, output and input.</span>
<span class="sd">    The LM317 is often connected as in the image below. [1]_</span>


<span class="sd">    .. image:: https://www.basictables.com/media/lm317-circuit.png</span>


<span class="sd">    Formula to Calculate Output Voltage, R1, R2:</span>

<span class="sd">    .. math:: V_{out} = 1.25 * (1+\frac{R2}{R1})</span>

<span class="sd">    .. math:: R1 = \frac{1.25*R2}{V_{out}-1.25}</span>

<span class="sd">    .. math:: R2 = \frac{R1*V_{out}}{1.25 - R1}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v_out: float, Optional</span>
<span class="sd">           Output Voltage in LM317 in Volts</span>
<span class="sd">    r1:    float, Optional</span>
<span class="sd">           r1 is resistance and is measured in ohm</span>
<span class="sd">    r2:    float, Optional</span>
<span class="sd">           r2 is resistance and is measured in ohm</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    v_out: float</span>
<span class="sd">           v_out is the output voltage and is measured in volt (V)</span>
<span class="sd">    r1:    float</span>
<span class="sd">           r1 is resistance and is measured in ohm</span>
<span class="sd">    r2:    float</span>
<span class="sd">           r2 is resistance and is measured in ohm</span>


<span class="sd">    .. [1] Electronial, "LM317" BasicTables, Accessed May, 2022</span>
<span class="sd">       https://www.basictables.com/electronics/lm317</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">r1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">r2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Returns Voltage</span>
        <span class="k">return</span> <span class="mf">1.25</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">r2</span> <span class="o">/</span> <span class="n">r1</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">r2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">v_out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Returns R1</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">1.25</span> <span class="o">*</span> <span class="n">r2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">v_out</span> <span class="o">-</span> <span class="mf">1.25</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">r1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">v_out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Returns R2</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">r1</span> <span class="o">*</span> <span class="n">v_out</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.25</span><span class="p">)</span> <span class="o">-</span> <span class="n">r1</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Invalid arguments"</span><span class="p">)</span></div>


<span class="c1"># Define Module Specific Variables</span>
<span class="n">_name_</span> <span class="o">=</span> <span class="n">NAME</span>
<span class="n">_version_</span> <span class="o">=</span> <span class="n">VERSION</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="n">_version_</span>  <span class="c1"># Alias Version for User Ease</span>

<span class="c1"># END OF FILE</span>
</pre></div>

          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2022, Joe Stanley.
              
          </div>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>